webpackJsonp([1],Array(228).concat([
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(541)\n\nvar Component = __webpack_require__(86)(\n  /* script */\n  __webpack_require__(422),\n  /* template */\n  __webpack_require__(517),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"D:\\\\Study\\\\project\\\\vueManageSys\\\\VuemanageSys\\\\vue2-manage-master\\\\src\\\\page\\\\visitor.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] visitor.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (true) {(function () {\n  var hotAPI = __webpack_require__(51)\n  hotAPI.install(__webpack_require__(1), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-4cd6d3c1\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-4cd6d3c1\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvdmlzaXRvci52dWU/ZDFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3tcXFwibWluaW1pemVcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00Y2Q2ZDNjMVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IWxlc3MtbG9hZGVyP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi92aXNpdG9yLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGNkNmQzYzFcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdmlzaXRvci52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkQ6XFxcXFN0dWR5XFxcXHByb2plY3RcXFxcdnVlTWFuYWdlU3lzXFxcXFZ1ZW1hbmFnZVN5c1xcXFx2dWUyLW1hbmFnZS1tYXN0ZXJcXFxcc3JjXFxcXHBhZ2VcXFxcdmlzaXRvci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSB2aXNpdG9yLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi00Y2Q2ZDNjMVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTRjZDZkM2MxXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wYWdlL3Zpc2l0b3IudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///228\n");

/***/ }),
/* 229 */,
/* 230 */
/***/ (function(module, exports) {

eval("/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanM/MTBmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG52YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICdbb2JqZWN0IENhbnZhc10nOiAxXG59O1xudmFyIFRZUEVEX0FSUkFZID0ge1xuICAnW29iamVjdCBJbnQ4QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAxLFxuICAnW29iamVjdCBJbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiAxXG59O1xudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG52YXIgbmF0aXZlU2xpY2UgPSBhcnJheVByb3RvLnNsaWNlO1xudmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xudmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlOyAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG52YXIgbWV0aG9kcyA9IHt9O1xuXG5mdW5jdGlvbiAkb3ZlcnJpZGUobmFtZSwgZm4pIHtcbiAgbWV0aG9kc1tuYW1lXSA9IGZuO1xufVxuLyoqXG4gKiBUaG9zZSBkYXRhIHR5cGVzIGNhbiBiZSBjbG9uZWQ6XG4gKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICogICAgIEJVSUxUSU5fT0JKRUNUXG4gKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICogT3RoZXIgZGF0YSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkIChub3Qgc3VyZSB3aGF0IHdpbGwgaGFwcGVuKS5cbiAqXG4gKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAqIChUaGVyZSBtaWdodCBiZSBhIGxhcmdlIG51bWJlciBvZiBkYXRlIGluIGBzZXJpZXMuZGF0YWApLlxuICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHJldHVybiB7Kn0gbmV3XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZW3R5cGVTdHJdKSB7XG4gICAgdmFyIEN0b3IgPSBzb3VyY2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yLmZyb20pIHtcbiAgICAgIHJlc3VsdCA9IEN0b3IuZnJvbShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiYgaXNPYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzQXJyYXkoc291cmNlUHJvcCkgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcCkgJiYgIWlzRG9tKHNvdXJjZVByb3ApICYmICFpc0RvbSh0YXJnZXRQcm9wKSAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKSkge1xuICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWV0aG9kcy5jcmVhdGVDYW52YXMoKTtcbn07XG5cbm1ldGhvZHMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59OyAvLyBGSVhNRVxuXG5cbnZhciBfY3R4O1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIV9jdHgpIHtcbiAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICByZXR1cm4gX2N0eDtcbn1cbi8qKlxuICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICog5p6E6YCg57G757un5om/5YWz57O7XG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gKi9cblxuXG5mdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBGKCkge31cblxuICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICB9XG5cbiAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG59XG4vKipcbiAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG59XG4vKipcbiAqIOaVsOe7hOaIluWvueixoemBjeWOhlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKi9cblxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiDmlbDnu4TmmKDlsIRcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6L+H5rukXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8qKlxuICog5pWw57uE6aG55p+l5om+XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkge1xuICB2YXIgYXJncyA9IG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIFdoZXRoZXIgaXMgZXhhY3RseSBOYU4uIE5vdGljZSBpc05hTignYScpIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBlcU5hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuLyoqXG4gKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAqIExvdyBwZXJmb3JtYW5jZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmUyKHZhbHVlMCwgdmFsdWUxKSB7XG4gIHJldHVybiB2YWx1ZTAgIT0gbnVsbCA/IHZhbHVlMCA6IHZhbHVlMTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxICE9IG51bGwgPyB2YWx1ZTEgOiB2YWx1ZTI7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBzbGljZSgpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICogZS5nLlxuICogIDMgPT4gWzMsIDMsIDMsIDNdXG4gKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICogIFs0LCAzLCAyXSA9PiBbNCwgMywgMiwgM11cbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSB2YWxcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzQXJyYXkodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcbiAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgLy8gdG9wIHwgaG9yaXpvbnRhbCB8IGJvdHRvbVxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IGFzIHByaW1pdGl2ZSB0byBiZSBpZ25vcmVkIHRyYXZlcnNpbmcgY2hpbGRyZW4gaW4gY2xvbmUgb3IgbWVyZ2VcbiAqL1xuXG5mdW5jdGlvbiBzZXRBc1ByaW1pdGl2ZShvYmopIHtcbiAgb2JqW3ByaW1pdGl2ZUtleV0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT25seSBhcHBseSBgb3duUHJvcGVydHlgLlxuICovXG5cblxuZnVuY3Rpb24gSGFzaE1hcChvYmopIHtcbiAgb2JqICYmIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICB9LCB0aGlzKTtcbn0gLy8gQWRkIHByZWZpeCB0byBhdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUuXG5cblxudmFyIEhBU0hfTUFQX1BSRUZJWCA9ICdfZWNfJztcbnZhciBIQVNIX01BUF9QUkVGSVhfTEVOR1RIID0gNDtcbkhhc2hNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAvLyBmcm9tIEVTNiBNYXApLlxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldID0gdmFsdWU7IC8vIENvbXBhcmluZyB3aXRoIGludm9jYXRpb24gY2hhaW5pbmcsIGByZXR1cm4gdmFsdWVgIGlzIG1vcmUgY29tbW9ubHlcbiAgICAvLyB1c2VkIGluIHRoaXMgY2FzZTogYHZhciBzb21lVmFsID0gbWFwLnNldCgnYScsIGdlblZhbCgpKTtgXG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIC8vIEFsdGhvdWdoIHV0aWwuZWFjaCBjYW4gYmUgcGVyZm9ybWVkIG9uIHRoaXMgaGFzaE1hcCBkaXJlY3RseSwgdXNlclxuICAvLyBzaG91bGQgbm90IHVzZSB0aGUgZXhwb3NlZCBrZXlzLCB3aG8gYXJlIHByZWZpeGVkLlxuICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuXG4gICAgZm9yICh2YXIgcHJlZml4ZWRLZXkgaW4gdGhpcykge1xuICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXhlZEtleSkgJiYgY2IodGhpc1twcmVmaXhlZEtleV0sIHByZWZpeGVkS2V5LnNsaWNlKEhBU0hfTUFQX1BSRUZJWF9MRU5HVEgpKTtcbiAgICB9XG4gIH0sXG4gIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgdGhpc1tIQVNIX01BUF9QUkVGSVggKyBrZXldO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoTWFwKG9iaikge1xuICByZXR1cm4gbmV3IEhhc2hNYXAob2JqKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzQnVpbHRJbk9iamVjdCA9IGlzQnVpbHRJbk9iamVjdDtcbmV4cG9ydHMuaXNEb20gPSBpc0RvbTtcbmV4cG9ydHMuZXFOYU4gPSBlcU5hTjtcbmV4cG9ydHMucmV0cmlldmUgPSByZXRyaWV2ZTtcbmV4cG9ydHMucmV0cmlldmUyID0gcmV0cmlldmUyO1xuZXhwb3J0cy5yZXRyaWV2ZTMgPSByZXRyaWV2ZTM7XG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5leHBvcnRzLm5vcm1hbGl6ZUNzc0FycmF5ID0gbm9ybWFsaXplQ3NzQXJyYXk7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuc2V0QXNQcmltaXRpdmUgPSBzZXRBc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuY3JlYXRlSGFzaE1hcCA9IGNyZWF0ZUhhc2hNYXA7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///230\n");

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(52)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.allcover {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n}\\n.ctt {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n}\\n.tb {\\n  position: absolute;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n.lr {\\n  position: absolute;\\n  left: 50%;\\n  transform: translateX(-50%);\\n}\\n.header_container {\\n  background-color: #EFF2F7;\\n  height: 60px;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-pack: justify;\\n      justify-content: space-between;\\n  -ms-flex-align: center;\\n      align-items: center;\\n  padding-left: 20px;\\n}\\n.avator {\\n  width: 36px;\\n  height: 36px;\\n  border-radius: 50%;\\n  margin-right: 37px;\\n}\\n.el-dropdown-menu__item {\\n  text-align: center;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWU/ZTkxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hbGxjb3ZlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG59XFxuLmN0dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cXG4udGIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcbi5sciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcbi5oZWFkZXJfY29udGFpbmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNFRkYyRjc7XFxuICBoZWlnaHQ6IDYwcHg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmctbGVmdDogMjBweDtcXG59XFxuLmF2YXRvciB7XFxuICB3aWR0aDogMzZweDtcXG4gIGhlaWdodDogMzZweDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIG1hcmdpbi1yaWdodDogMzdweDtcXG59XFxuLmVsLWRyb3Bkb3duLW1lbnVfX2l0ZW0ge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj97XCJtaW5pbWl6ZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWI1NjgwZTIyXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1wic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWVcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///231\n");

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrender = __webpack_require__(297);\n\nvar zrUtil = __webpack_require__(230);\n\nvar colorTool = __webpack_require__(256);\n\nvar env = __webpack_require__(239);\n\nvar timsort = __webpack_require__(267);\n\nvar Eventful = __webpack_require__(252);\n\nvar GlobalModel = __webpack_require__(340);\n\nvar ExtensionAPI = __webpack_require__(327);\n\nvar CoordinateSystemManager = __webpack_require__(271);\n\nvar OptionManager = __webpack_require__(341);\n\nvar backwardCompat = __webpack_require__(348);\n\nvar ComponentModel = __webpack_require__(248);\n\nvar SeriesModel = __webpack_require__(277);\n\nvar ComponentView = __webpack_require__(302);\n\nvar ChartView = __webpack_require__(280);\n\nvar graphic = __webpack_require__(233);\n\nvar modelUtil = __webpack_require__(234);\n\nvar _throttle = __webpack_require__(273);\n\nvar throttle = _throttle.throttle;\n\nvar seriesColor = __webpack_require__(353);\n\nvar loadingDefault = __webpack_require__(339);\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\nvar each = zrUtil.each;\nvar parseClassType = ComponentModel.parseClassType;\nvar version = '3.8.5';\nvar dependencies = {\n  zrender: '3.7.4'\n};\nvar PRIORITY_PROCESSOR_FILTER = 1000;\nvar PRIORITY_PROCESSOR_STATISTIC = 5000;\nvar PRIORITY_VISUAL_LAYOUT = 1000;\nvar PRIORITY_VISUAL_GLOBAL = 2000;\nvar PRIORITY_VISUAL_CHART = 3000;\nvar PRIORITY_VISUAL_COMPONENT = 4000; // FIXME\n// necessary?\n\nvar PRIORITY_VISUAL_BRUSH = 5000;\nvar PRIORITY = {\n  PROCESSOR: {\n    FILTER: PRIORITY_PROCESSOR_FILTER,\n    STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n  },\n  VISUAL: {\n    LAYOUT: PRIORITY_VISUAL_LAYOUT,\n    GLOBAL: PRIORITY_VISUAL_GLOBAL,\n    CHART: PRIORITY_VISUAL_CHART,\n    COMPONENT: PRIORITY_VISUAL_COMPONENT,\n    BRUSH: PRIORITY_VISUAL_BRUSH\n  }\n}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n// where they must not be invoked nestedly, except the only case: invoke\n// dispatchAction with updateMethod \"none\" in main process.\n// This flag is used to carry out this rule.\n// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\nvar IN_MAIN_PROCESS = '__flagInMainProcess';\nvar HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\nvar OPTION_UPDATED = '__optionUpdated';\nvar ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\nfunction createRegisterEventWithLowercaseName(method) {\n  return function (eventName, handler, context) {\n    // Event name is all lowercase\n    eventName = eventName && eventName.toLowerCase();\n    Eventful.prototype[method].call(this, eventName, handler, context);\n  };\n}\n/**\n * @module echarts~MessageCenter\n */\n\n\nfunction MessageCenter() {\n  Eventful.call(this);\n}\n\nMessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\nMessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\nMessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\nzrUtil.mixin(MessageCenter, Eventful);\n/**\n * @module echarts~ECharts\n */\n\nfunction ECharts(dom, theme, opts) {\n  opts = opts || {}; // Get theme by name\n\n  if (typeof theme === 'string') {\n    theme = themeStorage[theme];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  this.id;\n  /**\n   * Group id\n   * @type {string}\n   */\n\n  this.group;\n  /**\n   * @type {HTMLElement}\n   * @private\n   */\n\n  this._dom = dom;\n  var defaultRenderer = 'canvas';\n\n  /**\n   * @type {module:zrender/ZRender}\n   * @private\n   */\n  var zr = this._zr = zrender.init(dom, {\n    renderer: opts.renderer || defaultRenderer,\n    devicePixelRatio: opts.devicePixelRatio,\n    width: opts.width,\n    height: opts.height\n  });\n  /**\n   * Expect 60 pfs.\n   * @type {Function}\n   * @private\n   */\n\n  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);\n  var theme = zrUtil.clone(theme);\n  theme && backwardCompat(theme, true);\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._theme = theme;\n  /**\n   * @type {Array.<module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsMap = {};\n  /**\n   * @type {Array.<module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsMap = {};\n  /**\n   * @type {module:echarts/CoordinateSystem}\n   * @private\n   */\n\n  this._coordSysMgr = new CoordinateSystemManager();\n  /**\n   * @type {module:echarts/ExtensionAPI}\n   * @private\n   */\n\n  this._api = createExtensionAPI(this);\n  Eventful.call(this);\n  /**\n   * @type {module:echarts~MessageCenter}\n   * @private\n   */\n\n  this._messageCenter = new MessageCenter(); // Init mouse events\n\n  this._initEvents(); // In case some people write `window.onresize = chart.resize`\n\n\n  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure\n\n  this._pendingActions = []; // Sort on demand\n\n  function prioritySortFunc(a, b) {\n    return a.prio - b.prio;\n  }\n\n  timsort(visualFuncs, prioritySortFunc);\n  timsort(dataProcessorFuncs, prioritySortFunc);\n  zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value.\n\n  zrUtil.setAsPrimitive(this);\n}\n\nvar echartsProto = ECharts.prototype;\n\nechartsProto._onframe = function () {\n  // Lazy update\n  if (this[OPTION_UPDATED]) {\n    var silent = this[OPTION_UPDATED].silent;\n    this[IN_MAIN_PROCESS] = true;\n    updateMethods.prepareAndUpdate.call(this);\n    this[IN_MAIN_PROCESS] = false;\n    this[OPTION_UPDATED] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @return {HTMLElement}\n */\n\n\nechartsProto.getDom = function () {\n  return this._dom;\n};\n/**\n * @return {module:zrender~ZRender}\n */\n\n\nechartsProto.getZr = function () {\n  return this._zr;\n};\n/**\n * Usage:\n * chart.setOption(option, notMerge, lazyUpdate);\n * chart.setOption(option, {\n *     notMerge: ...,\n *     lazyUpdate: ...,\n *     silent: ...\n * });\n *\n * @param {Object} option\n * @param {Object|boolean} [opts] opts or notMerge.\n * @param {boolean} [opts.notMerge=false]\n * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n */\n\n\nechartsProto.setOption = function (option, notMerge, lazyUpdate) {\n  var silent;\n\n  if (zrUtil.isObject(notMerge)) {\n    lazyUpdate = notMerge.lazyUpdate;\n    silent = notMerge.silent;\n    notMerge = notMerge.notMerge;\n  }\n\n  this[IN_MAIN_PROCESS] = true;\n\n  if (!this._model || notMerge) {\n    var optionManager = new OptionManager(this._api);\n    var theme = this._theme;\n    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n    ecModel.init(null, null, theme, optionManager);\n  }\n\n  this._model.setOption(option, optionPreprocessorFuncs);\n\n  if (lazyUpdate) {\n    this[OPTION_UPDATED] = {\n      silent: silent\n    };\n    this[IN_MAIN_PROCESS] = false;\n  } else {\n    updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be\n    // fetched after `setOption`.\n\n    this._zr.flush();\n\n    this[OPTION_UPDATED] = false;\n    this[IN_MAIN_PROCESS] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @DEPRECATED\n */\n\n\nechartsProto.setTheme = function () {\n  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n};\n/**\n * @return {module:echarts/model/Global}\n */\n\n\nechartsProto.getModel = function () {\n  return this._model;\n};\n/**\n * @return {Object}\n */\n\n\nechartsProto.getOption = function () {\n  return this._model && this._model.getOption();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getWidth = function () {\n  return this._zr.getWidth();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getHeight = function () {\n  return this._zr.getHeight();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getDevicePixelRatio = function () {\n  return this._zr.painter.dpr || window.devicePixelRatio || 1;\n};\n/**\n * Get canvas which has all thing rendered\n * @param {Object} opts\n * @param {string} [opts.backgroundColor]\n * @return {string}\n */\n\n\nechartsProto.getRenderedCanvas = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  opts = opts || {};\n  opts.pixelRatio = opts.pixelRatio || 1;\n  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.getRenderedCanvas(opts);\n};\n/**\n * Get svg data url\n * @return {string}\n */\n\n\nechartsProto.getSvgDataUrl = function () {\n  if (!env.svgSupported) {\n    return;\n  }\n\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.pathToSvg();\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n * @param {string} [opts.excludeComponents]\n */\n\n\nechartsProto.getDataURL = function (opts) {\n  opts = opts || {};\n  var excludeComponents = opts.excludeComponents;\n  var ecModel = this._model;\n  var excludesComponentViews = [];\n  var self = this;\n  each(excludeComponents, function (componentType) {\n    ecModel.eachComponent({\n      mainType: componentType\n    }, function (component) {\n      var view = self._componentsMap[component.__viewId];\n\n      if (!view.group.ignore) {\n        excludesComponentViews.push(view);\n        view.group.ignore = true;\n      }\n    });\n  });\n  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n  each(excludesComponentViews, function (view) {\n    view.group.ignore = false;\n  });\n  return url;\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n */\n\n\nechartsProto.getConnectedDataURL = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  var groupId = this.group;\n  var mathMin = Math.min;\n  var mathMax = Math.max;\n  var MAX_NUMBER = Infinity;\n\n  if (connectedGroups[groupId]) {\n    var left = MAX_NUMBER;\n    var top = MAX_NUMBER;\n    var right = -MAX_NUMBER;\n    var bottom = -MAX_NUMBER;\n    var canvasList = [];\n    var dpr = opts && opts.pixelRatio || 1;\n    zrUtil.each(instances, function (chart, id) {\n      if (chart.group === groupId) {\n        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n        var boundingRect = chart.getDom().getBoundingClientRect();\n        left = mathMin(boundingRect.left, left);\n        top = mathMin(boundingRect.top, top);\n        right = mathMax(boundingRect.right, right);\n        bottom = mathMax(boundingRect.bottom, bottom);\n        canvasList.push({\n          dom: canvas,\n          left: boundingRect.left,\n          top: boundingRect.top\n        });\n      }\n    });\n    left *= dpr;\n    top *= dpr;\n    right *= dpr;\n    bottom *= dpr;\n    var width = right - left;\n    var height = bottom - top;\n    var targetCanvas = zrUtil.createCanvas();\n    targetCanvas.width = width;\n    targetCanvas.height = height;\n    var zr = zrender.init(targetCanvas);\n    each(canvasList, function (item) {\n      var img = new graphic.Image({\n        style: {\n          x: item.left * dpr - left,\n          y: item.top * dpr - top,\n          image: item.dom\n        }\n      });\n      zr.add(img);\n    });\n    zr.refreshImmediately();\n    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n  } else {\n    return this.getDataURL(opts);\n  }\n};\n/**\n * Convert from logical coordinate system to pixel coordinate system.\n * See CoordinateSystem#convertToPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId, geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\n\nechartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n/**\n * Convert from pixel coordinate system to logical coordinate system.\n * See CoordinateSystem#convertFromPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\nechartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\nfunction doConvertPixel(methodName, finder, value) {\n  var ecModel = this._model;\n\n  var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n\n  for (var i = 0; i < coordSysList.length; i++) {\n    var coordSys = coordSysList[i];\n\n    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {\n      return result;\n    }\n  }\n}\n/**\n * Is the specified coordinate systems or components contain the given pixel point.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {boolean} result\n */\n\n\nechartsProto.containPixel = function (finder, value) {\n  var ecModel = this._model;\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n  zrUtil.each(finder, function (models, key) {\n    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n      var coordSys = model.coordinateSystem;\n\n      if (coordSys && coordSys.containPoint) {\n        result |= !!coordSys.containPoint(value);\n      } else if (key === 'seriesModels') {\n        var view = this._chartsMap[model.__viewId];\n\n        if (view && view.containPoint) {\n          result |= view.containPoint(value, model);\n        } else {}\n      } else {}\n    }, this);\n  }, this);\n  return !!result;\n};\n/**\n * Get visual from series or data.\n * @param {string|Object} finder\n *        If string, e.g., 'series', means {seriesIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            dataIndex / dataIndexInside\n *        }\n *        If dataIndex is not specified, series visual will be fetched,\n *        but not data item visual.\n *        If all of seriesIndex, seriesId, seriesName are not specified,\n *        visual will be fetched from first series.\n * @param {string} visualType 'color', 'symbol', 'symbolSize'\n */\n\n\nechartsProto.getVisual = function (finder, visualType) {\n  var ecModel = this._model;\n  finder = modelUtil.parseFinder(ecModel, finder, {\n    defaultMainType: 'series'\n  });\n  var seriesModel = finder.seriesModel;\n  var data = seriesModel.getData();\n  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;\n  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);\n};\n/**\n * Get view of corresponding component model\n * @param  {module:echarts/model/Component} componentModel\n * @return {module:echarts/view/Component}\n */\n\n\nechartsProto.getViewOfComponentModel = function (componentModel) {\n  return this._componentsMap[componentModel.__viewId];\n};\n/**\n * Get view of corresponding series model\n * @param  {module:echarts/model/Series} seriesModel\n * @return {module:echarts/view/Chart}\n */\n\n\nechartsProto.getViewOfSeriesModel = function (seriesModel) {\n  return this._chartsMap[seriesModel.__viewId];\n};\n\nvar updateMethods = {\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  update: function (payload) {\n    // console.profile && console.profile('update');\n    var ecModel = this._model;\n    var api = this._api;\n    var coordSysMgr = this._coordSysMgr;\n    var zr = this._zr; // update before setOption\n\n    if (!ecModel) {\n      return;\n    } // Fixme First time update ?\n\n\n    ecModel.restoreData(); // TODO\n    // Save total ecModel here for undo/redo (after restoring data and before processing data).\n    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n    // Create new coordinate system each update\n    // In LineView may save the old coordinate system and use it to get the orignal point\n\n    coordSysMgr.create(this._model, this._api);\n    processData.call(this, ecModel, api);\n    stackSeriesData.call(this, ecModel);\n    coordSysMgr.update(ecModel, api);\n    doVisualEncoding.call(this, ecModel, payload);\n    doRender.call(this, ecModel, payload); // Set background\n\n    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n    var painter = zr.painter; // TODO all use clearColor ?\n\n    if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n      zr.configLayer(0, {\n        clearColor: backgroundColor\n      });\n    } else {\n      // In IE8\n      if (!env.canvasSupported) {\n        var colorArr = colorTool.parse(backgroundColor);\n        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\n        if (colorArr[3] === 0) {\n          backgroundColor = 'transparent';\n        }\n      }\n\n      if (backgroundColor.colorStops || backgroundColor.image) {\n        // Gradient background\n        // FIXME Fixed layer？\n        zr.configLayer(0, {\n          clearColor: backgroundColor\n        });\n        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n        this._dom.style.background = 'transparent';\n      } else {\n        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n          zr.configLayer(0, {\n            clearColor: null\n          });\n        }\n\n        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n        this._dom.style.background = backgroundColor;\n      }\n    }\n\n    each(postUpdateFuncs, function (func) {\n      func(ecModel, api);\n    }); // console.profile && console.profileEnd('update');\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateView: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateVisual: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload, true);\n    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateLayout: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    doLayout.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  prepareAndUpdate: function (payload) {\n    var ecModel = this._model;\n    prepareView.call(this, 'component', ecModel);\n    prepareView.call(this, 'chart', ecModel);\n    updateMethods.update.call(this, payload);\n  }\n};\n/**\n * @private\n */\n\nfunction updateDirectly(ecIns, method, payload, mainType, subType) {\n  var ecModel = ecIns._model; // broadcast\n\n  if (!mainType) {\n    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n    return;\n  }\n\n  var query = {};\n  query[mainType + 'Id'] = payload[mainType + 'Id'];\n  query[mainType + 'Index'] = payload[mainType + 'Index'];\n  query[mainType + 'Name'] = payload[mainType + 'Name'];\n  var condition = {\n    mainType: mainType,\n    query: query\n  };\n  subType && (condition.subType = subType); // subType may be '' by parseClassType;\n  // If dispatchAction before setOption, do nothing.\n\n  ecModel && ecModel.eachComponent(condition, function (model, index) {\n    callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);\n  }, ecIns);\n\n  function callView(view) {\n    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);\n  }\n}\n/**\n * Resize the chart\n * @param {Object} opts\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n * @param {boolean} [opts.silent=false]\n */\n\n\nechartsProto.resize = function (opts) {\n  this[IN_MAIN_PROCESS] = true;\n\n  this._zr.resize(opts);\n\n  var optionChanged = this._model && this._model.resetOption('media');\n\n  var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n  updateMethods[updateMethod].call(this); // Resize loading effect\n\n  this._loadingFX && this._loadingFX.resize();\n  this[IN_MAIN_PROCESS] = false;\n  var silent = opts && opts.silent;\n  flushPendingActions.call(this, silent);\n  triggerUpdatedEvent.call(this, silent);\n};\n/**\n * Show loading effect\n * @param  {string} [name='default']\n * @param  {Object} [cfg]\n */\n\n\nechartsProto.showLoading = function (name, cfg) {\n  if (zrUtil.isObject(name)) {\n    cfg = name;\n    name = '';\n  }\n\n  name = name || 'default';\n  this.hideLoading();\n\n  if (!loadingEffects[name]) {\n    return;\n  }\n\n  var el = loadingEffects[name](this._api, cfg);\n  var zr = this._zr;\n  this._loadingFX = el;\n  zr.add(el);\n};\n/**\n * Hide loading effect\n */\n\n\nechartsProto.hideLoading = function () {\n  this._loadingFX && this._zr.remove(this._loadingFX);\n  this._loadingFX = null;\n};\n/**\n * @param {Object} eventObj\n * @return {Object}\n */\n\n\nechartsProto.makeActionFromEvent = function (eventObj) {\n  var payload = zrUtil.extend({}, eventObj);\n  payload.type = eventActionMap[eventObj.type];\n  return payload;\n};\n/**\n * @pubilc\n * @param {Object} payload\n * @param {string} [payload.type] Action type\n * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n * @param {boolean} [opt.silent=false] Whether trigger events.\n * @param {boolean} [opt.flush=undefined]\n *                  true: Flush immediately, and then pixel in canvas can be fetched\n *                      immediately. Caution: it might affect performance.\n *                  false: Not not flush.\n *                  undefined: Auto decide whether perform flush.\n */\n\n\nechartsProto.dispatchAction = function (payload, opt) {\n  if (!zrUtil.isObject(opt)) {\n    opt = {\n      silent: !!opt\n    };\n  }\n\n  if (!actions[payload.type]) {\n    return;\n  } // Avoid dispatch action before setOption. Especially in `connect`.\n\n\n  if (!this._model) {\n    return;\n  } // May dispatchAction in rendering procedure\n\n\n  if (this[IN_MAIN_PROCESS]) {\n    this._pendingActions.push(payload);\n\n    return;\n  }\n\n  doDispatchAction.call(this, payload, opt.silent);\n\n  if (opt.flush) {\n    this._zr.flush(true);\n  } else if (opt.flush !== false && env.browser.weChat) {\n    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n    // hang when sliding page (on touch event), which cause that zr does not\n    // refresh util user interaction finished, which is not expected.\n    // But `dispatchAction` may be called too frequently when pan on touch\n    // screen, which impacts performance if do not throttle them.\n    this._throttledZrFlush();\n  }\n\n  flushPendingActions.call(this, opt.silent);\n  triggerUpdatedEvent.call(this, opt.silent);\n};\n\nfunction doDispatchAction(payload, silent) {\n  var payloadType = payload.type;\n  var escapeConnect = payload.escapeConnect;\n  var actionWrap = actions[payloadType];\n  var actionInfo = actionWrap.actionInfo;\n  var cptType = (actionInfo.update || 'update').split(':');\n  var updateMethod = cptType.pop();\n  cptType = cptType[0] != null && parseClassType(cptType[0]);\n  this[IN_MAIN_PROCESS] = true;\n  var payloads = [payload];\n  var batched = false; // Batch action\n\n  if (payload.batch) {\n    batched = true;\n    payloads = zrUtil.map(payload.batch, function (item) {\n      item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n      item.batch = null;\n      return item;\n    });\n  }\n\n  var eventObjBatch = [];\n  var eventObj;\n  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n  each(payloads, function (batchItem) {\n    // Action can specify the event by return it.\n    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside\n\n    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType\n\n    eventObj.type = actionInfo.event || eventObj.type;\n    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.\n\n    if (isHighDown) {\n      // method, payload, mainType, subType\n      updateDirectly(this, updateMethod, batchItem, 'series');\n    } else if (cptType) {\n      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n    }\n  }, this);\n\n  if (updateMethod !== 'none' && !isHighDown && !cptType) {\n    // Still dirty\n    if (this[OPTION_UPDATED]) {\n      // FIXME Pass payload ?\n      updateMethods.prepareAndUpdate.call(this, payload);\n      this[OPTION_UPDATED] = false;\n    } else {\n      updateMethods[updateMethod].call(this, payload);\n    }\n  } // Follow the rule of action batch\n\n\n  if (batched) {\n    eventObj = {\n      type: actionInfo.event || payloadType,\n      escapeConnect: escapeConnect,\n      batch: eventObjBatch\n    };\n  } else {\n    eventObj = eventObjBatch[0];\n  }\n\n  this[IN_MAIN_PROCESS] = false;\n  !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n}\n\nfunction flushPendingActions(silent) {\n  var pendingActions = this._pendingActions;\n\n  while (pendingActions.length) {\n    var payload = pendingActions.shift();\n    doDispatchAction.call(this, payload, silent);\n  }\n}\n\nfunction triggerUpdatedEvent(silent) {\n  !silent && this.trigger('updated');\n}\n/**\n * Register event\n * @method\n */\n\n\nechartsProto.on = createRegisterEventWithLowercaseName('on');\nechartsProto.off = createRegisterEventWithLowercaseName('off');\nechartsProto.one = createRegisterEventWithLowercaseName('one');\n/**\n * @param {string} methodName\n * @private\n */\n\nfunction invokeUpdateMethod(methodName, ecModel, payload) {\n  var api = this._api; // Update all components\n\n  each(this._componentsViews, function (component) {\n    var componentModel = component.__model;\n    component[methodName](componentModel, ecModel, api, payload);\n    updateZ(componentModel, component);\n  }, this); // Upate all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chart = this._chartsMap[seriesModel.__viewId];\n    chart[methodName](seriesModel, ecModel, api, payload);\n    updateZ(seriesModel, chart);\n    updateProgressiveAndBlend(seriesModel, chart);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Post render\n\n  each(postUpdateFuncs, function (func) {\n    func(ecModel, api);\n  });\n}\n/**\n * Prepare view instances of charts and components\n * @param  {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction prepareView(type, ecModel) {\n  var isComponent = type === 'component';\n  var viewList = isComponent ? this._componentsViews : this._chartsViews;\n  var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n  var zr = this._zr;\n\n  for (var i = 0; i < viewList.length; i++) {\n    viewList[i].__alive = false;\n  }\n\n  ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n    if (isComponent) {\n      if (componentType === 'series') {\n        return;\n      }\n    } else {\n      model = componentType;\n    } // Consider: id same and type changed.\n\n\n    var viewId = '_ec_' + model.id + '_' + model.type;\n    var view = viewMap[viewId];\n\n    if (!view) {\n      var classType = parseClassType(model.type);\n      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\n      if (Clazz) {\n        view = new Clazz();\n        view.init(ecModel, this._api);\n        viewMap[viewId] = view;\n        viewList.push(view);\n        zr.add(view.group);\n      } else {\n        // Error\n        return;\n      }\n    }\n\n    model.__viewId = view.__id = viewId;\n    view.__alive = true;\n    view.__model = model;\n    view.group.__ecComponentInfo = {\n      mainType: model.mainType,\n      index: model.componentIndex\n    };\n  }, this);\n\n  for (var i = 0; i < viewList.length;) {\n    var view = viewList[i];\n\n    if (!view.__alive) {\n      zr.remove(view.group);\n      view.dispose(ecModel, this._api);\n      viewList.splice(i, 1);\n      delete viewMap[view.__id];\n      view.__id = view.group.__ecComponentInfo = null;\n    } else {\n      i++;\n    }\n  }\n}\n/**\n * Processor data in each series\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction processData(ecModel, api) {\n  each(dataProcessorFuncs, function (process) {\n    process.func(ecModel, api);\n  });\n}\n/**\n * @private\n */\n\n\nfunction stackSeriesData(ecModel) {\n  var stackedDataMap = {};\n  ecModel.eachSeries(function (series) {\n    var stack = series.get('stack');\n    var data = series.getData();\n\n    if (stack && data.type === 'list') {\n      var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype\n\n      if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n        data.stackedOn = previousStack;\n      }\n\n      stackedDataMap[stack] = data;\n    }\n  });\n}\n/**\n * Layout before each chart render there series, special visual encoding stage\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction doLayout(ecModel, payload) {\n  var api = this._api;\n  each(visualFuncs, function (visual) {\n    if (visual.isLayout) {\n      visual.func(ecModel, api, payload);\n    }\n  });\n}\n/**\n * Encode visual infomation from data after data processing\n *\n * @param {module:echarts/model/Global} ecModel\n * @param {object} layout\n * @param {boolean} [excludesLayout]\n * @private\n */\n\n\nfunction doVisualEncoding(ecModel, payload, excludesLayout) {\n  var api = this._api;\n  ecModel.clearColorPalette();\n  ecModel.eachSeries(function (seriesModel) {\n    seriesModel.clearColorPalette();\n  });\n  each(visualFuncs, function (visual) {\n    (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);\n  });\n}\n/**\n * Render each chart and component\n * @private\n */\n\n\nfunction doRender(ecModel, payload) {\n  var api = this._api; // Render all components\n\n  each(this._componentsViews, function (componentView) {\n    var componentModel = componentView.__model;\n    componentView.render(componentModel, ecModel, api, payload);\n    updateZ(componentModel, componentView);\n  }, this);\n  each(this._chartsViews, function (chart) {\n    chart.__alive = false;\n  }, this); // Render all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chartView = this._chartsMap[seriesModel.__viewId];\n    chartView.__alive = true;\n    chartView.render(seriesModel, ecModel, api, payload);\n    chartView.group.silent = !!seriesModel.get('silent');\n    updateZ(seriesModel, chartView);\n    updateProgressiveAndBlend(seriesModel, chartView);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts\n\n  each(this._chartsViews, function (chart) {\n    if (!chart.__alive) {\n      chart.remove(ecModel, api);\n    }\n  }, this);\n}\n\nvar MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];\n/**\n * @private\n */\n\nechartsProto._initEvents = function () {\n  each(MOUSE_EVENT_NAMES, function (eveName) {\n    this._zr.on(eveName, function (e) {\n      var ecModel = this.getModel();\n      var el = e.target;\n      var params; // no e.target when 'globalout'.\n\n      if (eveName === 'globalout') {\n        params = {};\n      } else if (el && el.dataIndex != null) {\n        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n      } // If element has custom eventData of components\n      else if (el && el.eventData) {\n          params = zrUtil.extend({}, el.eventData);\n        }\n\n      if (params) {\n        params.event = e;\n        params.type = eveName;\n        this.trigger(eveName, params);\n      }\n    }, this);\n  }, this);\n  each(eventActionMap, function (actionType, eventType) {\n    this._messageCenter.on(eventType, function (event) {\n      this.trigger(eventType, event);\n    }, this);\n  }, this);\n};\n/**\n * @return {boolean}\n */\n\n\nechartsProto.isDisposed = function () {\n  return this._disposed;\n};\n/**\n * Clear\n */\n\n\nechartsProto.clear = function () {\n  this.setOption({\n    series: []\n  }, true);\n};\n/**\n * Dispose instance\n */\n\n\nechartsProto.dispose = function () {\n  if (this._disposed) {\n    return;\n  }\n\n  this._disposed = true;\n  var api = this._api;\n  var ecModel = this._model;\n  each(this._componentsViews, function (component) {\n    component.dispose(ecModel, api);\n  });\n  each(this._chartsViews, function (chart) {\n    chart.dispose(ecModel, api);\n  }); // Dispose after all views disposed\n\n  this._zr.dispose();\n\n  delete instances[this.id];\n};\n\nzrUtil.mixin(ECharts, Eventful);\n\nfunction updateHoverLayerStatus(zr, ecModel) {\n  var storage = zr.storage;\n  var elCount = 0;\n  storage.traverse(function (el) {\n    if (!el.isGroup) {\n      elCount++;\n    }\n  });\n\n  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n    storage.traverse(function (el) {\n      if (!el.isGroup) {\n        el.useHoverLayer = true;\n      }\n    });\n  }\n}\n/**\n * Update chart progressive and blend.\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateProgressiveAndBlend(seriesModel, chartView) {\n  // Progressive configuration\n  var elCount = 0;\n  chartView.group.traverse(function (el) {\n    if (el.type !== 'group' && !el.ignore) {\n      elCount++;\n    }\n  });\n  var frameDrawNum = +seriesModel.get('progressive');\n  var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\n  if (needProgressive) {\n    chartView.group.traverse(function (el) {\n      // FIXME marker and other components\n      if (!el.isGroup) {\n        el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\n        if (needProgressive) {\n          el.stopAnimation(true);\n        }\n      }\n    });\n  } // Blend configration\n\n\n  var blendMode = seriesModel.get('blendMode') || null;\n  chartView.group.traverse(function (el) {\n    // FIXME marker and other components\n    if (!el.isGroup) {\n      el.setStyle('blend', blendMode);\n    }\n  });\n}\n/**\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateZ(model, view) {\n  var z = model.get('z');\n  var zlevel = model.get('zlevel'); // Set z and zlevel\n\n  view.group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n    }\n  });\n}\n\nfunction createExtensionAPI(ecInstance) {\n  var coordSysMgr = ecInstance._coordSysMgr;\n  return zrUtil.extend(new ExtensionAPI(ecInstance), {\n    // Inject methods\n    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),\n    getComponentByElement: function (el) {\n      while (el) {\n        var modelInfo = el.__ecComponentInfo;\n\n        if (modelInfo != null) {\n          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n        }\n\n        el = el.parent;\n      }\n    }\n  });\n}\n/**\n * @type {Object} key: actionType.\n * @inner\n */\n\n\nvar actions = {};\n/**\n * Map eventType to actionType\n * @type {Object}\n */\n\nvar eventActionMap = {};\n/**\n * Data processor functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar dataProcessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar optionPreprocessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar postUpdateFuncs = [];\n/**\n * Visual encoding functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar visualFuncs = [];\n/**\n * Theme storage\n * @type {Object.<key, Object>}\n */\n\nvar themeStorage = {};\n/**\n * Loading effects\n */\n\nvar loadingEffects = {};\nvar instances = {};\nvar connectedGroups = {};\nvar idBase = new Date() - 0;\nvar groupIdBase = new Date() - 0;\nvar DOM_ATTRIBUTE_KEY = '_echarts_instance_';\nvar mapDataStores = {};\n\nfunction enableConnect(chart) {\n  var STATUS_PENDING = 0;\n  var STATUS_UPDATING = 1;\n  var STATUS_UPDATED = 2;\n  var STATUS_KEY = '__connectUpdateStatus';\n\n  function updateConnectedChartsStatus(charts, status) {\n    for (var i = 0; i < charts.length; i++) {\n      var otherChart = charts[i];\n      otherChart[STATUS_KEY] = status;\n    }\n  }\n\n  zrUtil.each(eventActionMap, function (actionType, eventType) {\n    chart._messageCenter.on(eventType, function (event) {\n      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n        if (event && event.escapeConnect) {\n          return;\n        }\n\n        var action = chart.makeActionFromEvent(event);\n        var otherCharts = [];\n        zrUtil.each(instances, function (otherChart) {\n          if (otherChart !== chart && otherChart.group === chart.group) {\n            otherCharts.push(otherChart);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n        each(otherCharts, function (otherChart) {\n          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n            otherChart.dispatchAction(action);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n      }\n    });\n  });\n}\n/**\n * @param {HTMLElement} dom\n * @param {Object} [theme]\n * @param {Object} opts\n * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n *                              Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n *                               Can be 'auto' (the same as null/undefined)\n */\n\n\nfunction init(dom, theme, opts) {\n  var existInstance = getInstanceByDom(dom);\n\n  if (existInstance) {\n    return existInstance;\n  }\n\n  var chart = new ECharts(dom, theme, opts);\n  chart.id = 'ec_' + idBase++;\n  instances[chart.id] = chart;\n\n  if (dom.setAttribute) {\n    dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n  } else {\n    dom[DOM_ATTRIBUTE_KEY] = chart.id;\n  }\n\n  enableConnect(chart);\n  return chart;\n}\n/**\n * @return {string|Array.<module:echarts~ECharts>} groupId\n */\n\n\nfunction connect(groupId) {\n  // Is array of charts\n  if (zrUtil.isArray(groupId)) {\n    var charts = groupId;\n    groupId = null; // If any chart has group\n\n    zrUtil.each(charts, function (chart) {\n      if (chart.group != null) {\n        groupId = chart.group;\n      }\n    });\n    groupId = groupId || 'g_' + groupIdBase++;\n    zrUtil.each(charts, function (chart) {\n      chart.group = groupId;\n    });\n  }\n\n  connectedGroups[groupId] = true;\n  return groupId;\n}\n/**\n * @DEPRECATED\n * @return {string} groupId\n */\n\n\nfunction disConnect(groupId) {\n  connectedGroups[groupId] = false;\n}\n/**\n * @return {string} groupId\n */\n\n\nvar disconnect = disConnect;\n/**\n * Dispose a chart instance\n * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n */\n\nfunction dispose(chart) {\n  if (typeof chart === 'string') {\n    chart = instances[chart];\n  } else if (!(chart instanceof ECharts)) {\n    // Try to treat as dom\n    chart = getInstanceByDom(chart);\n  }\n\n  if (chart instanceof ECharts && !chart.isDisposed()) {\n    chart.dispose();\n  }\n}\n/**\n * @param  {HTMLElement} dom\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceByDom(dom) {\n  var key;\n\n  if (dom.getAttribute) {\n    key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n  } else {\n    key = dom[DOM_ATTRIBUTE_KEY];\n  }\n\n  return instances[key];\n}\n/**\n * @param {string} key\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceById(key) {\n  return instances[key];\n}\n/**\n * Register theme\n */\n\n\nfunction registerTheme(name, theme) {\n  themeStorage[name] = theme;\n}\n/**\n * Register option preprocessor\n * @param {Function} preprocessorFunc\n */\n\n\nfunction registerPreprocessor(preprocessorFunc) {\n  optionPreprocessorFuncs.push(preprocessorFunc);\n}\n/**\n * @param {number} [priority=1000]\n * @param {Function} processorFunc\n */\n\n\nfunction registerProcessor(priority, processorFunc) {\n  if (typeof priority === 'function') {\n    processorFunc = priority;\n    priority = PRIORITY_PROCESSOR_FILTER;\n  }\n\n  dataProcessorFuncs.push({\n    prio: priority,\n    func: processorFunc\n  });\n}\n/**\n * Register postUpdater\n * @param {Function} postUpdateFunc\n */\n\n\nfunction registerPostUpdate(postUpdateFunc) {\n  postUpdateFuncs.push(postUpdateFunc);\n}\n/**\n * Usage:\n * registerAction('someAction', 'someEvent', function () { ... });\n * registerAction('someAction', function () { ... });\n * registerAction(\n *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n *     function () { ... }\n * );\n *\n * @param {(string|Object)} actionInfo\n * @param {string} actionInfo.type\n * @param {string} [actionInfo.event]\n * @param {string} [actionInfo.update]\n * @param {string} [eventName]\n * @param {Function} action\n */\n\n\nfunction registerAction(actionInfo, eventName, action) {\n  if (typeof eventName === 'function') {\n    action = eventName;\n    eventName = '';\n  }\n\n  var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {\n    event: eventName\n  }][0]; // Event name is all lowercase\n\n  actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n  eventName = actionInfo.event; // Validate action type and event name.\n\n  zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n  if (!actions[actionType]) {\n    actions[actionType] = {\n      action: action,\n      actionInfo: actionInfo\n    };\n  }\n\n  eventActionMap[eventName] = actionType;\n}\n/**\n * @param {string} type\n * @param {*} CoordinateSystem\n */\n\n\nfunction registerCoordinateSystem(type, CoordinateSystem) {\n  CoordinateSystemManager.register(type, CoordinateSystem);\n}\n/**\n * Get dimensions of specified coordinate system.\n * @param {string} type\n * @return {Array.<string|Object>}\n */\n\n\nfunction getCoordinateSystemDimensions(type) {\n  var coordSysCreator = CoordinateSystemManager.get(type);\n\n  if (coordSysCreator) {\n    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();\n  }\n}\n/**\n * Layout is a special stage of visual encoding\n * Most visual encoding like color are common for different chart\n * But each chart has it's own layout algorithm\n *\n * @param {number} [priority=1000]\n * @param {Function} layoutFunc\n */\n\n\nfunction registerLayout(priority, layoutFunc) {\n  if (typeof priority === 'function') {\n    layoutFunc = priority;\n    priority = PRIORITY_VISUAL_LAYOUT;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: layoutFunc,\n    isLayout: true\n  });\n}\n/**\n * @param {number} [priority=3000]\n * @param {Function} visualFunc\n */\n\n\nfunction registerVisual(priority, visualFunc) {\n  if (typeof priority === 'function') {\n    visualFunc = priority;\n    priority = PRIORITY_VISUAL_CHART;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: visualFunc\n  });\n}\n/**\n * @param {string} name\n */\n\n\nfunction registerLoading(name, loadingFx) {\n  loadingEffects[name] = loadingFx;\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentModel(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentModel;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentView(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentView;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentView.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendSeriesModel(opts\n/*, superClass*/\n) {\n  // var Clazz = SeriesModel;\n  // if (superClass) {\n  //     superClass = 'series.' + superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return SeriesModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendChartView(opts\n/*, superClass*/\n) {\n  // var Clazz = ChartView;\n  // if (superClass) {\n  //     superClass = superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ChartView.getClass(classType.main, true);\n  // }\n  return ChartView.extend(opts);\n}\n/**\n * ZRender need a canvas context to do measureText.\n * But in node environment canvas may be created by node-canvas.\n * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n *\n * Be careful of using it in the browser.\n *\n * @param {Function} creator\n * @example\n *     var Canvas = require('canvas');\n *     var echarts = require('echarts');\n *     echarts.setCanvasCreator(function () {\n *         // Small size is enough.\n *         return new Canvas(32, 32);\n *     });\n */\n\n\nfunction setCanvasCreator(creator) {\n  zrUtil.$override('createCanvas', creator);\n}\n/**\n * @param {string} mapName\n * @param {Object|string} geoJson\n * @param {Object} [specialAreas]\n *\n * @example\n *     $.get('USA.json', function (geoJson) {\n *         echarts.registerMap('USA', geoJson);\n *         // Or\n *         echarts.registerMap('USA', {\n *             geoJson: geoJson,\n *             specialAreas: {}\n *         })\n *     });\n */\n\n\nfunction registerMap(mapName, geoJson, specialAreas) {\n  if (geoJson.geoJson && !geoJson.features) {\n    specialAreas = geoJson.specialAreas;\n    geoJson = geoJson.geoJson;\n  }\n\n  if (typeof geoJson === 'string') {\n    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();\n  }\n\n  mapDataStores[mapName] = {\n    geoJson: geoJson,\n    specialAreas: specialAreas\n  };\n}\n/**\n * @param {string} mapName\n * @return {Object}\n */\n\n\nfunction getMap(mapName) {\n  return mapDataStores[mapName];\n}\n\nregisterVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);\nregisterPreprocessor(backwardCompat);\nregisterLoading('default', loadingDefault); // Default actions\n\nregisterAction({\n  type: 'highlight',\n  event: 'highlight',\n  update: 'highlight'\n}, zrUtil.noop);\nregisterAction({\n  type: 'downplay',\n  event: 'downplay',\n  update: 'downplay'\n}, zrUtil.noop); // For backward compatibility, where the namespace `dataTool` will\n// be mounted on `echarts` is the extension `dataTool` is imported.\n\nvar dataTool = {};\nexports.version = version;\nexports.dependencies = dependencies;\nexports.PRIORITY = PRIORITY;\nexports.init = init;\nexports.connect = connect;\nexports.disConnect = disConnect;\nexports.disconnect = disconnect;\nexports.dispose = dispose;\nexports.getInstanceByDom = getInstanceByDom;\nexports.getInstanceById = getInstanceById;\nexports.registerTheme = registerTheme;\nexports.registerPreprocessor = registerPreprocessor;\nexports.registerProcessor = registerProcessor;\nexports.registerPostUpdate = registerPostUpdate;\nexports.registerAction = registerAction;\nexports.registerCoordinateSystem = registerCoordinateSystem;\nexports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;\nexports.registerLayout = registerLayout;\nexports.registerVisual = registerVisual;\nexports.registerLoading = registerLoading;\nexports.extendComponentModel = extendComponentModel;\nexports.extendComponentView = extendComponentView;\nexports.extendSeriesModel = extendSeriesModel;\nexports.extendChartView = extendChartView;\nexports.setCanvasCreator = setCanvasCreator;\nexports.registerMap = registerMap;\nexports.getMap = getMap;\nexports.dataTool = dataTool;\nvar ___ec_export = __webpack_require__(337);\n(function () {\n    for (var key in ___ec_export) {\n        if (___ec_export.hasOwnProperty(key)) {\n            exports[key] = ___ec_export[key];\n        }\n    }\n})();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9lY2hhcnRzLmpzPzY4YTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJlbmRlciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi96cmVuZGVyXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi90b29sL2NvbG9yXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIEdsb2JhbE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvR2xvYmFsXCIpO1xuXG52YXIgRXh0ZW5zaW9uQVBJID0gcmVxdWlyZShcIi4vRXh0ZW5zaW9uQVBJXCIpO1xuXG52YXIgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIgPSByZXF1aXJlKFwiLi9Db29yZGluYXRlU3lzdGVtXCIpO1xuXG52YXIgT3B0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL21vZGVsL09wdGlvbk1hbmFnZXJcIik7XG5cbnZhciBiYWNrd2FyZENvbXBhdCA9IHJlcXVpcmUoXCIuL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG52YXIgU2VyaWVzTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9TZXJpZXNcIik7XG5cbnZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZShcIi4vdmlldy9Db21wb25lbnRcIik7XG5cbnZhciBDaGFydFZpZXcgPSByZXF1aXJlKFwiLi92aWV3L0NoYXJ0XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuL3V0aWwvZ3JhcGhpY1wiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbW9kZWxcIik7XG5cbnZhciBfdGhyb3R0bGUgPSByZXF1aXJlKFwiLi91dGlsL3Rocm90dGxlXCIpO1xuXG52YXIgdGhyb3R0bGUgPSBfdGhyb3R0bGUudGhyb3R0bGU7XG5cbnZhciBzZXJpZXNDb2xvciA9IHJlcXVpcmUoXCIuL3Zpc3VhbC9zZXJpZXNDb2xvclwiKTtcblxudmFyIGxvYWRpbmdEZWZhdWx0ID0gcmVxdWlyZShcIi4vbG9hZGluZy9kZWZhdWx0XCIpO1xuXG4vKiFcbiAqIEVDaGFydHMsIGEgamF2YXNjcmlwdCBpbnRlcmFjdGl2ZSBjaGFydCBsaWJyYXJ5LlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgQmFpZHUgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL2VjaGFydHMvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBwYXJzZUNsYXNzVHlwZSA9IENvbXBvbmVudE1vZGVsLnBhcnNlQ2xhc3NUeXBlO1xudmFyIHZlcnNpb24gPSAnMy44LjUnO1xudmFyIGRlcGVuZGVuY2llcyA9IHtcbiAgenJlbmRlcjogJzMuNy40J1xufTtcbnZhciBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSID0gMTAwMDtcbnZhciBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDID0gNTAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfTEFZT1VUID0gMTAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfR0xPQkFMID0gMjAwMDtcbnZhciBQUklPUklUWV9WSVNVQUxfQ0hBUlQgPSAzMDAwO1xudmFyIFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQgPSA0MDAwOyAvLyBGSVhNRVxuLy8gbmVjZXNzYXJ5P1xuXG52YXIgUFJJT1JJVFlfVklTVUFMX0JSVVNIID0gNTAwMDtcbnZhciBQUklPUklUWSA9IHtcbiAgUFJPQ0VTU09SOiB7XG4gICAgRklMVEVSOiBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSLFxuICAgIFNUQVRJU1RJQzogUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQ1xuICB9LFxuICBWSVNVQUw6IHtcbiAgICBMQVlPVVQ6IFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQsXG4gICAgR0xPQkFMOiBQUklPUklUWV9WSVNVQUxfR0xPQkFMLFxuICAgIENIQVJUOiBQUklPUklUWV9WSVNVQUxfQ0hBUlQsXG4gICAgQ09NUE9ORU5UOiBQUklPUklUWV9WSVNVQUxfQ09NUE9ORU5ULFxuICAgIEJSVVNIOiBQUklPUklUWV9WSVNVQUxfQlJVU0hcbiAgfVxufTsgLy8gTWFpbiBwcm9jZXNzIGhhdmUgdGhyZWUgZW50cmllczogYHNldE9wdGlvbmAsIGBkaXNwYXRjaEFjdGlvbmAgYW5kIGByZXNpemVgLFxuLy8gd2hlcmUgdGhleSBtdXN0IG5vdCBiZSBpbnZva2VkIG5lc3RlZGx5LCBleGNlcHQgdGhlIG9ubHkgY2FzZTogaW52b2tlXG4vLyBkaXNwYXRjaEFjdGlvbiB3aXRoIHVwZGF0ZU1ldGhvZCBcIm5vbmVcIiBpbiBtYWluIHByb2Nlc3MuXG4vLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBjYXJyeSBvdXQgdGhpcyBydWxlLlxuLy8gQWxsIGV2ZW50cyB3aWxsIGJlIHRyaWdnZXJlZCBvdXQgc2lkZSBtYWluIHByb2Nlc3MgKGkuZS4gd2hlbiAhdGhpc1tJTl9NQUlOX1BST0NFU1NdKS5cblxudmFyIElOX01BSU5fUFJPQ0VTUyA9ICdfX2ZsYWdJbk1haW5Qcm9jZXNzJztcbnZhciBIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CRyA9ICdfX2hhc0dyYWRpZW50T3JQYXR0ZXJuQmcnO1xudmFyIE9QVElPTl9VUERBVEVEID0gJ19fb3B0aW9uVXBkYXRlZCc7XG52YXIgQUNUSU9OX1JFRyA9IC9eW2EtekEtWjAtOV9dKyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG4gICAgZXZlbnROYW1lID0gZXZlbnROYW1lICYmIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIEV2ZW50ZnVsLnByb3RvdHlwZVttZXRob2RdLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgfTtcbn1cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzfk1lc3NhZ2VDZW50ZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIE1lc3NhZ2VDZW50ZXIoKSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG59XG5cbk1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbicpO1xuTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbk1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9uZSA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb25lJyk7XG56clV0aWwubWl4aW4oTWVzc2FnZUNlbnRlciwgRXZlbnRmdWwpO1xuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHN+RUNoYXJ0c1xuICovXG5cbmZ1bmN0aW9uIEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gR2V0IHRoZW1lIGJ5IG5hbWVcblxuICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgIHRoZW1lID0gdGhlbWVTdG9yYWdlW3RoZW1lXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cblxuICB0aGlzLmlkO1xuICAvKipcbiAgICogR3JvdXAgaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5ncm91cDtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fZG9tID0gZG9tO1xuICB2YXIgZGVmYXVsdFJlbmRlcmVyID0gJ2NhbnZhcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHpyID0gdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XG4gICAgcmVuZGVyZXI6IG9wdHMucmVuZGVyZXIgfHwgZGVmYXVsdFJlbmRlcmVyLFxuICAgIGRldmljZVBpeGVsUmF0aW86IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICBoZWlnaHQ6IG9wdHMuaGVpZ2h0XG4gIH0pO1xuICAvKipcbiAgICogRXhwZWN0IDYwIHBmcy5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl90aHJvdHRsZWRackZsdXNoID0gdGhyb3R0bGUoenJVdGlsLmJpbmQoenIuZmx1c2gsIHpyKSwgMTcpO1xuICB2YXIgdGhlbWUgPSB6clV0aWwuY2xvbmUodGhlbWUpO1xuICB0aGVtZSAmJiBiYWNrd2FyZENvbXBhdCh0aGVtZSwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl90aGVtZSA9IHRoZW1lO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fY2hhcnRzVmlld3MgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NoYXJ0c01hcCA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NvbXBvbmVudHNWaWV3cyA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NvbXBvbmVudHNNYXAgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9jb29yZFN5c01nciA9IG5ldyBDb29yZGluYXRlU3lzdGVtTWFuYWdlcigpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fYXBpID0gY3JlYXRlRXh0ZW5zaW9uQVBJKHRoaXMpO1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzfk1lc3NhZ2VDZW50ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX21lc3NhZ2VDZW50ZXIgPSBuZXcgTWVzc2FnZUNlbnRlcigpOyAvLyBJbml0IG1vdXNlIGV2ZW50c1xuXG4gIHRoaXMuX2luaXRFdmVudHMoKTsgLy8gSW4gY2FzZSBzb21lIHBlb3BsZSB3cml0ZSBgd2luZG93Lm9ucmVzaXplID0gY2hhcnQucmVzaXplYFxuXG5cbiAgdGhpcy5yZXNpemUgPSB6clV0aWwuYmluZCh0aGlzLnJlc2l6ZSwgdGhpcyk7IC8vIENhbid0IGRpc3BhdGNoIGFjdGlvbiBkdXJpbmcgcmVuZGVyaW5nIHByb2NlZHVyZVxuXG4gIHRoaXMuX3BlbmRpbmdBY3Rpb25zID0gW107IC8vIFNvcnQgb24gZGVtYW5kXG5cbiAgZnVuY3Rpb24gcHJpb3JpdHlTb3J0RnVuYyhhLCBiKSB7XG4gICAgcmV0dXJuIGEucHJpbyAtIGIucHJpbztcbiAgfVxuXG4gIHRpbXNvcnQodmlzdWFsRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuICB0aW1zb3J0KGRhdGFQcm9jZXNzb3JGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG4gIHpyLmFuaW1hdGlvbi5vbignZnJhbWUnLCB0aGlzLl9vbmZyYW1lLCB0aGlzKTsgLy8gRUNoYXJ0cyBpbnN0YW5jZSBjYW4gYmUgdXNlZCBhcyB2YWx1ZS5cblxuICB6clV0aWwuc2V0QXNQcmltaXRpdmUodGhpcyk7XG59XG5cbnZhciBlY2hhcnRzUHJvdG8gPSBFQ2hhcnRzLnByb3RvdHlwZTtcblxuZWNoYXJ0c1Byb3RvLl9vbmZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBMYXp5IHVwZGF0ZVxuICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICB2YXIgc2lsZW50ID0gdGhpc1tPUFRJT05fVVBEQVRFRF0uc2lsZW50O1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG4gICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7XG4gICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG4gICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICBmbHVzaFBlbmRpbmdBY3Rpb25zLmNhbGwodGhpcywgc2lsZW50KTtcbiAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbiAgfVxufTtcbi8qKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0RG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZG9tO1xufTtcbi8qKlxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXJ+WlJlbmRlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRaciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3pyO1xufTtcbi8qKlxuICogVXNhZ2U6XG4gKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCBub3RNZXJnZSwgbGF6eVVwZGF0ZSk7XG4gKiBjaGFydC5zZXRPcHRpb24ob3B0aW9uLCB7XG4gKiAgICAgbm90TWVyZ2U6IC4uLixcbiAqICAgICBsYXp5VXBkYXRlOiAuLi4sXG4gKiAgICAgc2lsZW50OiAuLi5cbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRzXSBvcHRzIG9yIG5vdE1lcmdlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ub3RNZXJnZT1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubGF6eVVwZGF0ZT1mYWxzZV0gVXNlZnVsIHdoZW4gc2V0T3B0aW9uIGZyZXF1ZW50bHkuXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpIHtcbiAgdmFyIHNpbGVudDtcblxuICBpZiAoenJVdGlsLmlzT2JqZWN0KG5vdE1lcmdlKSkge1xuICAgIGxhenlVcGRhdGUgPSBub3RNZXJnZS5sYXp5VXBkYXRlO1xuICAgIHNpbGVudCA9IG5vdE1lcmdlLnNpbGVudDtcbiAgICBub3RNZXJnZSA9IG5vdE1lcmdlLm5vdE1lcmdlO1xuICB9XG5cbiAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICBpZiAoIXRoaXMuX21vZGVsIHx8IG5vdE1lcmdlKSB7XG4gICAgdmFyIG9wdGlvbk1hbmFnZXIgPSBuZXcgT3B0aW9uTWFuYWdlcih0aGlzLl9hcGkpO1xuICAgIHZhciB0aGVtZSA9IHRoaXMuX3RoZW1lO1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWwgPSBuZXcgR2xvYmFsTW9kZWwobnVsbCwgbnVsbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpO1xuICAgIGVjTW9kZWwuaW5pdChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gIH1cblxuICB0aGlzLl9tb2RlbC5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyk7XG5cbiAgaWYgKGxhenlVcGRhdGUpIHtcbiAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IHtcbiAgICAgIHNpbGVudDogc2lsZW50XG4gICAgfTtcbiAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzKTsgLy8gRW5zdXJlIHpyIHJlZnJlc2ggc3ljaHJvbm91c2x5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlXG4gICAgLy8gZmV0Y2hlZCBhZnRlciBgc2V0T3B0aW9uYC5cblxuICAgIHRoaXMuX3pyLmZsdXNoKCk7XG5cbiAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICB9XG59O1xuLyoqXG4gKiBAREVQUkVDQVRFRFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnNldFRoZW1lID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZygnRUNoYXJ0cyNzZXRUaGVtZSgpIGlzIERFUFJFQ0FURUQgaW4gRUNoYXJ0cyAzLjAnKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsO1xufTtcbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLmdldE9wdGlvbigpO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXREZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fenIucGFpbnRlci5kcHIgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn07XG4vKipcbiAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0UmVuZGVyZWRDYW52YXMgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5waXhlbFJhdGlvID0gb3B0cy5waXhlbFJhdGlvIHx8IDE7XG4gIG9wdHMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fbW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgdmFyIHpyID0gdGhpcy5fenI7XG4gIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpOyAvLyBTdG9wIGFuaW1hdGlvbnNcblxuICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICB9KTtcbiAgcmV0dXJuIHpyLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMob3B0cyk7XG59O1xuLyoqXG4gKiBHZXQgc3ZnIGRhdGEgdXJsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0U3ZnRGF0YVVybCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFlbnYuc3ZnU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHpyID0gdGhpcy5fenI7XG4gIHZhciBsaXN0ID0genIuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpOyAvLyBTdG9wIGFuaW1hdGlvbnNcblxuICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICB9KTtcbiAgcmV0dXJuIHpyLnBhaW50ZXIucGF0aFRvU3ZnKCk7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnR5cGU9J3BuZyddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5leGNsdWRlQ29tcG9uZW50c11cbiAqL1xuXG5cbmVjaGFydHNQcm90by5nZXREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBleGNsdWRlQ29tcG9uZW50cyA9IG9wdHMuZXhjbHVkZUNvbXBvbmVudHM7XG4gIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gIHZhciBleGNsdWRlc0NvbXBvbmVudFZpZXdzID0gW107XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWFjaChleGNsdWRlQ29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgbWFpblR5cGU6IGNvbXBvbmVudFR5cGVcbiAgICB9LCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICB2YXIgdmlldyA9IHNlbGYuX2NvbXBvbmVudHNNYXBbY29tcG9uZW50Ll9fdmlld0lkXTtcblxuICAgICAgaWYgKCF2aWV3Lmdyb3VwLmlnbm9yZSkge1xuICAgICAgICBleGNsdWRlc0NvbXBvbmVudFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHZhciB1cmwgPSB0aGlzLl96ci5wYWludGVyLmdldFR5cGUoKSA9PT0gJ3N2ZycgPyB0aGlzLmdldFN2Z0RhdGFVcmwoKSA6IHRoaXMuZ2V0UmVuZGVyZWRDYW52YXMob3B0cykudG9EYXRhVVJMKCdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKSk7XG4gIGVhY2goZXhjbHVkZXNDb21wb25lbnRWaWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHVybDtcbn07XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHlwZT0ncG5nJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldENvbm5lY3RlZERhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXA7XG4gIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gIHZhciBNQVhfTlVNQkVSID0gSW5maW5pdHk7XG5cbiAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSkge1xuICAgIHZhciBsZWZ0ID0gTUFYX05VTUJFUjtcbiAgICB2YXIgdG9wID0gTUFYX05VTUJFUjtcbiAgICB2YXIgcmlnaHQgPSAtTUFYX05VTUJFUjtcbiAgICB2YXIgYm90dG9tID0gLU1BWF9OVU1CRVI7XG4gICAgdmFyIGNhbnZhc0xpc3QgPSBbXTtcbiAgICB2YXIgZHByID0gb3B0cyAmJiBvcHRzLnBpeGVsUmF0aW8gfHwgMTtcbiAgICB6clV0aWwuZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChjaGFydCwgaWQpIHtcbiAgICAgIGlmIChjaGFydC5ncm91cCA9PT0gZ3JvdXBJZCkge1xuICAgICAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0UmVuZGVyZWRDYW52YXMoenJVdGlsLmNsb25lKG9wdHMpKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGNoYXJ0LmdldERvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZWZ0ID0gbWF0aE1pbihib3VuZGluZ1JlY3QubGVmdCwgbGVmdCk7XG4gICAgICAgIHRvcCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LnRvcCwgdG9wKTtcbiAgICAgICAgcmlnaHQgPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5yaWdodCwgcmlnaHQpO1xuICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgIGNhbnZhc0xpc3QucHVzaCh7XG4gICAgICAgICAgZG9tOiBjYW52YXMsXG4gICAgICAgICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQsXG4gICAgICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxlZnQgKj0gZHByO1xuICAgIHRvcCAqPSBkcHI7XG4gICAgcmlnaHQgKj0gZHByO1xuICAgIGJvdHRvbSAqPSBkcHI7XG4gICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgdmFyIHRhcmdldENhbnZhcyA9IHpyVXRpbC5jcmVhdGVDYW52YXMoKTtcbiAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciB6ciA9IHpyZW5kZXIuaW5pdCh0YXJnZXRDYW52YXMpO1xuICAgIGVhY2goY2FudmFzTGlzdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpbWcgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgeDogaXRlbS5sZWZ0ICogZHByIC0gbGVmdCxcbiAgICAgICAgICB5OiBpdGVtLnRvcCAqIGRwciAtIHRvcCxcbiAgICAgICAgICBpbWFnZTogaXRlbS5kb21cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB6ci5hZGQoaW1nKTtcbiAgICB9KTtcbiAgICB6ci5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICByZXR1cm4gdGFyZ2V0Q2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldERhdGFVUkwob3B0cyk7XG4gIH1cbn07XG4vKipcbiAqIENvbnZlcnQgZnJvbSBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHBpeGVsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogU2VlIENvb3JkaW5hdGVTeXN0ZW0jY29udmVydFRvUGl4ZWwuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkLCBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lLFxuICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gKiAgICAgICAgfVxuICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtBcnJheXxudW1iZXJ9IHJlc3VsdFxuICovXG5cblxuZWNoYXJ0c1Byb3RvLmNvbnZlcnRUb1BpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydFRvUGl4ZWwnKTtcbi8qKlxuICogQ29udmVydCBmcm9tIHBpeGVsIGNvb3JkaW5hdGUgc3lzdGVtIHRvIGxvZ2ljYWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBTZWUgQ29vcmRpbmF0ZVN5c3RlbSNjb252ZXJ0RnJvbVBpeGVsLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdnZW8nLCBtZWFucyB7Z2VvSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWVcbiAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl8bnVtYmVyfSByZXN1bHRcbiAqL1xuXG5lY2hhcnRzUHJvdG8uY29udmVydEZyb21QaXhlbCA9IHpyVXRpbC5jdXJyeShkb0NvbnZlcnRQaXhlbCwgJ2NvbnZlcnRGcm9tUGl4ZWwnKTtcblxuZnVuY3Rpb24gZG9Db252ZXJ0UGl4ZWwobWV0aG9kTmFtZSwgZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gIHZhciBjb29yZFN5c0xpc3QgPSB0aGlzLl9jb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcygpO1xuXG4gIHZhciByZXN1bHQ7XG4gIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRTeXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gY29vcmRTeXNMaXN0W2ldO1xuXG4gICAgaWYgKGNvb3JkU3lzW21ldGhvZE5hbWVdICYmIChyZXN1bHQgPSBjb29yZFN5c1ttZXRob2ROYW1lXShlY01vZGVsLCBmaW5kZXIsIHZhbHVlKSkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlIHN5c3RlbXMgb3IgY29tcG9uZW50cyBjb250YWluIHRoZSBnaXZlbiBwaXhlbCBwb2ludC5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gKiAgICAgICAgICAgIGdlb0luZGV4IC8gZ2VvSWQgLyBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lLFxuICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gKiAgICAgICAgfVxuICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSByZXN1bHRcbiAqL1xuXG5cbmVjaGFydHNQcm90by5jb250YWluUGl4ZWwgPSBmdW5jdGlvbiAoZmluZGVyLCB2YWx1ZSkge1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICB2YXIgcmVzdWx0O1xuICBmaW5kZXIgPSBtb2RlbFV0aWwucGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyKTtcbiAgenJVdGlsLmVhY2goZmluZGVyLCBmdW5jdGlvbiAobW9kZWxzLCBrZXkpIHtcbiAgICBrZXkuaW5kZXhPZignTW9kZWxzJykgPj0gMCAmJiB6clV0aWwuZWFjaChtb2RlbHMsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgdmFyIGNvb3JkU3lzID0gbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5Qb2ludCkge1xuICAgICAgICByZXN1bHQgfD0gISFjb29yZFN5cy5jb250YWluUG9pbnQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJpZXNNb2RlbHMnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2hhcnRzTWFwW21vZGVsLl9fdmlld0lkXTtcblxuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgIHJlc3VsdCB8PSB2aWV3LmNvbnRhaW5Qb2ludCh2YWx1ZSwgbW9kZWwpO1xuICAgICAgICB9IGVsc2Uge31cbiAgICAgIH0gZWxzZSB7fVxuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuICEhcmVzdWx0O1xufTtcbi8qKlxuICogR2V0IHZpc3VhbCBmcm9tIHNlcmllcyBvciBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdzZXJpZXMnLCBtZWFucyB7c2VyaWVzSW5kZXg6IDB9LlxuICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZGF0YUluZGV4IC8gZGF0YUluZGV4SW5zaWRlXG4gKiAgICAgICAgfVxuICogICAgICAgIElmIGRhdGFJbmRleCBpcyBub3Qgc3BlY2lmaWVkLCBzZXJpZXMgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCxcbiAqICAgICAgICBidXQgbm90IGRhdGEgaXRlbSB2aXN1YWwuXG4gKiAgICAgICAgSWYgYWxsIG9mIHNlcmllc0luZGV4LCBzZXJpZXNJZCwgc2VyaWVzTmFtZSBhcmUgbm90IHNwZWNpZmllZCxcbiAqICAgICAgICB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkIGZyb20gZmlyc3Qgc2VyaWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHZpc3VhbFR5cGUgJ2NvbG9yJywgJ3N5bWJvbCcsICdzeW1ib2xTaXplJ1xuICovXG5cblxuZWNoYXJ0c1Byb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZpc3VhbFR5cGUpIHtcbiAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlciwge1xuICAgIGRlZmF1bHRNYWluVHlwZTogJ3NlcmllcydcbiAgfSk7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGZpbmRlci5zZXJpZXNNb2RlbDtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gIHZhciBkYXRhSW5kZXhJbnNpZGUgPSBmaW5kZXIuaGFzT3duUHJvcGVydHkoJ2RhdGFJbmRleEluc2lkZScpID8gZmluZGVyLmRhdGFJbmRleEluc2lkZSA6IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4JykgPyBkYXRhLmluZGV4T2ZSYXdJbmRleChmaW5kZXIuZGF0YUluZGV4KSA6IG51bGw7XG4gIHJldHVybiBkYXRhSW5kZXhJbnNpZGUgIT0gbnVsbCA/IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXhJbnNpZGUsIHZpc3VhbFR5cGUpIDogZGF0YS5nZXRWaXN1YWwodmlzdWFsVHlwZSk7XG59O1xuLyoqXG4gKiBHZXQgdmlldyBvZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudCBtb2RlbFxuICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvdmlldy9Db21wb25lbnR9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TW9kZWwpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXBbY29tcG9uZW50TW9kZWwuX192aWV3SWRdO1xufTtcbi8qKlxuICogR2V0IHZpZXcgb2YgY29ycmVzcG9uZGluZyBzZXJpZXMgbW9kZWxcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZ2V0Vmlld09mU2VyaWVzTW9kZWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgcmV0dXJuIHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG59O1xuXG52YXIgdXBkYXRlTWV0aG9kcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZSgndXBkYXRlJyk7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgIHZhciBjb29yZFN5c01nciA9IHRoaXMuX2Nvb3JkU3lzTWdyO1xuICAgIHZhciB6ciA9IHRoaXMuX3pyOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGaXhtZSBGaXJzdCB0aW1lIHVwZGF0ZSA/XG5cblxuICAgIGVjTW9kZWwucmVzdG9yZURhdGEoKTsgLy8gVE9ET1xuICAgIC8vIFNhdmUgdG90YWwgZWNNb2RlbCBoZXJlIGZvciB1bmRvL3JlZG8gKGFmdGVyIHJlc3RvcmluZyBkYXRhIGFuZCBiZWZvcmUgcHJvY2Vzc2luZyBkYXRhKS5cbiAgICAvLyBVbmRvIChyZXN0b3JhdGlvbiBvZiB0b3RhbCBlY01vZGVsKSBjYW4gYmUgY2FycmllZCBvdXQgaW4gJ2FjdGlvbicgb3Igb3V0c2lkZSBBUEkgY2FsbC5cbiAgICAvLyBDcmVhdGUgbmV3IGNvb3JkaW5hdGUgc3lzdGVtIGVhY2ggdXBkYXRlXG4gICAgLy8gSW4gTGluZVZpZXcgbWF5IHNhdmUgdGhlIG9sZCBjb29yZGluYXRlIHN5c3RlbSBhbmQgdXNlIGl0IHRvIGdldCB0aGUgb3JpZ25hbCBwb2ludFxuXG4gICAgY29vcmRTeXNNZ3IuY3JlYXRlKHRoaXMuX21vZGVsLCB0aGlzLl9hcGkpO1xuICAgIHByb2Nlc3NEYXRhLmNhbGwodGhpcywgZWNNb2RlbCwgYXBpKTtcbiAgICBzdGFja1Nlcmllc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsKTtcbiAgICBjb29yZFN5c01nci51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgZG9SZW5kZXIuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTsgLy8gU2V0IGJhY2tncm91bmRcblxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJ3RyYW5zcGFyZW50JztcbiAgICB2YXIgcGFpbnRlciA9IHpyLnBhaW50ZXI7IC8vIFRPRE8gYWxsIHVzZSBjbGVhckNvbG9yID9cblxuICAgIGlmIChwYWludGVyLmlzU2luZ2xlQ2FudmFzICYmIHBhaW50ZXIuaXNTaW5nbGVDYW52YXMoKSkge1xuICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBJRThcbiAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yID0gY29sb3JUb29sLnN0cmluZ2lmeShjb2xvckFyciwgJ3JnYicpO1xuXG4gICAgICAgIGlmIChjb2xvckFyclszXSA9PT0gMCkge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5jb2xvclN0b3BzIHx8IGJhY2tncm91bmRDb2xvci5pbWFnZSkge1xuICAgICAgICAvLyBHcmFkaWVudCBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIEZJWE1FIEZpeGVkIGxheWVy77yfXG4gICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddKSB7XG4gICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgY2xlYXJDb2xvcjogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWFjaChwb3N0VXBkYXRlRnVuY3MsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICBmdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgfSk7IC8vIGNvbnNvbGUucHJvZmlsZSAmJiBjb25zb2xlLnByb2ZpbGVFbmQoJ3VwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVmlldzogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsOyAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuXG4gICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgfSk7XG4gICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaWV3JywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVWaXN1YWw6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDsgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cblxuICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5jbGVhckFsbFZpc3VhbCgpO1xuICAgIH0pO1xuICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkLCB0cnVlKTtcbiAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlVmlzdWFsJywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDsgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cblxuICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvTGF5b3V0LmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG4gICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZUxheW91dCcsIGVjTW9kZWwsIHBheWxvYWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJlcGFyZUFuZFVwZGF0ZTogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgIHByZXBhcmVWaWV3LmNhbGwodGhpcywgJ2NvbXBvbmVudCcsIGVjTW9kZWwpO1xuICAgIHByZXBhcmVWaWV3LmNhbGwodGhpcywgJ2NoYXJ0JywgZWNNb2RlbCk7XG4gICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RseShlY0lucywgbWV0aG9kLCBwYXlsb2FkLCBtYWluVHlwZSwgc3ViVHlwZSkge1xuICB2YXIgZWNNb2RlbCA9IGVjSW5zLl9tb2RlbDsgLy8gYnJvYWRjYXN0XG5cbiAgaWYgKCFtYWluVHlwZSkge1xuICAgIGVhY2goZWNJbnMuX2NvbXBvbmVudHNWaWV3cy5jb25jYXQoZWNJbnMuX2NoYXJ0c1ZpZXdzKSwgY2FsbFZpZXcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWVyeSA9IHt9O1xuICBxdWVyeVttYWluVHlwZSArICdJZCddID0gcGF5bG9hZFttYWluVHlwZSArICdJZCddO1xuICBxdWVyeVttYWluVHlwZSArICdJbmRleCddID0gcGF5bG9hZFttYWluVHlwZSArICdJbmRleCddO1xuICBxdWVyeVttYWluVHlwZSArICdOYW1lJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ05hbWUnXTtcbiAgdmFyIGNvbmRpdGlvbiA9IHtcbiAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH07XG4gIHN1YlR5cGUgJiYgKGNvbmRpdGlvbi5zdWJUeXBlID0gc3ViVHlwZSk7IC8vIHN1YlR5cGUgbWF5IGJlICcnIGJ5IHBhcnNlQ2xhc3NUeXBlO1xuICAvLyBJZiBkaXNwYXRjaEFjdGlvbiBiZWZvcmUgc2V0T3B0aW9uLCBkbyBub3RoaW5nLlxuXG4gIGVjTW9kZWwgJiYgZWNNb2RlbC5lYWNoQ29tcG9uZW50KGNvbmRpdGlvbiwgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgIGNhbGxWaWV3KGVjSW5zW21haW5UeXBlID09PSAnc2VyaWVzJyA/ICdfY2hhcnRzTWFwJyA6ICdfY29tcG9uZW50c01hcCddW21vZGVsLl9fdmlld0lkXSk7XG4gIH0sIGVjSW5zKTtcblxuICBmdW5jdGlvbiBjYWxsVmlldyh2aWV3KSB7XG4gICAgdmlldyAmJiB2aWV3Ll9fYWxpdmUgJiYgdmlld1ttZXRob2RdICYmIHZpZXdbbWV0aG9kXSh2aWV3Ll9fbW9kZWwsIGVjTW9kZWwsIGVjSW5zLl9hcGksIHBheWxvYWQpO1xuICB9XG59XG4vKipcbiAqIFJlc2l6ZSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNpbGVudD1mYWxzZV1cbiAqL1xuXG5cbmVjaGFydHNQcm90by5yZXNpemUgPSBmdW5jdGlvbiAob3B0cykge1xuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gIHRoaXMuX3pyLnJlc2l6ZShvcHRzKTtcblxuICB2YXIgb3B0aW9uQ2hhbmdlZCA9IHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLnJlc2V0T3B0aW9uKCdtZWRpYScpO1xuXG4gIHZhciB1cGRhdGVNZXRob2QgPSBvcHRpb25DaGFuZ2VkID8gJ3ByZXBhcmVBbmRVcGRhdGUnIDogJ3VwZGF0ZSc7XG4gIHVwZGF0ZU1ldGhvZHNbdXBkYXRlTWV0aG9kXS5jYWxsKHRoaXMpOyAvLyBSZXNpemUgbG9hZGluZyBlZmZlY3RcblxuICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fbG9hZGluZ0ZYLnJlc2l6ZSgpO1xuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgdmFyIHNpbGVudCA9IG9wdHMgJiYgb3B0cy5zaWxlbnQ7XG4gIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbn07XG4vKipcbiAqIFNob3cgbG9hZGluZyBlZmZlY3RcbiAqIEBwYXJhbSAge3N0cmluZ30gW25hbWU9J2RlZmF1bHQnXVxuICogQHBhcmFtICB7T2JqZWN0fSBbY2ZnXVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKG5hbWUsIGNmZykge1xuICBpZiAoenJVdGlsLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgY2ZnID0gbmFtZTtcbiAgICBuYW1lID0gJyc7XG4gIH1cblxuICBuYW1lID0gbmFtZSB8fCAnZGVmYXVsdCc7XG4gIHRoaXMuaGlkZUxvYWRpbmcoKTtcblxuICBpZiAoIWxvYWRpbmdFZmZlY3RzW25hbWVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsID0gbG9hZGluZ0VmZmVjdHNbbmFtZV0odGhpcy5fYXBpLCBjZmcpO1xuICB2YXIgenIgPSB0aGlzLl96cjtcbiAgdGhpcy5fbG9hZGluZ0ZYID0gZWw7XG4gIHpyLmFkZChlbCk7XG59O1xuLyoqXG4gKiBIaWRlIGxvYWRpbmcgZWZmZWN0XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl96ci5yZW1vdmUodGhpcy5fbG9hZGluZ0ZYKTtcbiAgdGhpcy5fbG9hZGluZ0ZYID0gbnVsbDtcbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuZWNoYXJ0c1Byb3RvLm1ha2VBY3Rpb25Gcm9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgdmFyIHBheWxvYWQgPSB6clV0aWwuZXh0ZW5kKHt9LCBldmVudE9iaik7XG4gIHBheWxvYWQudHlwZSA9IGV2ZW50QWN0aW9uTWFwW2V2ZW50T2JqLnR5cGVdO1xuICByZXR1cm4gcGF5bG9hZDtcbn07XG4vKipcbiAqIEBwdWJpbGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BheWxvYWQudHlwZV0gQWN0aW9uIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRdIElmIHBhc3MgYm9vbGVhbiwgbWVhbnMgb3B0LnNpbGVudFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0LnNpbGVudD1mYWxzZV0gV2hldGhlciB0cmlnZ2VyIGV2ZW50cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5mbHVzaD11bmRlZmluZWRdXG4gKiAgICAgICAgICAgICAgICAgIHRydWU6IEZsdXNoIGltbWVkaWF0ZWx5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlIGZldGNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5LiBDYXV0aW9uOiBpdCBtaWdodCBhZmZlY3QgcGVyZm9ybWFuY2UuXG4gKiAgICAgICAgICAgICAgICAgIGZhbHNlOiBOb3Qgbm90IGZsdXNoLlxuICogICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IEF1dG8gZGVjaWRlIHdoZXRoZXIgcGVyZm9ybSBmbHVzaC5cbiAqL1xuXG5cbmVjaGFydHNQcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBvcHQpIHtcbiAgaWYgKCF6clV0aWwuaXNPYmplY3Qob3B0KSkge1xuICAgIG9wdCA9IHtcbiAgICAgIHNpbGVudDogISFvcHRcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFhY3Rpb25zW3BheWxvYWQudHlwZV0pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQXZvaWQgZGlzcGF0Y2ggYWN0aW9uIGJlZm9yZSBzZXRPcHRpb24uIEVzcGVjaWFsbHkgaW4gYGNvbm5lY3RgLlxuXG5cbiAgaWYgKCF0aGlzLl9tb2RlbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBNYXkgZGlzcGF0Y2hBY3Rpb24gaW4gcmVuZGVyaW5nIHByb2NlZHVyZVxuXG5cbiAgaWYgKHRoaXNbSU5fTUFJTl9QUk9DRVNTXSkge1xuICAgIHRoaXMuX3BlbmRpbmdBY3Rpb25zLnB1c2gocGF5bG9hZCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBkb0Rpc3BhdGNoQWN0aW9uLmNhbGwodGhpcywgcGF5bG9hZCwgb3B0LnNpbGVudCk7XG5cbiAgaWYgKG9wdC5mbHVzaCkge1xuICAgIHRoaXMuX3pyLmZsdXNoKHRydWUpO1xuICB9IGVsc2UgaWYgKG9wdC5mbHVzaCAhPT0gZmFsc2UgJiYgZW52LmJyb3dzZXIud2VDaGF0KSB7XG4gICAgLy8gSW4gV2VDaGF0IGVtYmVkZWQgYnJvd3NlciwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYW5kIGBzZXRJbnRlcnZhbGBcbiAgICAvLyBoYW5nIHdoZW4gc2xpZGluZyBwYWdlIChvbiB0b3VjaCBldmVudCksIHdoaWNoIGNhdXNlIHRoYXQgenIgZG9lcyBub3RcbiAgICAvLyByZWZyZXNoIHV0aWwgdXNlciBpbnRlcmFjdGlvbiBmaW5pc2hlZCwgd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgIC8vIEJ1dCBgZGlzcGF0Y2hBY3Rpb25gIG1heSBiZSBjYWxsZWQgdG9vIGZyZXF1ZW50bHkgd2hlbiBwYW4gb24gdG91Y2hcbiAgICAvLyBzY3JlZW4sIHdoaWNoIGltcGFjdHMgcGVyZm9ybWFuY2UgaWYgZG8gbm90IHRocm90dGxlIHRoZW0uXG4gICAgdGhpcy5fdGhyb3R0bGVkWnJGbHVzaCgpO1xuICB9XG5cbiAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIG9wdC5zaWxlbnQpO1xuICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgb3B0LnNpbGVudCk7XG59O1xuXG5mdW5jdGlvbiBkb0Rpc3BhdGNoQWN0aW9uKHBheWxvYWQsIHNpbGVudCkge1xuICB2YXIgcGF5bG9hZFR5cGUgPSBwYXlsb2FkLnR5cGU7XG4gIHZhciBlc2NhcGVDb25uZWN0ID0gcGF5bG9hZC5lc2NhcGVDb25uZWN0O1xuICB2YXIgYWN0aW9uV3JhcCA9IGFjdGlvbnNbcGF5bG9hZFR5cGVdO1xuICB2YXIgYWN0aW9uSW5mbyA9IGFjdGlvbldyYXAuYWN0aW9uSW5mbztcbiAgdmFyIGNwdFR5cGUgPSAoYWN0aW9uSW5mby51cGRhdGUgfHwgJ3VwZGF0ZScpLnNwbGl0KCc6Jyk7XG4gIHZhciB1cGRhdGVNZXRob2QgPSBjcHRUeXBlLnBvcCgpO1xuICBjcHRUeXBlID0gY3B0VHlwZVswXSAhPSBudWxsICYmIHBhcnNlQ2xhc3NUeXBlKGNwdFR5cGVbMF0pO1xuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuICB2YXIgcGF5bG9hZHMgPSBbcGF5bG9hZF07XG4gIHZhciBiYXRjaGVkID0gZmFsc2U7IC8vIEJhdGNoIGFjdGlvblxuXG4gIGlmIChwYXlsb2FkLmJhdGNoKSB7XG4gICAgYmF0Y2hlZCA9IHRydWU7XG4gICAgcGF5bG9hZHMgPSB6clV0aWwubWFwKHBheWxvYWQuYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5leHRlbmQoe30sIGl0ZW0pLCBwYXlsb2FkKTtcbiAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZXZlbnRPYmpCYXRjaCA9IFtdO1xuICB2YXIgZXZlbnRPYmo7XG4gIHZhciBpc0hpZ2hEb3duID0gcGF5bG9hZFR5cGUgPT09ICdoaWdobGlnaHQnIHx8IHBheWxvYWRUeXBlID09PSAnZG93bnBsYXknO1xuICBlYWNoKHBheWxvYWRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtKSB7XG4gICAgLy8gQWN0aW9uIGNhbiBzcGVjaWZ5IHRoZSBldmVudCBieSByZXR1cm4gaXQuXG4gICAgZXZlbnRPYmogPSBhY3Rpb25XcmFwLmFjdGlvbihiYXRjaEl0ZW0sIHRoaXMuX21vZGVsLCB0aGlzLl9hcGkpOyAvLyBFbWl0IGV2ZW50IG91dHNpZGVcblxuICAgIGV2ZW50T2JqID0gZXZlbnRPYmogfHwgenJVdGlsLmV4dGVuZCh7fSwgYmF0Y2hJdGVtKTsgLy8gQ29udmVydCB0eXBlIHRvIGV2ZW50VHlwZVxuXG4gICAgZXZlbnRPYmoudHlwZSA9IGFjdGlvbkluZm8uZXZlbnQgfHwgZXZlbnRPYmoudHlwZTtcbiAgICBldmVudE9iakJhdGNoLnB1c2goZXZlbnRPYmopOyAvLyBsaWdodCB1cGRhdGUgZG9lcyBub3QgcGVyZm9ybSBkYXRhIHByb2Nlc3MsIGxheW91dCBhbmQgdmlzdWFsLlxuXG4gICAgaWYgKGlzSGlnaERvd24pIHtcbiAgICAgIC8vIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGVcbiAgICAgIHVwZGF0ZURpcmVjdGx5KHRoaXMsIHVwZGF0ZU1ldGhvZCwgYmF0Y2hJdGVtLCAnc2VyaWVzJyk7XG4gICAgfSBlbHNlIGlmIChjcHRUeXBlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RseSh0aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgY3B0VHlwZS5tYWluLCBjcHRUeXBlLnN1Yik7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBpZiAodXBkYXRlTWV0aG9kICE9PSAnbm9uZScgJiYgIWlzSGlnaERvd24gJiYgIWNwdFR5cGUpIHtcbiAgICAvLyBTdGlsbCBkaXJ0eVxuICAgIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgICAgLy8gRklYTUUgUGFzcyBwYXlsb2FkID9cbiAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlTWV0aG9kc1t1cGRhdGVNZXRob2RdLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgfVxuICB9IC8vIEZvbGxvdyB0aGUgcnVsZSBvZiBhY3Rpb24gYmF0Y2hcblxuXG4gIGlmIChiYXRjaGVkKSB7XG4gICAgZXZlbnRPYmogPSB7XG4gICAgICB0eXBlOiBhY3Rpb25JbmZvLmV2ZW50IHx8IHBheWxvYWRUeXBlLFxuICAgICAgZXNjYXBlQ29ubmVjdDogZXNjYXBlQ29ubmVjdCxcbiAgICAgIGJhdGNoOiBldmVudE9iakJhdGNoXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBldmVudE9iaiA9IGV2ZW50T2JqQmF0Y2hbMF07XG4gIH1cblxuICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcbiAgIXNpbGVudCAmJiB0aGlzLl9tZXNzYWdlQ2VudGVyLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgZXZlbnRPYmopO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBlbmRpbmdBY3Rpb25zKHNpbGVudCkge1xuICB2YXIgcGVuZGluZ0FjdGlvbnMgPSB0aGlzLl9wZW5kaW5nQWN0aW9ucztcblxuICB3aGlsZSAocGVuZGluZ0FjdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIHBheWxvYWQgPSBwZW5kaW5nQWN0aW9ucy5zaGlmdCgpO1xuICAgIGRvRGlzcGF0Y2hBY3Rpb24uY2FsbCh0aGlzLCBwYXlsb2FkLCBzaWxlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJVcGRhdGVkRXZlbnQoc2lsZW50KSB7XG4gICFzaWxlbnQgJiYgdGhpcy50cmlnZ2VyKCd1cGRhdGVkJyk7XG59XG4vKipcbiAqIFJlZ2lzdGVyIGV2ZW50XG4gKiBAbWV0aG9kXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8ub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG5lY2hhcnRzUHJvdG8ub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbmVjaGFydHNQcm90by5vbmUgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uZScpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VVcGRhdGVNZXRob2QobWV0aG9kTmFtZSwgZWNNb2RlbCwgcGF5bG9hZCkge1xuICB2YXIgYXBpID0gdGhpcy5fYXBpOyAvLyBVcGRhdGUgYWxsIGNvbXBvbmVudHNcblxuICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudC5fX21vZGVsO1xuICAgIGNvbXBvbmVudFttZXRob2ROYW1lXShjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnQpO1xuICB9LCB0aGlzKTsgLy8gVXBhdGUgYWxsIGNoYXJ0c1xuXG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgY2hhcnRbbWV0aG9kTmFtZV0oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgdXBkYXRlWihzZXJpZXNNb2RlbCwgY2hhcnQpO1xuICAgIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0KTtcbiAgfSwgdGhpcyk7IC8vIElmIHVzZSBob3ZlciBsYXllclxuXG4gIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXModGhpcy5fenIsIGVjTW9kZWwpOyAvLyBQb3N0IHJlbmRlclxuXG4gIGVhY2gocG9zdFVwZGF0ZUZ1bmNzLCBmdW5jdGlvbiAoZnVuYykge1xuICAgIGZ1bmMoZWNNb2RlbCwgYXBpKTtcbiAgfSk7XG59XG4vKipcbiAqIFByZXBhcmUgdmlldyBpbnN0YW5jZXMgb2YgY2hhcnRzIGFuZCBjb21wb25lbnRzXG4gKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlVmlldyh0eXBlLCBlY01vZGVsKSB7XG4gIHZhciBpc0NvbXBvbmVudCA9IHR5cGUgPT09ICdjb21wb25lbnQnO1xuICB2YXIgdmlld0xpc3QgPSBpc0NvbXBvbmVudCA/IHRoaXMuX2NvbXBvbmVudHNWaWV3cyA6IHRoaXMuX2NoYXJ0c1ZpZXdzO1xuICB2YXIgdmlld01hcCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c01hcCA6IHRoaXMuX2NoYXJ0c01hcDtcbiAgdmFyIHpyID0gdGhpcy5fenI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZpZXdMaXN0W2ldLl9fYWxpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGVjTW9kZWxbaXNDb21wb25lbnQgPyAnZWFjaENvbXBvbmVudCcgOiAnZWFjaFNlcmllcyddKGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCkge1xuICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwgPSBjb21wb25lbnRUeXBlO1xuICAgIH0gLy8gQ29uc2lkZXI6IGlkIHNhbWUgYW5kIHR5cGUgY2hhbmdlZC5cblxuXG4gICAgdmFyIHZpZXdJZCA9ICdfZWNfJyArIG1vZGVsLmlkICsgJ18nICsgbW9kZWwudHlwZTtcbiAgICB2YXIgdmlldyA9IHZpZXdNYXBbdmlld0lkXTtcblxuICAgIGlmICghdmlldykge1xuICAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKG1vZGVsLnR5cGUpO1xuICAgICAgdmFyIENsYXp6ID0gaXNDb21wb25lbnQgPyBDb21wb25lbnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViKSA6IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUuc3ViKTtcblxuICAgICAgaWYgKENsYXp6KSB7XG4gICAgICAgIHZpZXcgPSBuZXcgQ2xhenooKTtcbiAgICAgICAgdmlldy5pbml0KGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgIHZpZXdNYXBbdmlld0lkXSA9IHZpZXc7XG4gICAgICAgIHZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgICAgIHpyLmFkZCh2aWV3Lmdyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVycm9yXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2RlbC5fX3ZpZXdJZCA9IHZpZXcuX19pZCA9IHZpZXdJZDtcbiAgICB2aWV3Ll9fYWxpdmUgPSB0cnVlO1xuICAgIHZpZXcuX19tb2RlbCA9IG1vZGVsO1xuICAgIHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSB7XG4gICAgICBtYWluVHlwZTogbW9kZWwubWFpblR5cGUsXG4gICAgICBpbmRleDogbW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICB9O1xuICB9LCB0aGlzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICB2YXIgdmlldyA9IHZpZXdMaXN0W2ldO1xuXG4gICAgaWYgKCF2aWV3Ll9fYWxpdmUpIHtcbiAgICAgIHpyLnJlbW92ZSh2aWV3Lmdyb3VwKTtcbiAgICAgIHZpZXcuZGlzcG9zZShlY01vZGVsLCB0aGlzLl9hcGkpO1xuICAgICAgdmlld0xpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgZGVsZXRlIHZpZXdNYXBbdmlldy5fX2lkXTtcbiAgICAgIHZpZXcuX19pZCA9IHZpZXcuZ3JvdXAuX19lY0NvbXBvbmVudEluZm8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFByb2Nlc3NvciBkYXRhIGluIGVhY2ggc2VyaWVzXG4gKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzRGF0YShlY01vZGVsLCBhcGkpIHtcbiAgZWFjaChkYXRhUHJvY2Vzc29yRnVuY3MsIGZ1bmN0aW9uIChwcm9jZXNzKSB7XG4gICAgcHJvY2Vzcy5mdW5jKGVjTW9kZWwsIGFwaSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RhY2tTZXJpZXNEYXRhKGVjTW9kZWwpIHtcbiAgdmFyIHN0YWNrZWREYXRhTWFwID0ge307XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgdmFyIHN0YWNrID0gc2VyaWVzLmdldCgnc3RhY2snKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG5cbiAgICBpZiAoc3RhY2sgJiYgZGF0YS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgIHZhciBwcmV2aW91c1N0YWNrID0gc3RhY2tlZERhdGFNYXBbc3RhY2tdOyAvLyBBdm9pZCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcblxuICAgICAgaWYgKHN0YWNrZWREYXRhTWFwLmhhc093blByb3BlcnR5KHN0YWNrKSAmJiBwcmV2aW91c1N0YWNrKSB7XG4gICAgICAgIGRhdGEuc3RhY2tlZE9uID0gcHJldmlvdXNTdGFjaztcbiAgICAgIH1cblxuICAgICAgc3RhY2tlZERhdGFNYXBbc3RhY2tdID0gZGF0YTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBMYXlvdXQgYmVmb3JlIGVhY2ggY2hhcnQgcmVuZGVyIHRoZXJlIHNlcmllcywgc3BlY2lhbCB2aXN1YWwgZW5jb2Rpbmcgc3RhZ2VcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvTGF5b3V0KGVjTW9kZWwsIHBheWxvYWQpIHtcbiAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgZWFjaCh2aXN1YWxGdW5jcywgZnVuY3Rpb24gKHZpc3VhbCkge1xuICAgIGlmICh2aXN1YWwuaXNMYXlvdXQpIHtcbiAgICAgIHZpc3VhbC5mdW5jKGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogRW5jb2RlIHZpc3VhbCBpbmZvbWF0aW9uIGZyb20gZGF0YSBhZnRlciBkYXRhIHByb2Nlc3NpbmdcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZXNMYXlvdXRdXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9WaXN1YWxFbmNvZGluZyhlY01vZGVsLCBwYXlsb2FkLCBleGNsdWRlc0xheW91dCkge1xuICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICBlY01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBzZXJpZXNNb2RlbC5jbGVhckNvbG9yUGFsZXR0ZSgpO1xuICB9KTtcbiAgZWFjaCh2aXN1YWxGdW5jcywgZnVuY3Rpb24gKHZpc3VhbCkge1xuICAgICghZXhjbHVkZXNMYXlvdXQgfHwgIXZpc3VhbC5pc0xheW91dCkgJiYgdmlzdWFsLmZ1bmMoZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgfSk7XG59XG4vKipcbiAqIFJlbmRlciBlYWNoIGNoYXJ0IGFuZCBjb21wb25lbnRcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBkb1JlbmRlcihlY01vZGVsLCBwYXlsb2FkKSB7XG4gIHZhciBhcGkgPSB0aGlzLl9hcGk7IC8vIFJlbmRlciBhbGwgY29tcG9uZW50c1xuXG4gIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50Vmlldykge1xuICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICBjb21wb25lbnRWaWV3LnJlbmRlcihjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgfSwgdGhpcyk7XG4gIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgIGNoYXJ0Ll9fYWxpdmUgPSBmYWxzZTtcbiAgfSwgdGhpcyk7IC8vIFJlbmRlciBhbGwgY2hhcnRzXG5cbiAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgY2hhcnRWaWV3Ll9fYWxpdmUgPSB0cnVlO1xuICAgIGNoYXJ0Vmlldy5yZW5kZXIoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgY2hhcnRWaWV3Lmdyb3VwLnNpbGVudCA9ICEhc2VyaWVzTW9kZWwuZ2V0KCdzaWxlbnQnKTtcbiAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuICAgIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldyk7XG4gIH0sIHRoaXMpOyAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcblxuICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTsgLy8gUmVtb3ZlIGdyb3VwcyBvZiB1bnJlbmRlcmVkIGNoYXJ0c1xuXG4gIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgIGlmICghY2hhcnQuX19hbGl2ZSkge1xuICAgICAgY2hhcnQucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgfVxuICB9LCB0aGlzKTtcbn1cblxudmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ2dsb2JhbG91dCcsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmVjaGFydHNQcm90by5faW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcbiAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmdldE1vZGVsKCk7XG4gICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgIHZhciBwYXJhbXM7IC8vIG5vIGUudGFyZ2V0IHdoZW4gJ2dsb2JhbG91dCcuXG5cbiAgICAgIGlmIChldmVOYW1lID09PSAnZ2xvYmFsb3V0Jykge1xuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWwuc2VyaWVzSW5kZXgpO1xuICAgICAgICBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICB9IC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZXZlbnREYXRhKSB7XG4gICAgICAgICAgcGFyYW1zID0genJVdGlsLmV4dGVuZCh7fSwgZWwuZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XG4gICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xuICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgdGhpcy5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xufTtcbi8qKlxuICogQ2xlYXJcbiAqL1xuXG5cbmVjaGFydHNQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRPcHRpb24oe1xuICAgIHNlcmllczogW11cbiAgfSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBEaXNwb3NlIGluc3RhbmNlXG4gKi9cblxuXG5lY2hhcnRzUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gIH0pO1xuICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICBjaGFydC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gIH0pOyAvLyBEaXNwb3NlIGFmdGVyIGFsbCB2aWV3cyBkaXNwb3NlZFxuXG4gIHRoaXMuX3pyLmRpc3Bvc2UoKTtcblxuICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xufTtcblxuenJVdGlsLm1peGluKEVDaGFydHMsIEV2ZW50ZnVsKTtcblxuZnVuY3Rpb24gdXBkYXRlSG92ZXJMYXllclN0YXR1cyh6ciwgZWNNb2RlbCkge1xuICB2YXIgc3RvcmFnZSA9IHpyLnN0b3JhZ2U7XG4gIHZhciBlbENvdW50ID0gMDtcbiAgc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgIGVsQ291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChlbENvdW50ID4gZWNNb2RlbC5nZXQoJ2hvdmVyTGF5ZXJUaHJlc2hvbGQnKSAmJiAhZW52Lm5vZGUpIHtcbiAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgIGVsLnVzZUhvdmVyTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFVwZGF0ZSBjaGFydCBwcm9ncmVzc2l2ZSBhbmQgYmxlbmQuXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc3xtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IG1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzaXZlQW5kQmxlbmQoc2VyaWVzTW9kZWwsIGNoYXJ0Vmlldykge1xuICAvLyBQcm9ncmVzc2l2ZSBjb25maWd1cmF0aW9uXG4gIHZhciBlbENvdW50ID0gMDtcbiAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnICYmICFlbC5pZ25vcmUpIHtcbiAgICAgIGVsQ291bnQrKztcbiAgICB9XG4gIH0pO1xuICB2YXIgZnJhbWVEcmF3TnVtID0gK3Nlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgdmFyIG5lZWRQcm9ncmVzc2l2ZSA9IGVsQ291bnQgPiBzZXJpZXNNb2RlbC5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJykgJiYgZnJhbWVEcmF3TnVtICYmICFlbnYubm9kZTtcblxuICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgLy8gRklYTUUgbWFya2VyIGFuZCBvdGhlciBjb21wb25lbnRzXG4gICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgZWwucHJvZ3Jlc3NpdmUgPSBuZWVkUHJvZ3Jlc3NpdmUgPyBNYXRoLmZsb29yKGVsQ291bnQrKyAvIGZyYW1lRHJhd051bSkgOiAtMTtcblxuICAgICAgICBpZiAobmVlZFByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIEJsZW5kIGNvbmZpZ3JhdGlvblxuXG5cbiAgdmFyIGJsZW5kTW9kZSA9IHNlcmllc01vZGVsLmdldCgnYmxlbmRNb2RlJykgfHwgbnVsbDtcbiAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgZWwuc2V0U3R5bGUoJ2JsZW5kJywgYmxlbmRNb2RlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc3xtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IG1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZVoobW9kZWwsIHZpZXcpIHtcbiAgdmFyIHogPSBtb2RlbC5nZXQoJ3onKTtcbiAgdmFyIHpsZXZlbCA9IG1vZGVsLmdldCgnemxldmVsJyk7IC8vIFNldCB6IGFuZCB6bGV2ZWxcblxuICB2aWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSB7XG4gIHZhciBjb29yZFN5c01nciA9IGVjSW5zdGFuY2UuX2Nvb3JkU3lzTWdyO1xuICByZXR1cm4genJVdGlsLmV4dGVuZChuZXcgRXh0ZW5zaW9uQVBJKGVjSW5zdGFuY2UpLCB7XG4gICAgLy8gSW5qZWN0IG1ldGhvZHNcbiAgICBnZXRDb29yZGluYXRlU3lzdGVtczogenJVdGlsLmJpbmQoY29vcmRTeXNNZ3IuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMsIGNvb3JkU3lzTWdyKSxcbiAgICBnZXRDb21wb25lbnRCeUVsZW1lbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIHZhciBtb2RlbEluZm8gPSBlbC5fX2VjQ29tcG9uZW50SW5mbztcblxuICAgICAgICBpZiAobW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZWNJbnN0YW5jZS5fbW9kZWwuZ2V0Q29tcG9uZW50KG1vZGVsSW5mby5tYWluVHlwZSwgbW9kZWxJbmZvLmluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEB0eXBlIHtPYmplY3R9IGtleTogYWN0aW9uVHlwZS5cbiAqIEBpbm5lclxuICovXG5cblxudmFyIGFjdGlvbnMgPSB7fTtcbi8qKlxuICogTWFwIGV2ZW50VHlwZSB0byBhY3Rpb25UeXBlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBldmVudEFjdGlvbk1hcCA9IHt9O1xuLyoqXG4gKiBEYXRhIHByb2Nlc3NvciBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywgRnVuY3Rpb24+Pn1cbiAqIEBpbm5lclxuICovXG5cbnZhciBkYXRhUHJvY2Vzc29yRnVuY3MgPSBbXTtcbi8qKlxuICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MgPSBbXTtcbi8qKlxuICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgcG9zdFVwZGF0ZUZ1bmNzID0gW107XG4vKipcbiAqIFZpc3VhbCBlbmNvZGluZyBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywgRnVuY3Rpb24+Pn1cbiAqIEBpbm5lclxuICovXG5cbnZhciB2aXN1YWxGdW5jcyA9IFtdO1xuLyoqXG4gKiBUaGVtZSBzdG9yYWdlXG4gKiBAdHlwZSB7T2JqZWN0LjxrZXksIE9iamVjdD59XG4gKi9cblxudmFyIHRoZW1lU3RvcmFnZSA9IHt9O1xuLyoqXG4gKiBMb2FkaW5nIGVmZmVjdHNcbiAqL1xuXG52YXIgbG9hZGluZ0VmZmVjdHMgPSB7fTtcbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBjb25uZWN0ZWRHcm91cHMgPSB7fTtcbnZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcbnZhciBncm91cElkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xudmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19lY2hhcnRzX2luc3RhbmNlXyc7XG52YXIgbWFwRGF0YVN0b3JlcyA9IHt9O1xuXG5mdW5jdGlvbiBlbmFibGVDb25uZWN0KGNoYXJ0KSB7XG4gIHZhciBTVEFUVVNfUEVORElORyA9IDA7XG4gIHZhciBTVEFUVVNfVVBEQVRJTkcgPSAxO1xuICB2YXIgU1RBVFVTX1VQREFURUQgPSAyO1xuICB2YXIgU1RBVFVTX0tFWSA9ICdfX2Nvbm5lY3RVcGRhdGVTdGF0dXMnO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhjaGFydHMsIHN0YXR1cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJDaGFydCA9IGNoYXJ0c1tpXTtcbiAgICAgIG90aGVyQ2hhcnRbU1RBVFVTX0tFWV0gPSBzdGF0dXM7XG4gICAgfVxuICB9XG5cbiAgenJVdGlsLmVhY2goZXZlbnRBY3Rpb25NYXAsIGZ1bmN0aW9uIChhY3Rpb25UeXBlLCBldmVudFR5cGUpIHtcbiAgICBjaGFydC5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGNvbm5lY3RlZEdyb3Vwc1tjaGFydC5ncm91cF0gJiYgY2hhcnRbU1RBVFVTX0tFWV0gIT09IFNUQVRVU19QRU5ESU5HKSB7XG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC5lc2NhcGVDb25uZWN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IGNoYXJ0Lm1ha2VBY3Rpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICB2YXIgb3RoZXJDaGFydHMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgIGlmIChvdGhlckNoYXJ0ICE9PSBjaGFydCAmJiBvdGhlckNoYXJ0Lmdyb3VwID09PSBjaGFydC5ncm91cCkge1xuICAgICAgICAgICAgb3RoZXJDaGFydHMucHVzaChvdGhlckNoYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVDb25uZWN0ZWRDaGFydHNTdGF0dXMob3RoZXJDaGFydHMsIFNUQVRVU19QRU5ESU5HKTtcbiAgICAgICAgZWFjaChvdGhlckNoYXJ0cywgZnVuY3Rpb24gKG90aGVyQ2hhcnQpIHtcbiAgICAgICAgICBpZiAob3RoZXJDaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1VQREFUSU5HKSB7XG4gICAgICAgICAgICBvdGhlckNoYXJ0LmRpc3BhdGNoQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfVVBEQVRFRCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGhlbWVdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dIFVzZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXJdIEN1cnJlbnRseSBvbmx5ICdjYW52YXMnIGlzIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gVXNlIGNsaWVudFdpZHRoIG9mIHRoZSBpbnB1dCBgZG9tYCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIFVzZSBjbGllbnRIZWlnaHQgb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCB0aGVtZSwgb3B0cykge1xuICB2YXIgZXhpc3RJbnN0YW5jZSA9IGdldEluc3RhbmNlQnlEb20oZG9tKTtcblxuICBpZiAoZXhpc3RJbnN0YW5jZSkge1xuICAgIHJldHVybiBleGlzdEluc3RhbmNlO1xuICB9XG5cbiAgdmFyIGNoYXJ0ID0gbmV3IEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cyk7XG4gIGNoYXJ0LmlkID0gJ2VjXycgKyBpZEJhc2UrKztcbiAgaW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuXG4gIGlmIChkb20uc2V0QXR0cmlidXRlKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSwgY2hhcnQuaWQpO1xuICB9IGVsc2Uge1xuICAgIGRvbVtET01fQVRUUklCVVRFX0tFWV0gPSBjaGFydC5pZDtcbiAgfVxuXG4gIGVuYWJsZUNvbm5lY3QoY2hhcnQpO1xuICByZXR1cm4gY2hhcnQ7XG59XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ3xBcnJheS48bW9kdWxlOmVjaGFydHN+RUNoYXJ0cz59IGdyb3VwSWRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbm5lY3QoZ3JvdXBJZCkge1xuICAvLyBJcyBhcnJheSBvZiBjaGFydHNcbiAgaWYgKHpyVXRpbC5pc0FycmF5KGdyb3VwSWQpKSB7XG4gICAgdmFyIGNoYXJ0cyA9IGdyb3VwSWQ7XG4gICAgZ3JvdXBJZCA9IG51bGw7IC8vIElmIGFueSBjaGFydCBoYXMgZ3JvdXBcblxuICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICBpZiAoY2hhcnQuZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICBncm91cElkID0gY2hhcnQuZ3JvdXA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZ3JvdXBJZCA9IGdyb3VwSWQgfHwgJ2dfJyArIGdyb3VwSWRCYXNlKys7XG4gICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgIGNoYXJ0Lmdyb3VwID0gZ3JvdXBJZDtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZEdyb3Vwc1tncm91cElkXSA9IHRydWU7XG4gIHJldHVybiBncm91cElkO1xufVxuLyoqXG4gKiBAREVQUkVDQVRFRFxuICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNDb25uZWN0KGdyb3VwSWQpIHtcbiAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gZmFsc2U7XG59XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICovXG5cblxudmFyIGRpc2Nvbm5lY3QgPSBkaXNDb25uZWN0O1xuLyoqXG4gKiBEaXNwb3NlIGEgY2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzfkVDaGFydHN8SFRNTERvbUVsZW1lbnR8c3RyaW5nfSBjaGFydFxuICovXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoY2hhcnQpIHtcbiAgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGFydCA9IGluc3RhbmNlc1tjaGFydF07XG4gIH0gZWxzZSBpZiAoIShjaGFydCBpbnN0YW5jZW9mIEVDaGFydHMpKSB7XG4gICAgLy8gVHJ5IHRvIHRyZWF0IGFzIGRvbVxuICAgIGNoYXJ0ID0gZ2V0SW5zdGFuY2VCeURvbShjaGFydCk7XG4gIH1cblxuICBpZiAoY2hhcnQgaW5zdGFuY2VvZiBFQ2hhcnRzICYmICFjaGFydC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICBjaGFydC5kaXNwb3NlKCk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHJldHVybiB7ZWNoYXJ0c35FQ2hhcnRzfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VCeURvbShkb20pIHtcbiAgdmFyIGtleTtcblxuICBpZiAoZG9tLmdldEF0dHJpYnV0ZSkge1xuICAgIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xuICB9IGVsc2Uge1xuICAgIGtleSA9IGRvbVtET01fQVRUUklCVVRFX0tFWV07XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VzW2tleV07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2VjaGFydHN+RUNoYXJ0c31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlQnlJZChrZXkpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xufVxuLyoqXG4gKiBSZWdpc3RlciB0aGVtZVxuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJUaGVtZShuYW1lLCB0aGVtZSkge1xuICB0aGVtZVN0b3JhZ2VbbmFtZV0gPSB0aGVtZTtcbn1cbi8qKlxuICogUmVnaXN0ZXIgb3B0aW9uIHByZXByb2Nlc3NvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlcHJvY2Vzc29yRnVuY1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJQcmVwcm9jZXNzb3IocHJlcHJvY2Vzc29yRnVuYykge1xuICBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcy5wdXNoKHByZXByb2Nlc3NvckZ1bmMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9jZXNzb3JGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclByb2Nlc3Nvcihwcmlvcml0eSwgcHJvY2Vzc29yRnVuYykge1xuICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzc29yRnVuYyA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfUFJPQ0VTU09SX0ZJTFRFUjtcbiAgfVxuXG4gIGRhdGFQcm9jZXNzb3JGdW5jcy5wdXNoKHtcbiAgICBwcmlvOiBwcmlvcml0eSxcbiAgICBmdW5jOiBwcm9jZXNzb3JGdW5jXG4gIH0pO1xufVxuLyoqXG4gKiBSZWdpc3RlciBwb3N0VXBkYXRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9zdFVwZGF0ZUZ1bmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUG9zdFVwZGF0ZShwb3N0VXBkYXRlRnVuYykge1xuICBwb3N0VXBkYXRlRnVuY3MucHVzaChwb3N0VXBkYXRlRnVuYyk7XG59XG4vKipcbiAqIFVzYWdlOlxuICogcmVnaXN0ZXJBY3Rpb24oJ3NvbWVBY3Rpb24nLCAnc29tZUV2ZW50JywgZnVuY3Rpb24gKCkgeyAuLi4gfSk7XG4gKiByZWdpc3RlckFjdGlvbignc29tZUFjdGlvbicsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICogcmVnaXN0ZXJBY3Rpb24oXG4gKiAgICAge3R5cGU6ICdzb21lQWN0aW9uJywgZXZlbnQ6ICdzb21lRXZlbnQnLCB1cGRhdGU6ICd1cGRhdGVWaWV3J30sXG4gKiAgICAgZnVuY3Rpb24gKCkgeyAuLi4gfVxuICogKTtcbiAqXG4gKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KX0gYWN0aW9uSW5mb1xuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbkluZm8udHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb25JbmZvLmV2ZW50XVxuICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb25JbmZvLnVwZGF0ZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbihhY3Rpb25JbmZvLCBldmVudE5hbWUsIGFjdGlvbikge1xuICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGlvbiA9IGV2ZW50TmFtZTtcbiAgICBldmVudE5hbWUgPSAnJztcbiAgfVxuXG4gIHZhciBhY3Rpb25UeXBlID0genJVdGlsLmlzT2JqZWN0KGFjdGlvbkluZm8pID8gYWN0aW9uSW5mby50eXBlIDogW2FjdGlvbkluZm8sIGFjdGlvbkluZm8gPSB7XG4gICAgZXZlbnQ6IGV2ZW50TmFtZVxuICB9XVswXTsgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG5cbiAgYWN0aW9uSW5mby5ldmVudCA9IChhY3Rpb25JbmZvLmV2ZW50IHx8IGFjdGlvblR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gIGV2ZW50TmFtZSA9IGFjdGlvbkluZm8uZXZlbnQ7IC8vIFZhbGlkYXRlIGFjdGlvbiB0eXBlIGFuZCBldmVudCBuYW1lLlxuXG4gIHpyVXRpbC5hc3NlcnQoQUNUSU9OX1JFRy50ZXN0KGFjdGlvblR5cGUpICYmIEFDVElPTl9SRUcudGVzdChldmVudE5hbWUpKTtcblxuICBpZiAoIWFjdGlvbnNbYWN0aW9uVHlwZV0pIHtcbiAgICBhY3Rpb25zW2FjdGlvblR5cGVdID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBhY3Rpb25JbmZvOiBhY3Rpb25JbmZvXG4gICAgfTtcbiAgfVxuXG4gIGV2ZW50QWN0aW9uTWFwW2V2ZW50TmFtZV0gPSBhY3Rpb25UeXBlO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHsqfSBDb29yZGluYXRlU3lzdGVtXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0odHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSkge1xuICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3Rlcih0eXBlLCBDb29yZGluYXRlU3lzdGVtKTtcbn1cbi8qKlxuICogR2V0IGRpbWVuc2lvbnMgb2Ygc3BlY2lmaWVkIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvb3JkaW5hdGVTeXN0ZW1EaW1lbnNpb25zKHR5cGUpIHtcbiAgdmFyIGNvb3JkU3lzQ3JlYXRvciA9IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCh0eXBlKTtcblxuICBpZiAoY29vcmRTeXNDcmVhdG9yKSB7XG4gICAgcmV0dXJuIGNvb3JkU3lzQ3JlYXRvci5nZXREaW1lbnNpb25zSW5mbyA/IGNvb3JkU3lzQ3JlYXRvci5nZXREaW1lbnNpb25zSW5mbygpIDogY29vcmRTeXNDcmVhdG9yLmRpbWVuc2lvbnMuc2xpY2UoKTtcbiAgfVxufVxuLyoqXG4gKiBMYXlvdXQgaXMgYSBzcGVjaWFsIHN0YWdlIG9mIHZpc3VhbCBlbmNvZGluZ1xuICogTW9zdCB2aXN1YWwgZW5jb2RpbmcgbGlrZSBjb2xvciBhcmUgY29tbW9uIGZvciBkaWZmZXJlbnQgY2hhcnRcbiAqIEJ1dCBlYWNoIGNoYXJ0IGhhcyBpdCdzIG93biBsYXlvdXQgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGF5b3V0RnVuY1xuICovXG5cblxuZnVuY3Rpb24gcmVnaXN0ZXJMYXlvdXQocHJpb3JpdHksIGxheW91dEZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxheW91dEZ1bmMgPSBwcmlvcml0eTtcbiAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1ZJU1VBTF9MQVlPVVQ7XG4gIH1cblxuICB2aXN1YWxGdW5jcy5wdXNoKHtcbiAgICBwcmlvOiBwcmlvcml0eSxcbiAgICBmdW5jOiBsYXlvdXRGdW5jLFxuICAgIGlzTGF5b3V0OiB0cnVlXG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTMwMDBdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB2aXN1YWxGdW5jXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3RlclZpc3VhbChwcmlvcml0eSwgdmlzdWFsRnVuYykge1xuICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmlzdWFsRnVuYyA9IHByaW9yaXR5O1xuICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0NIQVJUO1xuICB9XG5cbiAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgcHJpbzogcHJpb3JpdHksXG4gICAgZnVuYzogdmlzdWFsRnVuY1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZGluZyhuYW1lLCBsb2FkaW5nRngpIHtcbiAgbG9hZGluZ0VmZmVjdHNbbmFtZV0gPSBsb2FkaW5nRng7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRDb21wb25lbnRNb2RlbChvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50TW9kZWw7XG4gIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgLy8gfVxuICByZXR1cm4gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kQ29tcG9uZW50VmlldyhvcHRzXG4vKiwgc3VwZXJDbGFzcyovXG4pIHtcbiAgLy8gdmFyIENsYXp6ID0gQ29tcG9uZW50VmlldztcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIENvbXBvbmVudFZpZXcuZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdXBlckNsYXNzXVxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kU2VyaWVzTW9kZWwob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IFNlcmllc01vZGVsO1xuICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAvLyAgICAgc3VwZXJDbGFzcyA9ICdzZXJpZXMuJyArIHN1cGVyQ2xhc3MucmVwbGFjZSgnc2VyaWVzLicsICcnKTtcbiAgLy8gICAgIHZhciBjbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZShzdXBlckNsYXNzKTtcbiAgLy8gICAgIENsYXp6ID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAvLyB9XG4gIHJldHVybiBTZXJpZXNNb2RlbC5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRDaGFydFZpZXcob3B0c1xuLyosIHN1cGVyQ2xhc3MqL1xuKSB7XG4gIC8vIHZhciBDbGF6eiA9IENoYXJ0VmlldztcbiAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgLy8gICAgIHN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gIC8vICAgICBDbGF6eiA9IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgdHJ1ZSk7XG4gIC8vIH1cbiAgcmV0dXJuIENoYXJ0Vmlldy5leHRlbmQob3B0cyk7XG59XG4vKipcbiAqIFpSZW5kZXIgbmVlZCBhIGNhbnZhcyBjb250ZXh0IHRvIGRvIG1lYXN1cmVUZXh0LlxuICogQnV0IGluIG5vZGUgZW52aXJvbm1lbnQgY2FudmFzIG1heSBiZSBjcmVhdGVkIGJ5IG5vZGUtY2FudmFzLlxuICogU28gd2UgbmVlZCB0byBzcGVjaWZ5IGhvdyB0byBjcmVhdGUgYSBjYW52YXMgaW5zdGVhZCBvZiB1c2luZyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICpcbiAqIEJlIGNhcmVmdWwgb2YgdXNpbmcgaXQgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3JlYXRvclxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gKiAgICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCdlY2hhcnRzJyk7XG4gKiAgICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgLy8gU21hbGwgc2l6ZSBpcyBlbm91Z2guXG4gKiAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzKDMyLCAzMik7XG4gKiAgICAgfSk7XG4gKi9cblxuXG5mdW5jdGlvbiBzZXRDYW52YXNDcmVhdG9yKGNyZWF0b3IpIHtcbiAgenJVdGlsLiRvdmVycmlkZSgnY3JlYXRlQ2FudmFzJywgY3JlYXRvcik7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGdlb0pzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3BlY2lhbEFyZWFzXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgJC5nZXQoJ1VTQS5qc29uJywgZnVuY3Rpb24gKGdlb0pzb24pIHtcbiAqICAgICAgICAgZWNoYXJ0cy5yZWdpc3Rlck1hcCgnVVNBJywgZ2VvSnNvbik7XG4gKiAgICAgICAgIC8vIE9yXG4gKiAgICAgICAgIGVjaGFydHMucmVnaXN0ZXJNYXAoJ1VTQScsIHtcbiAqICAgICAgICAgICAgIGdlb0pzb246IGdlb0pzb24sXG4gKiAgICAgICAgICAgICBzcGVjaWFsQXJlYXM6IHt9XG4gKiAgICAgICAgIH0pXG4gKiAgICAgfSk7XG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3Rlck1hcChtYXBOYW1lLCBnZW9Kc29uLCBzcGVjaWFsQXJlYXMpIHtcbiAgaWYgKGdlb0pzb24uZ2VvSnNvbiAmJiAhZ2VvSnNvbi5mZWF0dXJlcykge1xuICAgIHNwZWNpYWxBcmVhcyA9IGdlb0pzb24uc3BlY2lhbEFyZWFzO1xuICAgIGdlb0pzb24gPSBnZW9Kc29uLmdlb0pzb247XG4gIH1cblxuICBpZiAodHlwZW9mIGdlb0pzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgZ2VvSnNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyAmJiBKU09OLnBhcnNlID8gSlNPTi5wYXJzZShnZW9Kc29uKSA6IG5ldyBGdW5jdGlvbigncmV0dXJuICgnICsgZ2VvSnNvbiArICcpOycpKCk7XG4gIH1cblxuICBtYXBEYXRhU3RvcmVzW21hcE5hbWVdID0ge1xuICAgIGdlb0pzb246IGdlb0pzb24sXG4gICAgc3BlY2lhbEFyZWFzOiBzcGVjaWFsQXJlYXNcbiAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE1hcChtYXBOYW1lKSB7XG4gIHJldHVybiBtYXBEYXRhU3RvcmVzW21hcE5hbWVdO1xufVxuXG5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfR0xPQkFMLCBzZXJpZXNDb2xvcik7XG5yZWdpc3RlclByZXByb2Nlc3NvcihiYWNrd2FyZENvbXBhdCk7XG5yZWdpc3RlckxvYWRpbmcoJ2RlZmF1bHQnLCBsb2FkaW5nRGVmYXVsdCk7IC8vIERlZmF1bHQgYWN0aW9uc1xuXG5yZWdpc3RlckFjdGlvbih7XG4gIHR5cGU6ICdoaWdobGlnaHQnLFxuICBldmVudDogJ2hpZ2hsaWdodCcsXG4gIHVwZGF0ZTogJ2hpZ2hsaWdodCdcbn0sIHpyVXRpbC5ub29wKTtcbnJlZ2lzdGVyQWN0aW9uKHtcbiAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgZXZlbnQ6ICdkb3ducGxheScsXG4gIHVwZGF0ZTogJ2Rvd25wbGF5J1xufSwgenJVdGlsLm5vb3ApOyAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2hlcmUgdGhlIG5hbWVzcGFjZSBgZGF0YVRvb2xgIHdpbGxcbi8vIGJlIG1vdW50ZWQgb24gYGVjaGFydHNgIGlzIHRoZSBleHRlbnNpb24gYGRhdGFUb29sYCBpcyBpbXBvcnRlZC5cblxudmFyIGRhdGFUb29sID0ge307XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG5leHBvcnRzLlBSSU9SSVRZID0gUFJJT1JJVFk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbmV4cG9ydHMuZGlzQ29ubmVjdCA9IGRpc0Nvbm5lY3Q7XG5leHBvcnRzLmRpc2Nvbm5lY3QgPSBkaXNjb25uZWN0O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2VCeURvbSA9IGdldEluc3RhbmNlQnlEb207XG5leHBvcnRzLmdldEluc3RhbmNlQnlJZCA9IGdldEluc3RhbmNlQnlJZDtcbmV4cG9ydHMucmVnaXN0ZXJUaGVtZSA9IHJlZ2lzdGVyVGhlbWU7XG5leHBvcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yID0gcmVnaXN0ZXJQcmVwcm9jZXNzb3I7XG5leHBvcnRzLnJlZ2lzdGVyUHJvY2Vzc29yID0gcmVnaXN0ZXJQcm9jZXNzb3I7XG5leHBvcnRzLnJlZ2lzdGVyUG9zdFVwZGF0ZSA9IHJlZ2lzdGVyUG9zdFVwZGF0ZTtcbmV4cG9ydHMucmVnaXN0ZXJBY3Rpb24gPSByZWdpc3RlckFjdGlvbjtcbmV4cG9ydHMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtID0gcmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtO1xuZXhwb3J0cy5nZXRDb29yZGluYXRlU3lzdGVtRGltZW5zaW9ucyA9IGdldENvb3JkaW5hdGVTeXN0ZW1EaW1lbnNpb25zO1xuZXhwb3J0cy5yZWdpc3RlckxheW91dCA9IHJlZ2lzdGVyTGF5b3V0O1xuZXhwb3J0cy5yZWdpc3RlclZpc3VhbCA9IHJlZ2lzdGVyVmlzdWFsO1xuZXhwb3J0cy5yZWdpc3RlckxvYWRpbmcgPSByZWdpc3RlckxvYWRpbmc7XG5leHBvcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsID0gZXh0ZW5kQ29tcG9uZW50TW9kZWw7XG5leHBvcnRzLmV4dGVuZENvbXBvbmVudFZpZXcgPSBleHRlbmRDb21wb25lbnRWaWV3O1xuZXhwb3J0cy5leHRlbmRTZXJpZXNNb2RlbCA9IGV4dGVuZFNlcmllc01vZGVsO1xuZXhwb3J0cy5leHRlbmRDaGFydFZpZXcgPSBleHRlbmRDaGFydFZpZXc7XG5leHBvcnRzLnNldENhbnZhc0NyZWF0b3IgPSBzZXRDYW52YXNDcmVhdG9yO1xuZXhwb3J0cy5yZWdpc3Rlck1hcCA9IHJlZ2lzdGVyTWFwO1xuZXhwb3J0cy5nZXRNYXAgPSBnZXRNYXA7XG5leHBvcnRzLmRhdGFUb29sID0gZGF0YVRvb2w7XG52YXIgX19fZWNfZXhwb3J0ID0gcmVxdWlyZShcIi4vZXhwb3J0XCIpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gX19fZWNfZXhwb3J0KSB7XG4gICAgICAgIGlmIChfX19lY19leHBvcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXhwb3J0c1trZXldID0gX19fZWNfZXhwb3J0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9lY2hhcnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///232\n");

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar pathTool = __webpack_require__(387);\n\nvar colorTool = __webpack_require__(256);\n\nvar matrix = __webpack_require__(253);\n\nvar vector = __webpack_require__(236);\n\nvar Path = __webpack_require__(238);\n\nvar Transformable = __webpack_require__(296);\n\nvar Image = __webpack_require__(290);\n\nexports.Image = Image;\n\nvar Group = __webpack_require__(259);\n\nexports.Group = Group;\n\nvar Text = __webpack_require__(372);\n\nexports.Text = Text;\n\nvar Circle = __webpack_require__(378);\n\nexports.Circle = Circle;\n\nvar Sector = __webpack_require__(384);\n\nexports.Sector = Sector;\n\nvar Ring = __webpack_require__(383);\n\nexports.Ring = Ring;\n\nvar Polygon = __webpack_require__(380);\n\nexports.Polygon = Polygon;\n\nvar Polyline = __webpack_require__(381);\n\nexports.Polyline = Polyline;\n\nvar Rect = __webpack_require__(382);\n\nexports.Rect = Rect;\n\nvar Line = __webpack_require__(379);\n\nexports.Line = Line;\n\nvar BezierCurve = __webpack_require__(377);\n\nexports.BezierCurve = BezierCurve;\n\nvar Arc = __webpack_require__(376);\n\nexports.Arc = Arc;\n\nvar CompoundPath = __webpack_require__(369);\n\nexports.CompoundPath = CompoundPath;\n\nvar LinearGradient = __webpack_require__(370);\n\nexports.LinearGradient = LinearGradient;\n\nvar RadialGradient = __webpack_require__(371);\n\nexports.RadialGradient = RadialGradient;\n\nvar BoundingRect = __webpack_require__(244);\n\nexports.BoundingRect = BoundingRect;\nvar round = Math.round;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar EMPTY_OBJ = {};\n/**\n * Extend shape with parameters\n */\n\nfunction extendShape(opts) {\n  return Path.extend(opts);\n}\n/**\n * Extend path\n */\n\n\nfunction extendPath(pathData, opts) {\n  return pathTool.extendFromString(pathData, opts);\n}\n/**\n * Create a path element from path data string\n * @param {string} pathData\n * @param {Object} opts\n * @param {module:zrender/core/BoundingRect} rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  var boundingRect = path.getBoundingRect();\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, boundingRect);\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param {string} imageUrl image url\n * @param {Object} opts options\n * @param {module:zrender/core/BoundingRect} rect constrain rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makeImage(imageUrl, rect, layout) {\n  var path = new Image({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        path.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return path;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  {Object} rect         element local bounding box\n * @param  {Object} boundingRect constraint bounding box\n * @return {Object} element position containing x, y, width, and height\n */\n\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nvar mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param {module:zrender/graphic/Path} path\n * @param {Object} rect\n */\n\nfunction resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x1]\n * @param {number} [param.shape.y1]\n * @param {number} [param.shape.x2]\n * @param {number} [param.shape.y2]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeLine(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n\n  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n  }\n\n  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n  }\n\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x]\n * @param {number} [param.shape.y]\n * @param {number} [param.shape.width]\n * @param {number} [param.shape.height]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeRect(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n  var originX = shape.x;\n  var originY = shape.y;\n  var originWidth = shape.width;\n  var originHeight = shape.height;\n  shape.x = subPixelOptimize(shape.x, lineWidth, true);\n  shape.y = subPixelOptimize(shape.y, lineWidth, true);\n  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nfunction hasFillOrStroke(fillOrStroke) {\n  return fillOrStroke != null && fillOrStroke != 'none';\n}\n\nfunction liftColor(color) {\n  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n}\n/**\n * @private\n */\n\n\nfunction cacheElementStl(el) {\n  if (el.__hoverStlDirty) {\n    var stroke = el.style.stroke;\n    var fill = el.style.fill; // Create hoverStyle on mouseover\n\n    var hoverStyle = el.__hoverStl;\n    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n    var normalStyle = {};\n\n    for (var name in hoverStyle) {\n      // See comment in `doSingleEnterHover`.\n      if (hoverStyle[name] != null) {\n        normalStyle[name] = el.style[name];\n      }\n    }\n\n    el.__normalStl = normalStyle;\n    el.__hoverStlDirty = false;\n  }\n}\n/**\n * @private\n */\n\n\nfunction doSingleEnterHover(el) {\n  if (el.__isHover) {\n    return;\n  }\n\n  cacheElementStl(el);\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.addHover(el, el.__hoverStl);\n  } else {\n    var style = el.style;\n    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text\n    // color should be returned to `autoColor`, rather than remain '#fff'.\n    // So we should rollback then apply again after style merging.\n\n    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:\n    // {\n    //     label: {\n    //         normal: {\n    //             show: false,\n    //             position: 'outside',\n    //             fontSize: 18\n    //         },\n    //         emphasis: {\n    //             show: true\n    //         }\n    //     }\n    // },\n    // where properties of `emphasis` may not appear in `normal`. We previously use\n    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n    // But consider rich text and setOption in merge mode, it is impossible to cover\n    // all properties in merge. So we use merge mode when setting style here, where\n    // only properties that is not `null/undefined` can be set. The disadventage:\n    // null/undefined can not be used to remove style any more in `emphasis`.\n\n    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.\n\n    if (insideRollbackOpt) {\n      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.\n\n      if (style.textFill == null) {\n        style.textFill = insideRollbackOpt.autoColor;\n      }\n    }\n\n    el.dirty(false);\n    el.z2 += 1;\n  }\n\n  el.__isHover = true;\n}\n/**\n * @inner\n */\n\n\nfunction doSingleLeaveHover(el) {\n  if (!el.__isHover) {\n    return;\n  }\n\n  var normalStl = el.__normalStl;\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.removeHover(el);\n  } else {\n    // Consider null/undefined value, should use\n    // `setStyle` but not `extendFrom(stl, true)`.\n    normalStl && el.setStyle(normalStl);\n    el.z2 -= 1;\n  }\n\n  el.__isHover = false;\n}\n/**\n * @inner\n */\n\n\nfunction doEnterHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleEnterHover(child);\n    }\n  }) : doSingleEnterHover(el);\n}\n\nfunction doLeaveHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleLeaveHover(child);\n    }\n  }) : doSingleLeaveHover(el);\n}\n/**\n * @inner\n */\n\n\nfunction setElementHoverStl(el, hoverStl) {\n  // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n  // Often used when item group has a label element and it's hoverStyle is different\n  el.__hoverStl = el.hoverStyle || hoverStl || {};\n  el.__hoverStlDirty = true;\n\n  if (el.__isHover) {\n    cacheElementStl(el);\n  }\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOver(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOut(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doLeaveHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction enterEmphasis() {\n  this.__isEmphasis = true;\n  doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction leaveEmphasis() {\n  this.__isEmphasis = false;\n  doLeaveHover(this);\n}\n/**\n * Set hover style of element.\n * This method can be called repeatly without side-effects.\n * @param {module:zrender/Element} el\n * @param {Object} [hoverStyle]\n * @param {Object} [opt]\n * @param {boolean} [opt.hoverSilentOnTouch=false]\n *        In touch device, mouseover event will be trigger on touchstart event\n *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n *        conviniently use hoverStyle when tap on touch screen without additional\n *        code for compatibility.\n *        But if the chart/component has select feature, which usually also use\n *        hoverStyle, there might be conflict between 'select-highlight' and\n *        'hover-highlight' especially when roam is enabled (see geo for example).\n *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n *        on touch device.\n */\n\n\nfunction setHoverStyle(el, hoverStyle, opt) {\n  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      setElementHoverStl(child, hoverStyle);\n    }\n  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.\n\n  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually\n\n  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n}\n/**\n * @param {Object|module:zrender/graphic/Style} normalStyle\n * @param {Object} emphasisStyle\n * @param {module:echarts/model/Model} normalModel\n * @param {module:echarts/model/Model} emphasisModel\n * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n * @param {Object} [opt.defaultText]\n * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {Object} [normalSpecified]\n * @param {Object} [emphasisSpecified]\n */\n\n\nfunction setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {\n  opt = opt || EMPTY_OBJ;\n  var labelFetcher = opt.labelFetcher;\n  var labelDataIndex = opt.labelDataIndex;\n  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n  // is not supported util someone requests.\n\n  var showNormal = normalModel.getShallow('show');\n  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.\n  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n\n  var baseText = showNormal || showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;\n  var normalStyleText = showNormal ? baseText : null;\n  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.\n\n  if (normalStyleText != null || emphasisStyleText != null) {\n    // Always set `textStyle` even if `normalStyle.text` is null, because default\n    // values have to be set on `normalStyle`.\n    // If we set default values on `emphasisStyle`, consider case:\n    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n    // Then the 'red' will not work on emphasis.\n    setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n  }\n\n  normalStyle.text = normalStyleText;\n  emphasisStyle.text = emphasisStyleText;\n}\n/**\n * Set basic textStyle properties.\n * @param {Object|module:zrender/graphic/Style} textStyle\n * @param {module:echarts/model/Model} model\n * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n * @param {boolean} [isEmphasis]\n */\n\n\nfunction setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {\n  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n  return textStyle;\n}\n/**\n * Set text option in the style.\n * @deprecated\n * @param {Object} textStyle\n * @param {module:echarts/model/Model} labelModel\n * @param {string|boolean} defaultColor Default text color.\n *        If set as false, it will be processed as a emphasis style.\n */\n\n\nfunction setText(textStyle, labelModel, defaultColor) {\n  var opt = {\n    isRectText: true\n  };\n  var isEmphasis;\n\n  if (defaultColor === false) {\n    isEmphasis = true;\n  } else {\n    // Support setting color as 'auto' to get visual color.\n    opt.autoColor = defaultColor;\n  }\n\n  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n}\n/**\n * {\n *      disableBox: boolean, Whether diable drawing box of block (outer most).\n *      isRectText: boolean,\n *      autoColor: string, specify a color when color is 'auto',\n *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n *              If autoColor specified, it is used as default textFill.\n *      useInsideStyle:\n *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n *                  if `textFill` is not specified.\n *              `false`: Do not use inside style.\n *              `null/undefined`: use inside style if `isRectText` is true and\n *                  `textFill` is not specified and textPosition contains `'inside'`.\n *      forceRich: boolean\n * }\n */\n\n\nfunction setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n  // Consider there will be abnormal when merge hover style to normal style if given default value.\n  opt = opt || EMPTY_OBJ;\n\n  if (opt.isRectText) {\n    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used\n    // in bar series, and magric type should be considered.\n\n    textPosition === 'outside' && (textPosition = 'top');\n    textStyle.textPosition = textPosition;\n    textStyle.textOffset = textStyleModel.getShallow('offset');\n    var labelRotate = textStyleModel.getShallow('rotate');\n    labelRotate != null && (labelRotate *= Math.PI / 180);\n    textStyle.textRotation = labelRotate;\n    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);\n  }\n\n  var ecModel = textStyleModel.ecModel;\n  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:\n  // {\n  //     data: [{\n  //         value: 12,\n  //         label: {\n  //             normal: {\n  //                 rich: {\n  //                     // no 'a' here but using parent 'a'.\n  //                 }\n  //             }\n  //         }\n  //     }],\n  //     rich: {\n  //         a: { ... }\n  //     }\n  // }\n\n  var richItemNames = getRichItemNames(textStyleModel);\n  var richResult;\n\n  if (richItemNames) {\n    richResult = {};\n\n    for (var name in richItemNames) {\n      if (richItemNames.hasOwnProperty(name)) {\n        // Cascade is supported in rich.\n        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.\n\n        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n      }\n    }\n  }\n\n  textStyle.rich = richResult;\n  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n  if (opt.forceRich && !opt.textStyle) {\n    opt.textStyle = {};\n  }\n\n  return textStyle;\n} // Consider case:\n// {\n//     data: [{\n//         value: 12,\n//         label: {\n//             normal: {\n//                 rich: {\n//                     // no 'a' here but using parent 'a'.\n//                 }\n//             }\n//         }\n//     }],\n//     rich: {\n//         a: { ... }\n//     }\n// }\n\n\nfunction getRichItemNames(textStyleModel) {\n  // Use object to remove duplicated names.\n  var richItemNameMap;\n\n  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n    var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n\n    if (rich) {\n      richItemNameMap = richItemNameMap || {};\n\n      for (var name in rich) {\n        if (rich.hasOwnProperty(name)) {\n          richItemNameMap[name] = 1;\n        }\n      }\n    }\n\n    textStyleModel = textStyleModel.parentModel;\n  }\n\n  return richItemNameMap;\n}\n\nfunction setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n  // In merge mode, default value should not be given.\n  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;\n  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;\n  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);\n\n  if (!isEmphasis) {\n    if (isBlock) {\n      // Always set `insideRollback`, for clearing previous.\n      var originalTextPosition = textStyle.textPosition;\n      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by\n      // real location (like [10, 30]) in zrender.\n\n      textStyle.insideOriginalTextPosition = originalTextPosition;\n      textStyle.insideRollbackOpt = opt;\n    } // Set default finally.\n\n\n    if (textStyle.textFill == null) {\n      textStyle.textFill = opt.autoColor;\n    }\n  } // Do not use `getFont` here, because merge should be supported, where\n  // part of these properties may be changed in emphasis style, and the\n  // others should remain their original value got from normal style.\n\n\n  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n  textStyle.textAlign = textStyleModel.getShallow('align');\n  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');\n  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n  textStyle.textWidth = textStyleModel.getShallow('width');\n  textStyle.textHeight = textStyleModel.getShallow('height');\n  textStyle.textTag = textStyleModel.getShallow('tag');\n\n  if (!isBlock || !opt.disableBox) {\n    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n    textStyle.textPadding = textStyleModel.getShallow('padding');\n    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n  }\n\n  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;\n  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;\n  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;\n  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;\n}\n\nfunction getAutoColor(color, opt) {\n  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;\n}\n\nfunction applyInsideStyle(textStyle, textPosition, opt) {\n  var useInsideStyle = opt.useInsideStyle;\n  var insideRollback;\n\n  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]\n  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {\n    insideRollback = {\n      textFill: null,\n      textStroke: textStyle.textStroke,\n      textStrokeWidth: textStyle.textStrokeWidth\n    };\n    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.\n\n    if (textStyle.textStroke == null) {\n      textStyle.textStroke = opt.autoColor;\n      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n    }\n  }\n\n  return insideRollback;\n}\n\nfunction rollbackInsideStyle(style) {\n  var insideRollback = style.insideRollback;\n\n  if (insideRollback) {\n    style.textFill = insideRollback.textFill;\n    style.textStroke = insideRollback.textStroke;\n    style.textStrokeWidth = insideRollback.textStrokeWidth;\n  }\n}\n\nfunction getFont(opt, ecModel) {\n  // ecModel or default text style model.\n  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n  return [// FIXME in node-canvas fontWeight is before fontStyle\n  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');\n}\n\nfunction animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n  if (typeof dataIndex === 'function') {\n    cb = dataIndex;\n    dataIndex = null;\n  } // Do not check 'animation' property directly here. Consider this case:\n  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n  // but its parent model (`seriesModel`) does.\n\n\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n  if (animationEnabled) {\n    var postfix = isUpdate ? 'Update' : '';\n    var duration = animatableModel.getShallow('animationDuration' + postfix);\n    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n\n    if (typeof animationDelay === 'function') {\n      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n    }\n\n    if (typeof duration === 'function') {\n      duration = duration(dataIndex);\n    }\n\n    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());\n  } else {\n    el.stopAnimation();\n    el.attr(props);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} [cb]\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\n\n\nfunction updateProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} cb\n */\n\n\nfunction initProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param {module:zrender/mixin/Transformable} target\n * @param {module:zrender/mixin/Transformable} [ancestor]\n */\n\n\nfunction getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param {Array.<number>} target [x, y]\n * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param {boolean=} invert Whether use invert matrix.\n * @return {Array.<number>} [x, y]\n */\n\n\nfunction applyTransform(target, transform, invert) {\n  if (transform && !zrUtil.isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param {string} direction 'left' 'right' 'top' 'bottom'\n * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param {boolean=} invert Whether use invert matrix.\n * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\n\nfunction transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nfunction groupTransition(g1, g2, animatableModel, cb) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (!el.isGroup && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      position: vector.clone(el.position),\n      rotation: el.rotation\n    };\n\n    if (el.shape) {\n      obj.shape = zrUtil.extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (!el.isGroup && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, el.dataIndex);\n      } // else {\n      //     if (el.previousProps) {\n      //         graphic.updateProps\n      //     }\n      // }\n\n    }\n  });\n}\n/**\n * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n * @param {Object} rect {x, y, width, height}\n * @return {Array.<Array.<number>>} A new clipped points.\n */\n\n\nfunction clipPointsByRect(points, rect) {\n  return zrUtil.map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * @param {Object} targetRect {x, y, width, height}\n * @param {Object} rect {x, y, width, height}\n * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n */\n\n\nfunction clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n/**\n * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n * @param {Object} [rect] {x, y, width, height}\n * @return {module:zrender/Element} Icon path or image element.\n */\n\n\nfunction createIcon(iconStr, opt, rect) {\n  opt = zrUtil.extend({\n    rectHover: true\n  }, opt);\n  var style = opt.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new Image(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');\n  }\n}\n\nexports.extendShape = extendShape;\nexports.extendPath = extendPath;\nexports.makePath = makePath;\nexports.makeImage = makeImage;\nexports.mergePath = mergePath;\nexports.resizePath = resizePath;\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;\nexports.setHoverStyle = setHoverStyle;\nexports.setLabelStyle = setLabelStyle;\nexports.setTextStyle = setTextStyle;\nexports.setText = setText;\nexports.getFont = getFont;\nexports.updateProps = updateProps;\nexports.initProps = initProps;\nexports.getTransform = getTransform;\nexports.applyTransform = applyTransform;\nexports.transformDirection = transformDirection;\nexports.groupTransition = groupTransition;\nexports.clipPointsByRect = clipPointsByRect;\nexports.clipRectByRect = clipRectByRect;\nexports.createIcon = createIcon;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL2dyYXBoaWMuanM/ZTI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIHBhdGhUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvcGF0aFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi90b29sL2NvbG9yXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBJbWFnZSA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlXCIpO1xuXG5leHBvcnRzLkltYWdlID0gSW1hZ2U7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbmV4cG9ydHMuR3JvdXAgPSBHcm91cDtcblxudmFyIFRleHQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9UZXh0XCIpO1xuXG5leHBvcnRzLlRleHQgPSBUZXh0O1xuXG52YXIgQ2lyY2xlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlXCIpO1xuXG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcblxudmFyIFNlY3RvciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvclwiKTtcblxuZXhwb3J0cy5TZWN0b3IgPSBTZWN0b3I7XG5cbnZhciBSaW5nID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZ1wiKTtcblxuZXhwb3J0cy5SaW5nID0gUmluZztcblxudmFyIFBvbHlnb24gPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uXCIpO1xuXG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuXG52YXIgUG9seWxpbmUgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVwiKTtcblxuZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuXG52YXIgUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3RcIik7XG5cbmV4cG9ydHMuUmVjdCA9IFJlY3Q7XG5cbnZhciBMaW5lID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZVwiKTtcblxuZXhwb3J0cy5MaW5lID0gTGluZTtcblxudmFyIEJlemllckN1cnZlID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmVcIik7XG5cbmV4cG9ydHMuQmV6aWVyQ3VydmUgPSBCZXppZXJDdXJ2ZTtcblxudmFyIEFyYyA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyY1wiKTtcblxuZXhwb3J0cy5BcmMgPSBBcmM7XG5cbnZhciBDb21wb3VuZFBhdGggPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGhcIik7XG5cbmV4cG9ydHMuQ29tcG91bmRQYXRoID0gQ29tcG91bmRQYXRoO1xuXG52YXIgTGluZWFyR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudFwiKTtcblxuZXhwb3J0cy5MaW5lYXJHcmFkaWVudCA9IExpbmVhckdyYWRpZW50O1xuXG52YXIgUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudFwiKTtcblxuZXhwb3J0cy5SYWRpYWxHcmFkaWVudCA9IFJhZGlhbEdyYWRpZW50O1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG5leHBvcnRzLkJvdW5kaW5nUmVjdCA9IEJvdW5kaW5nUmVjdDtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBFTVBUWV9PQkogPSB7fTtcbi8qKlxuICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xuICovXG5cbmZ1bmN0aW9uIGV4dGVuZFNoYXBlKG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xufVxuLyoqXG4gKiBFeHRlbmQgcGF0aFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kUGF0aChwYXRoRGF0YSwgb3B0cykge1xuICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlUGF0aChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XG4gIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG4gIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gIGlmIChyZWN0KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHJlY3QgPSBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCk7XG4gICAgfVxuXG4gICAgcmVzaXplUGF0aChwYXRoLCByZWN0KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBpbWFnZSBlbGVtZW50IGZyb20gaW1hZ2UgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwgaW1hZ2UgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25zXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0IGNvbnN0cmFpbiByZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xuICovXG5cblxuZnVuY3Rpb24gbWFrZUltYWdlKGltYWdlVXJsLCByZWN0LCBsYXlvdXQpIHtcbiAgdmFyIHBhdGggPSBuZXcgSW1hZ2Uoe1xuICAgIHN0eWxlOiB7XG4gICAgICBpbWFnZTogaW1hZ2VVcmwsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnksXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9LFxuICAgIG9ubG9hZDogZnVuY3Rpb24gKGltZykge1xuICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogaW1nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBwYXRoLnNldFN0eWxlKGNlbnRlckdyYXBoaWMocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIEdldCBwb3NpdGlvbiBvZiBjZW50ZXJlZCBlbGVtZW50IGluIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgICAgICAgICBlbGVtZW50IGxvY2FsIGJvdW5kaW5nIGJveFxuICogQHBhcmFtICB7T2JqZWN0fSBib3VuZGluZ1JlY3QgY29uc3RyYWludCBib3VuZGluZyBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gZWxlbWVudCBwb3NpdGlvbiBjb250YWluaW5nIHgsIHksIHdpZHRoLCBhbmQgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBjZW50ZXJHcmFwaGljKHJlY3QsIGJvdW5kaW5nUmVjdCkge1xuICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXG4gIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcbiAgdmFyIGhlaWdodDtcblxuICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xuICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgfVxuXG4gIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIHJldHVybiB7XG4gICAgeDogY3ggLSB3aWR0aCAvIDIsXG4gICAgeTogY3kgLSBoZWlnaHQgLyAyLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG52YXIgbWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xuLyoqXG4gKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gKi9cblxuZnVuY3Rpb24gcmVzaXplUGF0aChwYXRoLCByZWN0KSB7XG4gIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YlBpeGVsT3B0aW1pemVMaW5lKHBhcmFtKSB7XG4gIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xuICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xuXG4gIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XG4gICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xuICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocGFyYW0pIHtcbiAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG4gIHZhciBvcmlnaW5YID0gc2hhcGUueDtcbiAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xuICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgc2hhcGUud2lkdGggPSBNYXRoLm1heChzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LCBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxKTtcbiAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxKTtcbiAgcmV0dXJuIHBhcmFtO1xufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG4gIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xuICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMCA/IGRvdWJsZWRQb3NpdGlvbiAvIDIgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcbn1cblxuZnVuY3Rpb24gaGFzRmlsbE9yU3Ryb2tlKGZpbGxPclN0cm9rZSkge1xuICByZXR1cm4gZmlsbE9yU3Ryb2tlICE9IG51bGwgJiYgZmlsbE9yU3Ryb2tlICE9ICdub25lJztcbn1cblxuZnVuY3Rpb24gbGlmdENvbG9yKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnID8gY29sb3JUb29sLmxpZnQoY29sb3IsIC0wLjEpIDogY29sb3I7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjYWNoZUVsZW1lbnRTdGwoZWwpIHtcbiAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xuICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XG4gICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsOyAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcblxuICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcbiAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGwgfHwgKGhhc0ZpbGxPclN0cm9rZShmaWxsKSA/IGxpZnRDb2xvcihmaWxsKSA6IG51bGwpO1xuICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2UgfHwgKGhhc0ZpbGxPclN0cm9rZShzdHJva2UpID8gbGlmdENvbG9yKHN0cm9rZSkgOiBudWxsKTtcbiAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xuICAgICAgLy8gU2VlIGNvbW1lbnQgaW4gYGRvU2luZ2xlRW50ZXJIb3ZlcmAuXG4gICAgICBpZiAoaG92ZXJTdHlsZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcbiAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XG4gIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWNoZUVsZW1lbnRTdGwoZWwpO1xuXG4gIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgZWwuX196ciAmJiBlbC5fX3pyLmFkZEhvdmVyKGVsLCBlbC5fX2hvdmVyU3RsKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgaW5zaWRlUm9sbGJhY2tPcHQgPSBzdHlsZS5pbnNpZGVSb2xsYmFja09wdDsgLy8gQ29uc2lkZXIgY2FzZTogb25seSBgcG9zaXRpb246ICd0b3AnYCBpcyBzZXQgb24gZW1waGFzaXMsIHRoZW4gdGV4dFxuICAgIC8vIGNvbG9yIHNob3VsZCBiZSByZXR1cm5lZCB0byBgYXV0b0NvbG9yYCwgcmF0aGVyIHRoYW4gcmVtYWluICcjZmZmJy5cbiAgICAvLyBTbyB3ZSBzaG91bGQgcm9sbGJhY2sgdGhlbiBhcHBseSBhZ2FpbiBhZnRlciBzdHlsZSBtZXJnaW5nLlxuXG4gICAgaW5zaWRlUm9sbGJhY2tPcHQgJiYgcm9sbGJhY2tJbnNpZGVTdHlsZShzdHlsZSk7IC8vIHN0eWxlcyBjYW4gYmU6XG4gICAgLy8ge1xuICAgIC8vICAgICBsYWJlbDoge1xuICAgIC8vICAgICAgICAgbm9ybWFsOiB7XG4gICAgLy8gICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgLy8gICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAgICAvLyAgICAgICAgICAgICBmb250U2l6ZTogMThcbiAgICAvLyAgICAgICAgIH0sXG4gICAgLy8gICAgICAgICBlbXBoYXNpczoge1xuICAgIC8vICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH0sXG4gICAgLy8gd2hlcmUgcHJvcGVydGllcyBvZiBgZW1waGFzaXNgIG1heSBub3QgYXBwZWFyIGluIGBub3JtYWxgLiBXZSBwcmV2aW91c2x5IHVzZVxuICAgIC8vIG1vZHVsZTplY2hhcnRzL3V0aWwvbW9kZWwjZGVmYXVsdEVtcGhhc2lzIHRvIG1lcmdlIGBub3JtYWxgIHRvIGBlbXBoYXNpc2AuXG4gICAgLy8gQnV0IGNvbnNpZGVyIHJpY2ggdGV4dCBhbmQgc2V0T3B0aW9uIGluIG1lcmdlIG1vZGUsIGl0IGlzIGltcG9zc2libGUgdG8gY292ZXJcbiAgICAvLyBhbGwgcHJvcGVydGllcyBpbiBtZXJnZS4gU28gd2UgdXNlIG1lcmdlIG1vZGUgd2hlbiBzZXR0aW5nIHN0eWxlIGhlcmUsIHdoZXJlXG4gICAgLy8gb25seSBwcm9wZXJ0aWVzIHRoYXQgaXMgbm90IGBudWxsL3VuZGVmaW5lZGAgY2FuIGJlIHNldC4gVGhlIGRpc2FkdmVudGFnZTpcbiAgICAvLyBudWxsL3VuZGVmaW5lZCBjYW4gbm90IGJlIHVzZWQgdG8gcmVtb3ZlIHN0eWxlIGFueSBtb3JlIGluIGBlbXBoYXNpc2AuXG5cbiAgICBzdHlsZS5leHRlbmRGcm9tKGVsLl9faG92ZXJTdGwpOyAvLyBEbyBub3Qgc2F2ZSBgaW5zaWRlUm9sbGJhY2tgLlxuXG4gICAgaWYgKGluc2lkZVJvbGxiYWNrT3B0KSB7XG4gICAgICBhcHBseUluc2lkZVN0eWxlKHN0eWxlLCBzdHlsZS5pbnNpZGVPcmlnaW5hbFRleHRQb3NpdGlvbiwgaW5zaWRlUm9sbGJhY2tPcHQpOyAvLyB0ZXh0RmlsbCBtYXkgYmUgcm9sbGJhY2tlZCB0byBudWxsLlxuXG4gICAgICBpZiAoc3R5bGUudGV4dEZpbGwgPT0gbnVsbCkge1xuICAgICAgICBzdHlsZS50ZXh0RmlsbCA9IGluc2lkZVJvbGxiYWNrT3B0LmF1dG9Db2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgZWwuejIgKz0gMTtcbiAgfVxuXG4gIGVsLl9faXNIb3ZlciA9IHRydWU7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XG4gIGlmICghZWwuX19pc0hvdmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xuXG4gIGlmIChlbC51c2VIb3ZlckxheWVyKSB7XG4gICAgZWwuX196ciAmJiBlbC5fX3pyLnJlbW92ZUhvdmVyKGVsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb25zaWRlciBudWxsL3VuZGVmaW5lZCB2YWx1ZSwgc2hvdWxkIHVzZVxuICAgIC8vIGBzZXRTdHlsZWAgYnV0IG5vdCBgZXh0ZW5kRnJvbShzdGwsIHRydWUpYC5cbiAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcbiAgICBlbC56MiAtPSAxO1xuICB9XG5cbiAgZWwuX19pc0hvdmVyID0gZmFsc2U7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcbiAgICB9XG4gIH0pIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcbn1cblxuZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgZG9TaW5nbGVMZWF2ZUhvdmVyKGNoaWxkKTtcbiAgICB9XG4gIH0pIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcbn1cbi8qKlxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XG4gIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcbiAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxuICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcbiAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcblxuICBpZiAoZWwuX19pc0hvdmVyKSB7XG4gICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcbiAgfVxufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcihlKSB7XG4gIGlmICh0aGlzLl9faG92ZXJTaWxlbnRPblRvdWNoICYmIGUuenJCeVRvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXG5cblxuICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9FbnRlckhvdmVyKHRoaXMpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3V0KGUpIHtcbiAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcblxuXG4gICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcbiAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xuICBkb0VudGVySG92ZXIodGhpcyk7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gbGVhdmVFbXBoYXNpcygpIHtcbiAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcbiAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xufVxuLyoqXG4gKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudC5cbiAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgcmVwZWF0bHkgd2l0aG91dCBzaWRlLWVmZmVjdHMuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW2hvdmVyU3R5bGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5ob3ZlclNpbGVudE9uVG91Y2g9ZmFsc2VdXG4gKiAgICAgICAgSW4gdG91Y2ggZGV2aWNlLCBtb3VzZW92ZXIgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyIG9uIHRvdWNoc3RhcnQgZXZlbnRcbiAqICAgICAgICAoc2VlIG1vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHkpLiBCeSB0aGlzIG1lY2hhbmlzbSwgd2UgY2FuXG4gKiAgICAgICAgY29udmluaWVudGx5IHVzZSBob3ZlclN0eWxlIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlbiB3aXRob3V0IGFkZGl0aW9uYWxcbiAqICAgICAgICBjb2RlIGZvciBjb21wYXRpYmlsaXR5LlxuICogICAgICAgIEJ1dCBpZiB0aGUgY2hhcnQvY29tcG9uZW50IGhhcyBzZWxlY3QgZmVhdHVyZSwgd2hpY2ggdXN1YWxseSBhbHNvIHVzZVxuICogICAgICAgIGhvdmVyU3R5bGUsIHRoZXJlIG1pZ2h0IGJlIGNvbmZsaWN0IGJldHdlZW4gJ3NlbGVjdC1oaWdobGlnaHQnIGFuZFxuICogICAgICAgICdob3Zlci1oaWdobGlnaHQnIGVzcGVjaWFsbHkgd2hlbiByb2FtIGlzIGVuYWJsZWQgKHNlZSBnZW8gZm9yIGV4YW1wbGUpLlxuICogICAgICAgIEluIHRoaXMgY2FzZSwgaG92ZXJTaWxlbnRPblRvdWNoIHNob3VsZCBiZSB1c2VkIHRvIGRpc2FibGUgaG92ZXItaGlnaGxpZ2h0XG4gKiAgICAgICAgb24gdG91Y2ggZGV2aWNlLlxuICovXG5cblxuZnVuY3Rpb24gc2V0SG92ZXJTdHlsZShlbCwgaG92ZXJTdHlsZSwgb3B0KSB7XG4gIGVsLl9faG92ZXJTaWxlbnRPblRvdWNoID0gb3B0ICYmIG9wdC5ob3ZlclNpbGVudE9uVG91Y2g7XG4gIGVsLnR5cGUgPT09ICdncm91cCcgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgc2V0RWxlbWVudEhvdmVyU3RsKGNoaWxkLCBob3ZlclN0eWxlKTtcbiAgICB9XG4gIH0pIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTsgLy8gRHVwbGljYXRlZCBmdW5jdGlvbiB3aWxsIGJlIGF1dG8taWdub3JlZCwgc2VlIEV2ZW50ZnVsLmpzLlxuXG4gIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTsgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XG5cbiAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcykub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBub3JtYWxTdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IGVtcGhhc2lzU3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG5vcm1hbE1vZGVsXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBlbXBoYXNpc01vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0IENoZWNrIGBvcHRgIG9mIGBzZXRUZXh0U3R5bGVDb21tb25gIHRvIGZpbmQgb3RoZXIgcHJvcHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5kZWZhdWx0VGV4dF1cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtvcHQubGFiZWxGZXRjaGVyXSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQubGFiZWxGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKG9wdC5sYWJlbERhdGFJbmRleCwgJ25vcm1hbCcvJ2VtcGhhc2lzJywgbnVsbCwgb3B0LmxhYmVsRGltSW5kZXgpYFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbERhdGFJbmRleF0gRmV0Y2ggdGV4dCBieVxuICogICAgICBgb3B0LnRleHRGZXRjaGVyLmdldEZvcm1hdHRlZExhYmVsKG9wdC5sYWJlbERhdGFJbmRleCwgJ25vcm1hbCcvJ2VtcGhhc2lzJywgbnVsbCwgb3B0LmxhYmVsRGltSW5kZXgpYFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW29wdC5sYWJlbERpbUluZGV4XSBGZXRjaCB0ZXh0IGJ5XG4gKiAgICAgIGBvcHQudGV4dEZldGNoZXIuZ2V0Rm9ybWF0dGVkTGFiZWwob3B0LmxhYmVsRGF0YUluZGV4LCAnbm9ybWFsJy8nZW1waGFzaXMnLCBudWxsLCBvcHQubGFiZWxEaW1JbmRleClgXG4gKiBAcGFyYW0ge09iamVjdH0gW25vcm1hbFNwZWNpZmllZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW1waGFzaXNTcGVjaWZpZWRdXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRMYWJlbFN0eWxlKG5vcm1hbFN0eWxlLCBlbXBoYXNpc1N0eWxlLCBub3JtYWxNb2RlbCwgZW1waGFzaXNNb2RlbCwgb3B0LCBub3JtYWxTcGVjaWZpZWQsIGVtcGhhc2lzU3BlY2lmaWVkKSB7XG4gIG9wdCA9IG9wdCB8fCBFTVBUWV9PQko7XG4gIHZhciBsYWJlbEZldGNoZXIgPSBvcHQubGFiZWxGZXRjaGVyO1xuICB2YXIgbGFiZWxEYXRhSW5kZXggPSBvcHQubGFiZWxEYXRhSW5kZXg7XG4gIHZhciBsYWJlbERpbUluZGV4ID0gb3B0LmxhYmVsRGltSW5kZXg7IC8vIFRoaXMgc2NlbmFyaW8sIGBsYWJlbC5ub3JtYWwuc2hvdyA9IHRydWU7IGxhYmVsLmVtcGhhc2lzLnNob3cgPSBmYWxzZWAsXG4gIC8vIGlzIG5vdCBzdXBwb3J0ZWQgdXRpbCBzb21lb25lIHJlcXVlc3RzLlxuXG4gIHZhciBzaG93Tm9ybWFsID0gbm9ybWFsTW9kZWwuZ2V0U2hhbGxvdygnc2hvdycpO1xuICB2YXIgc2hvd0VtcGhhc2lzID0gZW1waGFzaXNNb2RlbC5nZXRTaGFsbG93KCdzaG93Jyk7IC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBvbmx5IGZldGNoIGxhYmVsIHdoZW4gbmVjZXNzYXJ5LlxuICAvLyBJZiBgbm9ybWFsLnNob3dgIGlzIGBmYWxzZWAgYW5kIGBlbXBoYXNpcy5zaG93YCBpcyBgdHJ1ZWAgYW5kIGBlbXBoYXNpcy5mb3JtYXR0ZXJgIGlzIG5vdCBzZXQsXG4gIC8vIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQsIHdoZXJlIHRleHQgaXMgZmV0Y2hlZCBieSBgbm9ybWFsLmZvcm1hdHRlcmAgb3IgYG9wdC5kZWZhdWx0VGV4dGAuXG5cbiAgdmFyIGJhc2VUZXh0ID0gc2hvd05vcm1hbCB8fCBzaG93RW1waGFzaXMgPyB6clV0aWwucmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgJ25vcm1hbCcsIG51bGwsIGxhYmVsRGltSW5kZXgpIDogbnVsbCwgb3B0LmRlZmF1bHRUZXh0KSA6IG51bGw7XG4gIHZhciBub3JtYWxTdHlsZVRleHQgPSBzaG93Tm9ybWFsID8gYmFzZVRleHQgOiBudWxsO1xuICB2YXIgZW1waGFzaXNTdHlsZVRleHQgPSBzaG93RW1waGFzaXMgPyB6clV0aWwucmV0cmlldmUyKGxhYmVsRmV0Y2hlciA/IGxhYmVsRmV0Y2hlci5nZXRGb3JtYXR0ZWRMYWJlbChsYWJlbERhdGFJbmRleCwgJ2VtcGhhc2lzJywgbnVsbCwgbGFiZWxEaW1JbmRleCkgOiBudWxsLCBiYXNlVGV4dCkgOiBudWxsOyAvLyBPcHRpbWl6ZTogSWYgc3R5bGUudGV4dCBpcyBudWxsLCB0ZXh0IHdpbGwgbm90IGJlIGRyYXduLlxuXG4gIGlmIChub3JtYWxTdHlsZVRleHQgIT0gbnVsbCB8fCBlbXBoYXNpc1N0eWxlVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gQWx3YXlzIHNldCBgdGV4dFN0eWxlYCBldmVuIGlmIGBub3JtYWxTdHlsZS50ZXh0YCBpcyBudWxsLCBiZWNhdXNlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZXMgaGF2ZSB0byBiZSBzZXQgb24gYG5vcm1hbFN0eWxlYC5cbiAgICAvLyBJZiB3ZSBzZXQgZGVmYXVsdCB2YWx1ZXMgb24gYGVtcGhhc2lzU3R5bGVgLCBjb25zaWRlciBjYXNlOlxuICAgIC8vIEZpcnN0bHksIGBzZXRPcHRpb24oLi4uIGxhYmVsOiB7bm9ybWFsOiB7dGV4dDogbnVsbH0sIGVtcGhhc2lzOiB7c2hvdzogdHJ1ZX19IC4uLik7YFxuICAgIC8vIFNlY29uZGx5LCBgc2V0T3B0aW9uKC4uLiBsYWJlbDoge25vcmFtbDoge3Nob3c6IHRydWUsIHRleHQ6ICdhYmMnLCBjb2xvcjogJ3JlZCd9IC4uLik7YFxuICAgIC8vIFRoZW4gdGhlICdyZWQnIHdpbGwgbm90IHdvcmsgb24gZW1waGFzaXMuXG4gICAgc2V0VGV4dFN0eWxlKG5vcm1hbFN0eWxlLCBub3JtYWxNb2RlbCwgbm9ybWFsU3BlY2lmaWVkLCBvcHQpO1xuICAgIHNldFRleHRTdHlsZShlbXBoYXNpc1N0eWxlLCBlbXBoYXNpc01vZGVsLCBlbXBoYXNpc1NwZWNpZmllZCwgb3B0LCB0cnVlKTtcbiAgfVxuXG4gIG5vcm1hbFN0eWxlLnRleHQgPSBub3JtYWxTdHlsZVRleHQ7XG4gIGVtcGhhc2lzU3R5bGUudGV4dCA9IGVtcGhhc2lzU3R5bGVUZXh0O1xufVxuLyoqXG4gKiBTZXQgYmFzaWMgdGV4dFN0eWxlIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSB0ZXh0U3R5bGVcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gW3NwZWNpZmllZFRleHRTdHlsZV0gQ2FuIGJlIG92ZXJyaWRlZCBieSBzZXR0aW5ncyBpbiBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBTZWUgYG9wdGAgb2YgYHNldFRleHRTdHlsZUNvbW1vbmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0VtcGhhc2lzXVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIHNwZWNpZmllZFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKSB7XG4gIHNldFRleHRTdHlsZUNvbW1vbih0ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICBzcGVjaWZpZWRUZXh0U3R5bGUgJiYgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHNwZWNpZmllZFRleHRTdHlsZSk7XG4gIHRleHRTdHlsZS5ob3N0ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5ICYmIHRleHRTdHlsZS5ob3N0LmRpcnR5KGZhbHNlKTtcbiAgcmV0dXJuIHRleHRTdHlsZTtcbn1cbi8qKlxuICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZS5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXG4gKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBkZWZhdWx0Q29sb3IgRGVmYXVsdCB0ZXh0IGNvbG9yLlxuICogICAgICAgIElmIHNldCBhcyBmYWxzZSwgaXQgd2lsbCBiZSBwcm9jZXNzZWQgYXMgYSBlbXBoYXNpcyBzdHlsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRleHQodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBkZWZhdWx0Q29sb3IpIHtcbiAgdmFyIG9wdCA9IHtcbiAgICBpc1JlY3RUZXh0OiB0cnVlXG4gIH07XG4gIHZhciBpc0VtcGhhc2lzO1xuXG4gIGlmIChkZWZhdWx0Q29sb3IgPT09IGZhbHNlKSB7XG4gICAgaXNFbXBoYXNpcyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzZXR0aW5nIGNvbG9yIGFzICdhdXRvJyB0byBnZXQgdmlzdWFsIGNvbG9yLlxuICAgIG9wdC5hdXRvQ29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gIH1cblxuICBzZXRUZXh0U3R5bGVDb21tb24odGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBvcHQsIGlzRW1waGFzaXMpO1xuICB0ZXh0U3R5bGUuaG9zdCAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eSAmJiB0ZXh0U3R5bGUuaG9zdC5kaXJ0eShmYWxzZSk7XG59XG4vKipcbiAqIHtcbiAqICAgICAgZGlzYWJsZUJveDogYm9vbGVhbiwgV2hldGhlciBkaWFibGUgZHJhd2luZyBib3ggb2YgYmxvY2sgKG91dGVyIG1vc3QpLlxuICogICAgICBpc1JlY3RUZXh0OiBib29sZWFuLFxuICogICAgICBhdXRvQ29sb3I6IHN0cmluZywgc3BlY2lmeSBhIGNvbG9yIHdoZW4gY29sb3IgaXMgJ2F1dG8nLFxuICogICAgICAgICAgICAgIGZvciB0ZXh0RmlsbCwgdGV4dFN0cm9rZSwgdGV4dEJhY2tncm91bmRDb2xvciwgYW5kIHRleHRCb3JkZXJDb2xvci5cbiAqICAgICAgICAgICAgICBJZiBhdXRvQ29sb3Igc3BlY2lmaWVkLCBpdCBpcyB1c2VkIGFzIGRlZmF1bHQgdGV4dEZpbGwuXG4gKiAgICAgIHVzZUluc2lkZVN0eWxlOlxuICogICAgICAgICAgICAgIGB0cnVlYDogVXNlIGluc2lkZSBzdHlsZSAodGV4dEZpbGwsIHRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aClcbiAqICAgICAgICAgICAgICAgICAgaWYgYHRleHRGaWxsYCBpcyBub3Qgc3BlY2lmaWVkLlxuICogICAgICAgICAgICAgIGBmYWxzZWA6IERvIG5vdCB1c2UgaW5zaWRlIHN0eWxlLlxuICogICAgICAgICAgICAgIGBudWxsL3VuZGVmaW5lZGA6IHVzZSBpbnNpZGUgc3R5bGUgaWYgYGlzUmVjdFRleHRgIGlzIHRydWUgYW5kXG4gKiAgICAgICAgICAgICAgICAgIGB0ZXh0RmlsbGAgaXMgbm90IHNwZWNpZmllZCBhbmQgdGV4dFBvc2l0aW9uIGNvbnRhaW5zIGAnaW5zaWRlJ2AuXG4gKiAgICAgIGZvcmNlUmljaDogYm9vbGVhblxuICogfVxuICovXG5cblxuZnVuY3Rpb24gc2V0VGV4dFN0eWxlQ29tbW9uKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIG9wdCwgaXNFbXBoYXNpcykge1xuICAvLyBDb25zaWRlciB0aGVyZSB3aWxsIGJlIGFibm9ybWFsIHdoZW4gbWVyZ2UgaG92ZXIgc3R5bGUgdG8gbm9ybWFsIHN0eWxlIGlmIGdpdmVuIGRlZmF1bHQgdmFsdWUuXG4gIG9wdCA9IG9wdCB8fCBFTVBUWV9PQko7XG5cbiAgaWYgKG9wdC5pc1JlY3RUZXh0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgKGlzRW1waGFzaXMgPyBudWxsIDogJ2luc2lkZScpOyAvLyAnb3V0c2lkZScgaXMgbm90IGEgdmFsaWQgenIgdGV4dFBvc3Rpb24gdmFsdWUsIGJ1dCB1c2VkXG4gICAgLy8gaW4gYmFyIHNlcmllcywgYW5kIG1hZ3JpYyB0eXBlIHNob3VsZCBiZSBjb25zaWRlcmVkLlxuXG4gICAgdGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScgJiYgKHRleHRQb3NpdGlvbiA9ICd0b3AnKTtcbiAgICB0ZXh0U3R5bGUudGV4dFBvc2l0aW9uID0gdGV4dFBvc2l0aW9uO1xuICAgIHRleHRTdHlsZS50ZXh0T2Zmc2V0ID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnb2Zmc2V0Jyk7XG4gICAgdmFyIGxhYmVsUm90YXRlID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygncm90YXRlJyk7XG4gICAgbGFiZWxSb3RhdGUgIT0gbnVsbCAmJiAobGFiZWxSb3RhdGUgKj0gTWF0aC5QSSAvIDE4MCk7XG4gICAgdGV4dFN0eWxlLnRleHRSb3RhdGlvbiA9IGxhYmVsUm90YXRlO1xuICAgIHRleHRTdHlsZS50ZXh0RGlzdGFuY2UgPSB6clV0aWwucmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJyksIGlzRW1waGFzaXMgPyBudWxsIDogNSk7XG4gIH1cblxuICB2YXIgZWNNb2RlbCA9IHRleHRTdHlsZU1vZGVsLmVjTW9kZWw7XG4gIHZhciBnbG9iYWxUZXh0U3R5bGUgPSBlY01vZGVsICYmIGVjTW9kZWwub3B0aW9uLnRleHRTdHlsZTsgLy8gQ29uc2lkZXIgY2FzZTpcbiAgLy8ge1xuICAvLyAgICAgZGF0YTogW3tcbiAgLy8gICAgICAgICB2YWx1ZTogMTIsXG4gIC8vICAgICAgICAgbGFiZWw6IHtcbiAgLy8gICAgICAgICAgICAgbm9ybWFsOiB7XG4gIC8vICAgICAgICAgICAgICAgICByaWNoOiB7XG4gIC8vICAgICAgICAgICAgICAgICAgICAgLy8gbm8gJ2EnIGhlcmUgYnV0IHVzaW5nIHBhcmVudCAnYScuXG4gIC8vICAgICAgICAgICAgICAgICB9XG4gIC8vICAgICAgICAgICAgIH1cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XSxcbiAgLy8gICAgIHJpY2g6IHtcbiAgLy8gICAgICAgICBhOiB7IC4uLiB9XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICB2YXIgcmljaEl0ZW1OYW1lcyA9IGdldFJpY2hJdGVtTmFtZXModGV4dFN0eWxlTW9kZWwpO1xuICB2YXIgcmljaFJlc3VsdDtcblxuICBpZiAocmljaEl0ZW1OYW1lcykge1xuICAgIHJpY2hSZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gcmljaEl0ZW1OYW1lcykge1xuICAgICAgaWYgKHJpY2hJdGVtTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgLy8gQ2FzY2FkZSBpcyBzdXBwb3J0ZWQgaW4gcmljaC5cbiAgICAgICAgdmFyIHJpY2hUZXh0U3R5bGUgPSB0ZXh0U3R5bGVNb2RlbC5nZXRNb2RlbChbJ3JpY2gnLCBuYW1lXSk7IC8vIEluIHJpY2gsIG5ldmVyIGBkaXNhYmxlQm94YC5cblxuICAgICAgICBzZXRUb2tlblRleHRTdHlsZShyaWNoUmVzdWx0W25hbWVdID0ge30sIHJpY2hUZXh0U3R5bGUsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZXh0U3R5bGUucmljaCA9IHJpY2hSZXN1bHQ7XG4gIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzLCB0cnVlKTtcblxuICBpZiAob3B0LmZvcmNlUmljaCAmJiAhb3B0LnRleHRTdHlsZSkge1xuICAgIG9wdC50ZXh0U3R5bGUgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0U3R5bGU7XG59IC8vIENvbnNpZGVyIGNhc2U6XG4vLyB7XG4vLyAgICAgZGF0YTogW3tcbi8vICAgICAgICAgdmFsdWU6IDEyLFxuLy8gICAgICAgICBsYWJlbDoge1xuLy8gICAgICAgICAgICAgbm9ybWFsOiB7XG4vLyAgICAgICAgICAgICAgICAgcmljaDoge1xuLy8gICAgICAgICAgICAgICAgICAgICAvLyBubyAnYScgaGVyZSBidXQgdXNpbmcgcGFyZW50ICdhJy5cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICB9XSxcbi8vICAgICByaWNoOiB7XG4vLyAgICAgICAgIGE6IHsgLi4uIH1cbi8vICAgICB9XG4vLyB9XG5cblxuZnVuY3Rpb24gZ2V0UmljaEl0ZW1OYW1lcyh0ZXh0U3R5bGVNb2RlbCkge1xuICAvLyBVc2Ugb2JqZWN0IHRvIHJlbW92ZSBkdXBsaWNhdGVkIG5hbWVzLlxuICB2YXIgcmljaEl0ZW1OYW1lTWFwO1xuXG4gIHdoaWxlICh0ZXh0U3R5bGVNb2RlbCAmJiB0ZXh0U3R5bGVNb2RlbCAhPT0gdGV4dFN0eWxlTW9kZWwuZWNNb2RlbCkge1xuICAgIHZhciByaWNoID0gKHRleHRTdHlsZU1vZGVsLm9wdGlvbiB8fCBFTVBUWV9PQkopLnJpY2g7XG5cbiAgICBpZiAocmljaCkge1xuICAgICAgcmljaEl0ZW1OYW1lTWFwID0gcmljaEl0ZW1OYW1lTWFwIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHJpY2gpIHtcbiAgICAgICAgaWYgKHJpY2guaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByaWNoSXRlbU5hbWVNYXBbbmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGV4dFN0eWxlTW9kZWwgPSB0ZXh0U3R5bGVNb2RlbC5wYXJlbnRNb2RlbDtcbiAgfVxuXG4gIHJldHVybiByaWNoSXRlbU5hbWVNYXA7XG59XG5cbmZ1bmN0aW9uIHNldFRva2VuVGV4dFN0eWxlKHRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGdsb2JhbFRleHRTdHlsZSwgb3B0LCBpc0VtcGhhc2lzLCBpc0Jsb2NrKSB7XG4gIC8vIEluIG1lcmdlIG1vZGUsIGRlZmF1bHQgdmFsdWUgc2hvdWxkIG5vdCBiZSBnaXZlbi5cbiAgZ2xvYmFsVGV4dFN0eWxlID0gIWlzRW1waGFzaXMgJiYgZ2xvYmFsVGV4dFN0eWxlIHx8IEVNUFRZX09CSjtcbiAgdGV4dFN0eWxlLnRleHRGaWxsID0gZ2V0QXV0b0NvbG9yKHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2NvbG9yJyksIG9wdCkgfHwgZ2xvYmFsVGV4dFN0eWxlLmNvbG9yO1xuICB0ZXh0U3R5bGUudGV4dFN0cm9rZSA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0Qm9yZGVyQ29sb3InKSwgb3B0KSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoID0genJVdGlsLnJldHJpZXZlMih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0Qm9yZGVyV2lkdGgnKSwgZ2xvYmFsVGV4dFN0eWxlLnRleHRCb3JkZXJXaWR0aCk7XG5cbiAgaWYgKCFpc0VtcGhhc2lzKSB7XG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgIC8vIEFsd2F5cyBzZXQgYGluc2lkZVJvbGxiYWNrYCwgZm9yIGNsZWFyaW5nIHByZXZpb3VzLlxuICAgICAgdmFyIG9yaWdpbmFsVGV4dFBvc2l0aW9uID0gdGV4dFN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgIHRleHRTdHlsZS5pbnNpZGVSb2xsYmFjayA9IGFwcGx5SW5zaWRlU3R5bGUodGV4dFN0eWxlLCBvcmlnaW5hbFRleHRQb3NpdGlvbiwgb3B0KTsgLy8gU2F2ZSBvcmlnaW5hbCB0ZXh0UG9zaXRpb24sIGJlY2F1c2Ugc3R5bGUudGV4dFBvc2l0aW9uIHdpbGwgYmUgcmVwYWxjZWQgYnlcbiAgICAgIC8vIHJlYWwgbG9jYXRpb24gKGxpa2UgWzEwLCAzMF0pIGluIHpyZW5kZXIuXG5cbiAgICAgIHRleHRTdHlsZS5pbnNpZGVPcmlnaW5hbFRleHRQb3NpdGlvbiA9IG9yaWdpbmFsVGV4dFBvc2l0aW9uO1xuICAgICAgdGV4dFN0eWxlLmluc2lkZVJvbGxiYWNrT3B0ID0gb3B0O1xuICAgIH0gLy8gU2V0IGRlZmF1bHQgZmluYWxseS5cblxuXG4gICAgaWYgKHRleHRTdHlsZS50ZXh0RmlsbCA9PSBudWxsKSB7XG4gICAgICB0ZXh0U3R5bGUudGV4dEZpbGwgPSBvcHQuYXV0b0NvbG9yO1xuICAgIH1cbiAgfSAvLyBEbyBub3QgdXNlIGBnZXRGb250YCBoZXJlLCBiZWNhdXNlIG1lcmdlIHNob3VsZCBiZSBzdXBwb3J0ZWQsIHdoZXJlXG4gIC8vIHBhcnQgb2YgdGhlc2UgcHJvcGVydGllcyBtYXkgYmUgY2hhbmdlZCBpbiBlbXBoYXNpcyBzdHlsZSwgYW5kIHRoZVxuICAvLyBvdGhlcnMgc2hvdWxkIHJlbWFpbiB0aGVpciBvcmlnaW5hbCB2YWx1ZSBnb3QgZnJvbSBub3JtYWwgc3R5bGUuXG5cblxuICB0ZXh0U3R5bGUuZm9udFN0eWxlID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRTdHlsZTtcbiAgdGV4dFN0eWxlLmZvbnRXZWlnaHQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRXZWlnaHQ7XG4gIHRleHRTdHlsZS5mb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRTaXplJykgfHwgZ2xvYmFsVGV4dFN0eWxlLmZvbnRTaXplO1xuICB0ZXh0U3R5bGUuZm9udEZhbWlseSA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCBnbG9iYWxUZXh0U3R5bGUuZm9udEZhbWlseTtcbiAgdGV4dFN0eWxlLnRleHRBbGlnbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2FsaWduJyk7XG4gIHRleHRTdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ24nKSB8fCB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdiYXNlbGluZScpO1xuICB0ZXh0U3R5bGUudGV4dExpbmVIZWlnaHQgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdsaW5lSGVpZ2h0Jyk7XG4gIHRleHRTdHlsZS50ZXh0V2lkdGggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd3aWR0aCcpO1xuICB0ZXh0U3R5bGUudGV4dEhlaWdodCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2hlaWdodCcpO1xuICB0ZXh0U3R5bGUudGV4dFRhZyA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RhZycpO1xuXG4gIGlmICghaXNCbG9jayB8fCAhb3B0LmRpc2FibGVCb3gpIHtcbiAgICB0ZXh0U3R5bGUudGV4dEJhY2tncm91bmRDb2xvciA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdiYWNrZ3JvdW5kQ29sb3InKSwgb3B0KTtcbiAgICB0ZXh0U3R5bGUudGV4dFBhZGRpbmcgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdwYWRkaW5nJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3JkZXJDb2xvciA9IGdldEF1dG9Db2xvcih0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdib3JkZXJDb2xvcicpLCBvcHQpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm9yZGVyV2lkdGggPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdib3JkZXJXaWR0aCcpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm9yZGVyUmFkaXVzID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnYm9yZGVyUmFkaXVzJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd0NvbG9yJyk7XG4gICAgdGV4dFN0eWxlLnRleHRCb3hTaGFkb3dCbHVyID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnc2hhZG93Qmx1cicpO1xuICAgIHRleHRTdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3NoYWRvd09mZnNldFgnKTtcbiAgICB0ZXh0U3R5bGUudGV4dEJveFNoYWRvd09mZnNldFkgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCdzaGFkb3dPZmZzZXRZJyk7XG4gIH1cblxuICB0ZXh0U3R5bGUudGV4dFNoYWRvd0NvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd0NvbG9yJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dDb2xvcjtcbiAgdGV4dFN0eWxlLnRleHRTaGFkb3dCbHVyID0gdGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygndGV4dFNoYWRvd0JsdXInKSB8fCBnbG9iYWxUZXh0U3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gIHRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCA9IHRleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ3RleHRTaGFkb3dPZmZzZXRYJykgfHwgZ2xvYmFsVGV4dFN0eWxlLnRleHRTaGFkb3dPZmZzZXRYO1xuICB0ZXh0U3R5bGUudGV4dFNoYWRvd09mZnNldFkgPSB0ZXh0U3R5bGVNb2RlbC5nZXRTaGFsbG93KCd0ZXh0U2hhZG93T2Zmc2V0WScpIHx8IGdsb2JhbFRleHRTdHlsZS50ZXh0U2hhZG93T2Zmc2V0WTtcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b0NvbG9yKGNvbG9yLCBvcHQpIHtcbiAgcmV0dXJuIGNvbG9yICE9PSAnYXV0bycgPyBjb2xvciA6IG9wdCAmJiBvcHQuYXV0b0NvbG9yID8gb3B0LmF1dG9Db2xvciA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5SW5zaWRlU3R5bGUodGV4dFN0eWxlLCB0ZXh0UG9zaXRpb24sIG9wdCkge1xuICB2YXIgdXNlSW5zaWRlU3R5bGUgPSBvcHQudXNlSW5zaWRlU3R5bGU7XG4gIHZhciBpbnNpZGVSb2xsYmFjaztcblxuICBpZiAodGV4dFN0eWxlLnRleHRGaWxsID09IG51bGwgJiYgdXNlSW5zaWRlU3R5bGUgIT09IGZhbHNlICYmICh1c2VJbnNpZGVTdHlsZSA9PT0gdHJ1ZSB8fCBvcHQuaXNSZWN0VGV4dCAmJiB0ZXh0UG9zaXRpb24gLy8gdGV4dFBvc2l0aW9uIGNhbiBiZSBbMTAsIDMwXVxuICAmJiB0eXBlb2YgdGV4dFBvc2l0aW9uID09PSAnc3RyaW5nJyAmJiB0ZXh0UG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCkpIHtcbiAgICBpbnNpZGVSb2xsYmFjayA9IHtcbiAgICAgIHRleHRGaWxsOiBudWxsLFxuICAgICAgdGV4dFN0cm9rZTogdGV4dFN0eWxlLnRleHRTdHJva2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGhcbiAgICB9O1xuICAgIHRleHRTdHlsZS50ZXh0RmlsbCA9ICcjZmZmJzsgLy8gQ29uc2lkZXIgdGV4dCB3aXRoICNmZmYgb3ZlcmZsb3cgaXRzIGNvbnRhaW5lci5cblxuICAgIGlmICh0ZXh0U3R5bGUudGV4dFN0cm9rZSA9PSBudWxsKSB7XG4gICAgICB0ZXh0U3R5bGUudGV4dFN0cm9rZSA9IG9wdC5hdXRvQ29sb3I7XG4gICAgICB0ZXh0U3R5bGUudGV4dFN0cm9rZVdpZHRoID09IG51bGwgJiYgKHRleHRTdHlsZS50ZXh0U3Ryb2tlV2lkdGggPSAyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zaWRlUm9sbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHJvbGxiYWNrSW5zaWRlU3R5bGUoc3R5bGUpIHtcbiAgdmFyIGluc2lkZVJvbGxiYWNrID0gc3R5bGUuaW5zaWRlUm9sbGJhY2s7XG5cbiAgaWYgKGluc2lkZVJvbGxiYWNrKSB7XG4gICAgc3R5bGUudGV4dEZpbGwgPSBpbnNpZGVSb2xsYmFjay50ZXh0RmlsbDtcbiAgICBzdHlsZS50ZXh0U3Ryb2tlID0gaW5zaWRlUm9sbGJhY2sudGV4dFN0cm9rZTtcbiAgICBzdHlsZS50ZXh0U3Ryb2tlV2lkdGggPSBpbnNpZGVSb2xsYmFjay50ZXh0U3Ryb2tlV2lkdGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rm9udChvcHQsIGVjTW9kZWwpIHtcbiAgLy8gZWNNb2RlbCBvciBkZWZhdWx0IHRleHQgc3R5bGUgbW9kZWwuXG4gIHZhciBnVGV4dFN0eWxlTW9kZWwgPSBlY01vZGVsIHx8IGVjTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICByZXR1cm4gWy8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICBvcHQuZm9udFN0eWxlIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgJycsIG9wdC5mb250V2VpZ2h0IHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpIHx8ICcnLCAob3B0LmZvbnRTaXplIHx8IGdUZXh0U3R5bGVNb2RlbCAmJiBnVGV4dFN0eWxlTW9kZWwuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCAxMikgKyAncHgnLCBvcHQuZm9udEZhbWlseSB8fCBnVGV4dFN0eWxlTW9kZWwgJiYgZ1RleHRTdHlsZU1vZGVsLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZU9yU2V0UHJvcHMoaXNVcGRhdGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBkYXRhSW5kZXg7XG4gICAgZGF0YUluZGV4ID0gbnVsbDtcbiAgfSAvLyBEbyBub3QgY2hlY2sgJ2FuaW1hdGlvbicgcHJvcGVydHkgZGlyZWN0bHkgaGVyZS4gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAvLyBhbmltYXRpb24gbW9kZWwgaXMgYW4gYGl0ZW1Nb2RlbGAsIHdob3NlIGRvZXMgbm90IGhhdmUgYGlzQW5pbWF0aW9uRW5hYmxlZGBcbiAgLy8gYnV0IGl0cyBwYXJlbnQgbW9kZWwgKGBzZXJpZXNNb2RlbGApIGRvZXMuXG5cblxuICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCk7XG5cbiAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcbiAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRHVyYXRpb24nICsgcG9zdGZpeCk7XG4gICAgdmFyIGFuaW1hdGlvbkVhc2luZyA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkRlbGF5JyArIHBvc3RmaXgpO1xuXG4gICAgaWYgKHR5cGVvZiBhbmltYXRpb25EZWxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYW5pbWF0aW9uRGVsYXkgPSBhbmltYXRpb25EZWxheShkYXRhSW5kZXgsIGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyA/IGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyhlbCwgZGF0YUluZGV4KSA6IG51bGwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24oZGF0YUluZGV4KTtcbiAgICB9XG5cbiAgICBkdXJhdGlvbiA+IDAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25EZWxheSB8fCAwLCBhbmltYXRpb25FYXNpbmcsIGNiLCAhIWNiKSA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdG9wQW5pbWF0aW9uKCk7XG4gICAgZWwuYXR0cihwcm9wcyk7XG4gICAgY2IgJiYgY2IoKTtcbiAgfVxufVxuLyoqXG4gKiBVcGRhdGUgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlXG4gKiBjb25maWd1cmF0aW9uIGluIHNlcmllcy5cbiAqXG4gKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICogU28gaWYgZG8gbm90IHVzZSB0aGlzIG1ldGhvZCB0byBvbmUgZWxlbWVudCB0d2ljZSBiZWZvcmVcbiAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKiBAZXhhbXBsZVxuICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAqICAgICB9LCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdBbmltYXRpb24gZG9uZSEnKTsgfSk7XG4gKiAgICAgLy8gT3JcbiAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXG4gKiAgICAgfSwgc2VyaWVzTW9kZWwsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBkb25lIScpOyB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gIGFuaW1hdGVPclNldFByb3BzKHRydWUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbn1cbi8qKlxuICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGVcbiAqIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzLlxuICpcbiAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gKiBTbyBpZiBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICogYW5pbWF0aW9uIHN0YXJ0cywgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuXG5mdW5jdGlvbiBpbml0UHJvcHMoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgYW5pbWF0ZU9yU2V0UHJvcHMoZmFsc2UsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbn1cbi8qKlxuICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxuICogaW4gY29vcmRpbmF0ZSBvZiBpdHMgYW5jZXN0b3IgKHBhcmFtIGFuY2VzdG9yKVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IFthbmNlc3Rvcl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybSh0YXJnZXQsIGFuY2VzdG9yKSB7XG4gIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xuXG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xuICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG1hdDtcbn1cbi8qKlxuICogQXBwbHkgdHJhbnNmb3JtIHRvIGFuIHZlcnRleC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldCBbeCwgeV1cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58VHlwZWRBcnJheS48bnVtYmVyPnxPYmplY3R9IHRyYW5zZm9ybSBDYW4gYmU6XG4gKiAgICAgICsgVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cbiAqICAgICAgKyB7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZX0sIHRoZSBzYW1lIGFzIGB6cmVuZGVyL1RyYW5zZm9ybWFibGVgLlxuICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gW3gsIHldXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybSh0YXJnZXQsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gIGlmICh0cmFuc2Zvcm0gJiYgIXpyVXRpbC5pc0FycmF5TGlrZSh0cmFuc2Zvcm0pKSB7XG4gICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgaWYgKGludmVydCkge1xuICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB0YXJnZXQsIHRyYW5zZm9ybSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zZm9ybWVkIGRpcmVjdGlvbi4gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURpcmVjdGlvbihkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG4gIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cbiAgdmFyIGhCYXNlID0gdHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XG4gIHZhciB2QmFzZSA9IHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xuICB2YXIgdmVydGV4ID0gW2RpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLCBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMF07XG4gIHZlcnRleCA9IGFwcGx5VHJhbnNmb3JtKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpO1xuICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSkgPyB2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IHZlcnRleFsxXSA+IDAgPyAnYm90dG9tJyA6ICd0b3AnO1xufVxuLyoqXG4gKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyLlxuICogSWYgbm8gYW5pbWF0YWJsZU1vZGVsLCBubyBhbmltYXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBncm91cFRyYW5zaXRpb24oZzEsIGcyLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XG4gIGlmICghZzEgfHwgIWcyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxNYXAoZykge1xuICAgIHZhciBlbE1hcCA9IHt9O1xuICAgIGcudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICBlbE1hcFtlbC5hbmlkXSA9IGVsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlbE1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuaW1hdGFibGVQcm9wcyhlbCkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBwb3NpdGlvbjogdmVjdG9yLmNsb25lKGVsLnBvc2l0aW9uKSxcbiAgICAgIHJvdGF0aW9uOiBlbC5yb3RhdGlvblxuICAgIH07XG5cbiAgICBpZiAoZWwuc2hhcGUpIHtcbiAgICAgIG9iai5zaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGVsLnNoYXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGVsTWFwMSA9IGdldEVsTWFwKGcxKTtcbiAgZzIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbC5pc0dyb3VwICYmIGVsLmFuaWQpIHtcbiAgICAgIHZhciBvbGRFbCA9IGVsTWFwMVtlbC5hbmlkXTtcblxuICAgICAgaWYgKG9sZEVsKSB7XG4gICAgICAgIHZhciBuZXdQcm9wID0gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKTtcbiAgICAgICAgZWwuYXR0cihnZXRBbmltYXRhYmxlUHJvcHMob2xkRWwpKTtcbiAgICAgICAgdXBkYXRlUHJvcHMoZWwsIG5ld1Byb3AsIGFuaW1hdGFibGVNb2RlbCwgZWwuZGF0YUluZGV4KTtcbiAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAvLyAgICAgaWYgKGVsLnByZXZpb3VzUHJvcHMpIHtcbiAgICAgIC8vICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wc1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vIH1cblxuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcG9pbnRzIExpa2U6IFtbMjMsIDQ0XSwgWzUzLCA2Nl0sIC4uLl1cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gQSBuZXcgY2xpcHBlZCBwb2ludHMuXG4gKi9cblxuXG5mdW5jdGlvbiBjbGlwUG9pbnRzQnlSZWN0KHBvaW50cywgcmVjdCkge1xuICByZXR1cm4genJVdGlsLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgeCA9IG1hdGhNYXgoeCwgcmVjdC54KTtcbiAgICB4ID0gbWF0aE1pbih4LCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICB2YXIgeSA9IHBvaW50WzFdO1xuICAgIHkgPSBtYXRoTWF4KHksIHJlY3QueSk7XG4gICAgeSA9IG1hdGhNaW4oeSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBjbGlwcGVkIHJlY3QuIElmIHJlY3Qgc2l6ZSBhcmUgbmVnYXRpdmUsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBjbGlwUmVjdEJ5UmVjdCh0YXJnZXRSZWN0LCByZWN0KSB7XG4gIHZhciB4ID0gbWF0aE1heCh0YXJnZXRSZWN0LngsIHJlY3QueCk7XG4gIHZhciB4MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC54ICsgdGFyZ2V0UmVjdC53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gIHZhciB5ID0gbWF0aE1heCh0YXJnZXRSZWN0LnksIHJlY3QueSk7XG4gIHZhciB5MiA9IG1hdGhNaW4odGFyZ2V0UmVjdC55ICsgdGFyZ2V0UmVjdC5oZWlnaHQsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblxuICBpZiAoeDIgPj0geCAmJiB5MiA+PSB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHgyIC0geCxcbiAgICAgIGhlaWdodDogeTIgLSB5XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWNvblN0ciBTdXBwb3J0ICdpbWFnZTovLycgb3IgJ3BhdGg6Ly8nIG9yIGRpcmVjdCBzdmcgcGF0aC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBQcm9wZXJ0aWVzIG9mIGBtb2R1bGU6enJlbmRlci9FbGVtZW50YCwgZXhjZXB0IGBzdHlsZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gSWNvbiBwYXRoIG9yIGltYWdlIGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVJY29uKGljb25TdHIsIG9wdCwgcmVjdCkge1xuICBvcHQgPSB6clV0aWwuZXh0ZW5kKHtcbiAgICByZWN0SG92ZXI6IHRydWVcbiAgfSwgb3B0KTtcbiAgdmFyIHN0eWxlID0gb3B0LnN0eWxlID0ge1xuICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgfTtcbiAgcmVjdCA9IHJlY3QgfHwge1xuICAgIHg6IC0xLFxuICAgIHk6IC0xLFxuICAgIHdpZHRoOiAyLFxuICAgIGhlaWdodDogMlxuICB9O1xuXG4gIGlmIChpY29uU3RyKSB7XG4gICAgcmV0dXJuIGljb25TdHIuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCA/IChzdHlsZS5pbWFnZSA9IGljb25TdHIuc2xpY2UoOCksIHpyVXRpbC5kZWZhdWx0cyhzdHlsZSwgcmVjdCksIG5ldyBJbWFnZShvcHQpKSA6IG1ha2VQYXRoKGljb25TdHIucmVwbGFjZSgncGF0aDovLycsICcnKSwgb3B0LCByZWN0LCAnY2VudGVyJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5leHRlbmRTaGFwZSA9IGV4dGVuZFNoYXBlO1xuZXhwb3J0cy5leHRlbmRQYXRoID0gZXh0ZW5kUGF0aDtcbmV4cG9ydHMubWFrZVBhdGggPSBtYWtlUGF0aDtcbmV4cG9ydHMubWFrZUltYWdlID0gbWFrZUltYWdlO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5leHBvcnRzLnJlc2l6ZVBhdGggPSByZXNpemVQYXRoO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplTGluZSA9IHN1YlBpeGVsT3B0aW1pemVMaW5lO1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IHN1YlBpeGVsT3B0aW1pemVSZWN0O1xuZXhwb3J0cy5zdWJQaXhlbE9wdGltaXplID0gc3ViUGl4ZWxPcHRpbWl6ZTtcbmV4cG9ydHMuc2V0SG92ZXJTdHlsZSA9IHNldEhvdmVyU3R5bGU7XG5leHBvcnRzLnNldExhYmVsU3R5bGUgPSBzZXRMYWJlbFN0eWxlO1xuZXhwb3J0cy5zZXRUZXh0U3R5bGUgPSBzZXRUZXh0U3R5bGU7XG5leHBvcnRzLnNldFRleHQgPSBzZXRUZXh0O1xuZXhwb3J0cy5nZXRGb250ID0gZ2V0Rm9udDtcbmV4cG9ydHMudXBkYXRlUHJvcHMgPSB1cGRhdGVQcm9wcztcbmV4cG9ydHMuaW5pdFByb3BzID0gaW5pdFByb3BzO1xuZXhwb3J0cy5nZXRUcmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm07XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLnRyYW5zZm9ybURpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbjtcbmV4cG9ydHMuZ3JvdXBUcmFuc2l0aW9uID0gZ3JvdXBUcmFuc2l0aW9uO1xuZXhwb3J0cy5jbGlwUG9pbnRzQnlSZWN0ID0gY2xpcFBvaW50c0J5UmVjdDtcbmV4cG9ydHMuY2xpcFJlY3RCeVJlY3QgPSBjbGlwUmVjdEJ5UmVjdDtcbmV4cG9ydHMuY3JlYXRlSWNvbiA9IGNyZWF0ZUljb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///233\n");

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar formatUtil = __webpack_require__(245);\n\nvar nubmerUtil = __webpack_require__(235);\n\nvar Model = __webpack_require__(246);\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\n\n\nfunction defaultEmphasis(opt, subOpts) {\n  if (opt) {\n    var emphasisOpt = opt.emphasis = opt.emphasis || {};\n    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {\n        emphasisOpt[subOptName] = normalOpt[subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\n\nfunction getDataItemValue(dataItem) {\n  // Performance sensitive.\n  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\n\n\nfunction converDataValue(value, dimInfo) {\n  // Performance sensitive.\n  var dimType = dimInfo && dimInfo.type;\n\n  if (dimType === 'ordinal') {\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && typeof value !== 'number' && value != null && value !== '-') {\n    value = +nubmerUtil.parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n\n\n  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\nfunction createDataFormatModel(data, opt) {\n  var model = new Model();\n  zrUtil.mixin(model, dataFormatMixin);\n  model.seriesIndex = opt.seriesIndex;\n  model.name = opt.name || '';\n  model.mainType = opt.mainType;\n  model.subType = opt.subType;\n\n  model.getData = function () {\n    return data;\n  };\n\n  return model;\n} // PENDING A little ugly\n\n\nvar dataFormatMixin = {\n  /**\n   * Get params for formatter\n   * @param {number} dataIndex\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex, true);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n    return {\n      componentType: this.mainType,\n      componentSubType: this.subType,\n      seriesType: this.mainType === 'series' ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: this.id,\n      seriesName: this.name,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      marker: formatUtil.getTooltipMarker(color),\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  },\n\n  /**\n   * Format label\n   * @param {number} dataIndex\n   * @param {string} [status='normal'] 'normal' or 'emphasis'\n   * @param {string} [dataType]\n   * @param {number} [dimIndex]\n   * @param {string} [labelProp='label']\n   * @return {string}\n   */\n  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var itemModel = data.getItemModel(dataIndex);\n    var params = this.getDataParams(dataIndex, dataType);\n\n    if (dimIndex != null && params.value instanceof Array) {\n      params.value = params.value[dimIndex];\n    }\n\n    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n    if (typeof formatter === 'function') {\n      params.status = status;\n      return formatter(params);\n    } else if (typeof formatter === 'string') {\n      return formatUtil.formatTpl(formatter, params);\n    }\n  },\n\n  /**\n   * Get raw value in option\n   * @param {number} idx\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getRawValue: function (idx, dataType) {\n    var data = this.getData(dataType);\n    var dataItem = data.getRawDataItem(idx);\n\n    if (dataItem != null) {\n      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n    }\n  },\n\n  /**\n   * Should be implemented.\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   * @return {string} tooltip string\n   */\n  formatTooltip: zrUtil.noop\n};\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\n\nfunction mappingToExists(exists, newCptOptions) {\n  // Mapping by the order by original option (but not order of\n  // new option) in merge mode. Because we should ensure\n  // some specified index (like xAxisIndex) is consistent with\n  // original option, which is easy to understand, espatially in\n  // media query. And in most case, merge option is used to\n  // update partial option but not be expected to change order.\n  newCptOptions = (newCptOptions || []).slice();\n  var result = zrUtil.map(exists || [], function (obj, index) {\n    return {\n      exist: obj\n    };\n  }); // Mapping by id or name if specified.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    } // id has highest priority.\n\n\n    for (var i = 0; i < result.length; i++) {\n      if (!result[i].option // Consider name: two map to one.\n      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Consider name: two map to one.\n      // Can not match when both ids exist but different.\n      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n  }); // Otherwise mapping by index.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    }\n\n    var i = 0;\n\n    for (; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Existing model that already has id should be able to\n      // mapped to (because after mapping performed model may\n      // be assigned with a id, whish should not affect next\n      // mapping), except those has inner id.\n      && !isIdInner(exist) // Caution:\n      // Do not overwrite id. But name can be overwritten,\n      // because axis use name as 'show label text'.\n      // 'exist' always has id and name and we dont\n      // need to check it.\n      && cptOption.id == null) {\n        result[i].option = cptOption;\n        break;\n      }\n    }\n\n    if (i >= result.length) {\n      result.push({\n        option: cptOption\n      });\n    }\n  });\n  return result;\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = zrUtil.createHashMap();\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    existCpt && idMap.set(existCpt.id, item);\n  });\n  each(mapResult, function (item, index) {\n    var opt = item.option;\n    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    var opt = item.option;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'.\n\n    if (existCpt) {\n      keyInfo.id = existCpt.id;\n    } else if (opt.id != null) {\n      keyInfo.id = opt.id + '';\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\n\n\nfunction isIdInner(cptOption) {\n  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = sourceBatch[i].seriesId;\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nvar makeGetter = function () {\n  var index = 0;\n  return function () {\n    var key = '\\0__ec_prop_getter_' + index++;\n    return function (hostObj) {\n      return hostObj[key] || (hostObj[key] = {});\n    };\n  };\n}();\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\n\n\nfunction parseFinder(ecModel, finder, opt) {\n  if (zrUtil.isString(finder)) {\n    var obj = {};\n    obj[finder + 'Index'] = 0;\n    finder = obj;\n  }\n\n  var defaultMainType = opt && opt.defaultMainType;\n\n  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {\n    finder[defaultMainType + 'Index'] = 0;\n  }\n\n  var result = {};\n  each(finder, function (value, key) {\n    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.\n\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      result[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    var queryParam = {\n      mainType: mainType\n    };\n\n    if (queryType !== 'index' || value !== 'all') {\n      queryParam[queryType] = value;\n    }\n\n    var models = ecModel.queryComponents(queryParam);\n    result[mainType + 'Models'] = models;\n    result[mainType + 'Model'] = models[0];\n  });\n  return result;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\n\n\nfunction dataDimToCoordDim(data, dataDim) {\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\n\n\nfunction coordDimToDataDim(data, coordDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n\n    if (dimItem.coordDim === coordDim) {\n      dataDim[dimItem.coordDimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\n\n\nfunction otherDimToDataDim(data, otherDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var otherDims = dimItem.otherDims;\n    var dimIndex = otherDims[otherDim];\n\n    if (dimIndex != null && dimIndex !== false) {\n      dataDim[dimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n\nfunction has(obj, prop) {\n  return obj && obj.hasOwnProperty(prop);\n}\n\nexports.normalizeToArray = normalizeToArray;\nexports.defaultEmphasis = defaultEmphasis;\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\nexports.getDataItemValue = getDataItemValue;\nexports.isDataItemOption = isDataItemOption;\nexports.converDataValue = converDataValue;\nexports.createDataFormatModel = createDataFormatModel;\nexports.dataFormatMixin = dataFormatMixin;\nexports.mappingToExists = mappingToExists;\nexports.makeIdAndName = makeIdAndName;\nexports.isIdInner = isIdInner;\nexports.compressBatches = compressBatches;\nexports.queryDataIndex = queryDataIndex;\nexports.makeGetter = makeGetter;\nexports.parseFinder = parseFinder;\nexports.dataDimToCoordDim = dataDimToCoordDim;\nexports.coordDimToDataDim = coordDimToDataDim;\nexports.otherDimToDataDim = otherDimToDataDim;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzP2UyYmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuXG52YXIgbnVibWVyVXRpbCA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuLyoqXG4gKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBbdmFsdWVdIG9yIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlIDogdmFsdWUgPT0gbnVsbCA/IFtdIDogW3ZhbHVlXTtcbn1cbi8qKlxuICogU3luYyBkZWZhdWx0IG9wdGlvbiBiZXR3ZWVuIG5vcm1hbCBhbmQgZW1waGFzaXMgbGlrZSBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAqIEluIGNhc2Ugc29tZSBvbmUgd2lsbCB3cml0ZSBjb2RlIGxpa2VcbiAqICAgICBsYWJlbDoge1xuICogICAgICAgICBub3JtYWw6IHtcbiAqICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICogICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAqICAgICAgICAgICAgIGZvbnRTaXplOiAxOFxuICogICAgICAgICB9LFxuICogICAgICAgICBlbXBoYXNpczoge1xuICogICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICogICAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3ViT3B0c1xuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdEVtcGhhc2lzKG9wdCwgc3ViT3B0cykge1xuICBpZiAob3B0KSB7XG4gICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgIHZhciBub3JtYWxPcHQgPSBvcHQubm9ybWFsID0gb3B0Lm5vcm1hbCB8fCB7fTsgLy8gRGVmYXVsdCBlbXBoYXNpcyBvcHRpb24gZnJvbSBub3JtYWxcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJPcHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ViT3B0TmFtZSA9IHN1Yk9wdHNbaV07XG5cbiAgICAgIGlmICghZW1waGFzaXNPcHQuaGFzT3duUHJvcGVydHkoc3ViT3B0TmFtZSkgJiYgbm9ybWFsT3B0Lmhhc093blByb3BlcnR5KHN1Yk9wdE5hbWUpKSB7XG4gICAgICAgIGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdID0gbm9ybWFsT3B0W3N1Yk9wdE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgVEVYVF9TVFlMRV9PUFRJT05TID0gWydmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdmb250U2l6ZScsICdmb250RmFtaWx5JywgJ3JpY2gnLCAndGFnJywgJ2NvbG9yJywgJ3RleHRCb3JkZXJDb2xvcicsICd0ZXh0Qm9yZGVyV2lkdGgnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2xpbmVIZWlnaHQnLCAnYWxpZ24nLCAndmVydGljYWxBbGlnbicsICdiYXNlbGluZScsICdzaGFkb3dDb2xvcicsICdzaGFkb3dCbHVyJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WScsICd0ZXh0U2hhZG93Q29sb3InLCAndGV4dFNoYWRvd0JsdXInLCAndGV4dFNoYWRvd09mZnNldFgnLCAndGV4dFNoYWRvd09mZnNldFknLCAnYmFja2dyb3VuZENvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JvcmRlcldpZHRoJywgJ2JvcmRlclJhZGl1cycsICdwYWRkaW5nJ107IC8vIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TID0gbW9kZWxVdGlsLlRFWFRfU1RZTEVfT1BUSU9OUy5jb25jYXQoW1xuLy8gICAgICdwb3NpdGlvbicsICdvZmZzZXQnLCAncm90YXRlJywgJ29yaWdpbicsICdzaG93JywgJ2Rpc3RhbmNlJywgJ2Zvcm1hdHRlcicsXG4vLyAgICAgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknLFxuLy8gICAgIC8vIEZJWE1FOiBkZXByZWNhdGVkLCBjaGVjayBhbmQgcmVtb3ZlIGl0LlxuLy8gICAgICd0ZXh0U3R5bGUnXG4vLyBdKTtcblxuLyoqXG4gKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICogVGhpcyBoZWxwZXIgbWV0aG9kIHJldGlldmVzIHZhbHVlIGZyb20gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8RGF0ZXxBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAqL1xuXG5mdW5jdGlvbiBnZXREYXRhSXRlbVZhbHVlKGRhdGFJdGVtKSB7XG4gIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgcmV0dXJuIGRhdGFJdGVtICYmIChkYXRhSXRlbS52YWx1ZSA9PSBudWxsID8gZGF0YUl0ZW0gOiBkYXRhSXRlbS52YWx1ZSk7XG59XG4vKipcbiAqIGRhdGEgY291bGQgYmUgWzEyLCAyMzIzLCB7dmFsdWU6IDIyM30sIFsxMjIxLCAyM10sIHt2YWx1ZTogWzIsIDIzXX1dXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgZGV0ZXJtaW5lIGlmIGRhdGFJdGVtIGhhcyBleHRyYSBvcHRpb24gYmVzaWRlcyB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICovXG5cblxuZnVuY3Rpb24gaXNEYXRhSXRlbU9wdGlvbihkYXRhSXRlbSkge1xuICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSk7IC8vIC8vIG1hcmtMaW5lIGRhdGEgY2FuIGJlIGFycmF5XG4gIC8vICYmICEoZGF0YUl0ZW1bMF0gJiYgaXNPYmplY3QoZGF0YUl0ZW1bMF0pICYmICEoZGF0YUl0ZW1bMF0gaW5zdGFuY2VvZiBBcnJheSkpO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciBtZXRob2QgY29udmVydCB2YWx1ZSBpbiBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkaW1JbmZvXSBJZiBzdHJpbmcgKGxpa2UgJ3gnKSwgZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbnZlckRhdGFWYWx1ZSh2YWx1ZSwgZGltSW5mbykge1xuICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHZhciBkaW1UeXBlID0gZGltSW5mbyAmJiBkaW1JbmZvLnR5cGU7XG5cbiAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChkaW1UeXBlID09PSAndGltZScgLy8gc3BlYWQgdXAgd2hlbiB1c2luZyB0aW1lc3RhbXBcbiAgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnLScpIHtcbiAgICB2YWx1ZSA9ICtudWJtZXJVdGlsLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gIH0gLy8gZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgLy8gSWYgZGltVHlwZSBpcyBub3Qgb3JkaW5hbCBhbmQgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgTmFOIG9yICctJyxcbiAgLy8gcGFyc2UgdG8gTmFOLlxuXG5cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnID8gTmFOIDogK3ZhbHVlOyAvLyBJZiBzdHJpbmcgKGxpa2UgJy0nKSwgdXNpbmcgJysnIHBhcnNlIHRvIE5hTlxufVxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBwcm94eSB0byBiZSB1c2VkIGluIHRvb2x0aXAgZm9yIGVkZ2UgZGF0YSwgbWFya0xpbmUgZGF0YSwgbWFya1BvaW50IGRhdGEuXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuc2VyaWVzSW5kZXhdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5uYW1lXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHQubWFpblR5cGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5zdWJUeXBlXVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUZvcm1hdE1vZGVsKGRhdGEsIG9wdCkge1xuICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoKTtcbiAgenJVdGlsLm1peGluKG1vZGVsLCBkYXRhRm9ybWF0TWl4aW4pO1xuICBtb2RlbC5zZXJpZXNJbmRleCA9IG9wdC5zZXJpZXNJbmRleDtcbiAgbW9kZWwubmFtZSA9IG9wdC5uYW1lIHx8ICcnO1xuICBtb2RlbC5tYWluVHlwZSA9IG9wdC5tYWluVHlwZTtcbiAgbW9kZWwuc3ViVHlwZSA9IG9wdC5zdWJUeXBlO1xuXG4gIG1vZGVsLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIG1vZGVsO1xufSAvLyBQRU5ESU5HIEEgbGl0dGxlIHVnbHlcblxuXG52YXIgZGF0YUZvcm1hdE1peGluID0ge1xuICAvKipcbiAgICogR2V0IHBhcmFtcyBmb3IgZm9ybWF0dGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RGF0YVBhcmFtczogZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIHJhd1ZhbHVlID0gdGhpcy5nZXRSYXdWYWx1ZShkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICB2YXIgcmF3RGF0YUluZGV4ID0gZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgdmFyIGl0ZW1PcHQgPSBkYXRhLmdldFJhd0RhdGFJdGVtKGRhdGFJbmRleCk7XG4gICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudFR5cGU6IHRoaXMubWFpblR5cGUsXG4gICAgICBjb21wb25lbnRTdWJUeXBlOiB0aGlzLnN1YlR5cGUsXG4gICAgICBzZXJpZXNUeXBlOiB0aGlzLm1haW5UeXBlID09PSAnc2VyaWVzJyA/IHRoaXMuc3ViVHlwZSA6IG51bGwsXG4gICAgICBzZXJpZXNJbmRleDogdGhpcy5zZXJpZXNJbmRleCxcbiAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgc2VyaWVzTmFtZTogdGhpcy5uYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGRhdGFJbmRleDogcmF3RGF0YUluZGV4LFxuICAgICAgZGF0YTogaXRlbU9wdCxcbiAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgIHZhbHVlOiByYXdWYWx1ZSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIG1hcmtlcjogZm9ybWF0VXRpbC5nZXRUb29sdGlwTWFya2VyKGNvbG9yKSxcbiAgICAgIC8vIFBhcmFtIG5hbWUgbGlzdCBmb3IgbWFwcGluZyBgYWAsIGBiYCwgYGNgLCBgZGAsIGBlYFxuICAgICAgJHZhcnM6IFsnc2VyaWVzTmFtZScsICduYW1lJywgJ3ZhbHVlJ11cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXQgbGFiZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXR1cz0nbm9ybWFsJ10gJ25vcm1hbCcgb3IgJ2VtcGhhc2lzJ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbUluZGV4XVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsUHJvcD0nbGFiZWwnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRGb3JtYXR0ZWRMYWJlbDogZnVuY3Rpb24gKGRhdGFJbmRleCwgc3RhdHVzLCBkYXRhVHlwZSwgZGltSW5kZXgsIGxhYmVsUHJvcCkge1xuICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAnbm9ybWFsJztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcblxuICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIHBhcmFtcy52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwYXJhbXMudmFsdWUgPSBwYXJhbXMudmFsdWVbZGltSW5kZXhdO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZXIgPSBpdGVtTW9kZWwuZ2V0KFtsYWJlbFByb3AgfHwgJ2xhYmVsJywgc3RhdHVzLCAnZm9ybWF0dGVyJ10pO1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCByYXcgdmFsdWUgaW4gb3B0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uIChpZHgsIGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oaWR4KTtcblxuICAgIGlmIChkYXRhSXRlbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pICYmICEoZGF0YUl0ZW0gaW5zdGFuY2VvZiBBcnJheSkgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpcGxlU2VyaWVzPWZhbHNlXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFUeXBlXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRvb2x0aXAgc3RyaW5nXG4gICAqL1xuICBmb3JtYXRUb29sdGlwOiB6clV0aWwubm9vcFxufTtcbi8qKlxuICogTWFwcGluZyB0byBleGlzdHMgZm9yIG1lcmdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59IGV4aXN0c1xuICogQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IG5ld0NwdE9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCBvZiB3aGljaCBpcyB0aGUgc2FtZSBhcyBleGlzdHMuXG4gKi9cblxuZnVuY3Rpb24gbWFwcGluZ1RvRXhpc3RzKGV4aXN0cywgbmV3Q3B0T3B0aW9ucykge1xuICAvLyBNYXBwaW5nIGJ5IHRoZSBvcmRlciBieSBvcmlnaW5hbCBvcHRpb24gKGJ1dCBub3Qgb3JkZXIgb2ZcbiAgLy8gbmV3IG9wdGlvbikgaW4gbWVyZ2UgbW9kZS4gQmVjYXVzZSB3ZSBzaG91bGQgZW5zdXJlXG4gIC8vIHNvbWUgc3BlY2lmaWVkIGluZGV4IChsaWtlIHhBeGlzSW5kZXgpIGlzIGNvbnNpc3RlbnQgd2l0aFxuICAvLyBvcmlnaW5hbCBvcHRpb24sIHdoaWNoIGlzIGVhc3kgdG8gdW5kZXJzdGFuZCwgZXNwYXRpYWxseSBpblxuICAvLyBtZWRpYSBxdWVyeS4gQW5kIGluIG1vc3QgY2FzZSwgbWVyZ2Ugb3B0aW9uIGlzIHVzZWQgdG9cbiAgLy8gdXBkYXRlIHBhcnRpYWwgb3B0aW9uIGJ1dCBub3QgYmUgZXhwZWN0ZWQgdG8gY2hhbmdlIG9yZGVyLlxuICBuZXdDcHRPcHRpb25zID0gKG5ld0NwdE9wdGlvbnMgfHwgW10pLnNsaWNlKCk7XG4gIHZhciByZXN1bHQgPSB6clV0aWwubWFwKGV4aXN0cyB8fCBbXSwgZnVuY3Rpb24gKG9iaiwgaW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhpc3Q6IG9ialxuICAgIH07XG4gIH0pOyAvLyBNYXBwaW5nIGJ5IGlkIG9yIG5hbWUgaWYgc3BlY2lmaWVkLlxuXG4gIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlkIGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uIC8vIENvbnNpZGVyIG5hbWU6IHR3byBtYXAgdG8gb25lLlxuICAgICAgJiYgY3B0T3B0aW9uLmlkICE9IG51bGwgJiYgcmVzdWx0W2ldLmV4aXN0LmlkID09PSBjcHRPcHRpb24uaWQgKyAnJykge1xuICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuXG4gICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAvLyBDYW4gbm90IG1hdGNoIHdoZW4gYm90aCBpZHMgZXhpc3QgYnV0IGRpZmZlcmVudC5cbiAgICAgICYmIChleGlzdC5pZCA9PSBudWxsIHx8IGNwdE9wdGlvbi5pZCA9PSBudWxsKSAmJiBjcHRPcHRpb24ubmFtZSAhPSBudWxsICYmICFpc0lkSW5uZXIoY3B0T3B0aW9uKSAmJiAhaXNJZElubmVyKGV4aXN0KSAmJiBleGlzdC5uYW1lID09PSBjcHRPcHRpb24ubmFtZSArICcnKSB7XG4gICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIE90aGVyd2lzZSBtYXBwaW5nIGJ5IGluZGV4LlxuXG4gIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuXG4gICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gRXhpc3RpbmcgbW9kZWwgdGhhdCBhbHJlYWR5IGhhcyBpZCBzaG91bGQgYmUgYWJsZSB0b1xuICAgICAgLy8gbWFwcGVkIHRvIChiZWNhdXNlIGFmdGVyIG1hcHBpbmcgcGVyZm9ybWVkIG1vZGVsIG1heVxuICAgICAgLy8gYmUgYXNzaWduZWQgd2l0aCBhIGlkLCB3aGlzaCBzaG91bGQgbm90IGFmZmVjdCBuZXh0XG4gICAgICAvLyBtYXBwaW5nKSwgZXhjZXB0IHRob3NlIGhhcyBpbm5lciBpZC5cbiAgICAgICYmICFpc0lkSW5uZXIoZXhpc3QpIC8vIENhdXRpb246XG4gICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGlkLiBCdXQgbmFtZSBjYW4gYmUgb3ZlcndyaXR0ZW4sXG4gICAgICAvLyBiZWNhdXNlIGF4aXMgdXNlIG5hbWUgYXMgJ3Nob3cgbGFiZWwgdGV4dCcuXG4gICAgICAvLyAnZXhpc3QnIGFsd2F5cyBoYXMgaWQgYW5kIG5hbWUgYW5kIHdlIGRvbnRcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaXQuXG4gICAgICAmJiBjcHRPcHRpb24uaWQgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIG9wdGlvbjogY3B0T3B0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNYWtlIGlkIGFuZCBuYW1lIGZvciBtYXBwaW5nIHJlc3VsdCAocmVzdWx0IG9mIG1hcHBpbmdUb0V4aXN0cylcbiAqIGludG8gYGtleUluZm9gIGZpZWxkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFJlc3VsdCwgbGlrZSBbe2V4aXN0OiAuLi4sIG9wdGlvbjogLi4ufSwge31dLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIG9yZGVyIGlzIHRoZSBzYW1lIGFzIGV4aXN0cy5cbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBtYWtlSWRBbmROYW1lKG1hcFJlc3VsdCkge1xuICAvLyBXZSB1c2UgdGhpcyBpZCB0byBoYXNoIGNvbXBvbmVudCBtb2RlbHMgYW5kIHZpZXcgaW5zdGFuY2VzXG4gIC8vIGluIGVjaGFydHMuIGlkIGNhbiBiZSBzcGVjaWZpZWQgYnkgdXNlciwgb3IgYXV0byBnZW5lcmF0ZWQuXG4gIC8vIFRoZSBpZCBnZW5lcmF0aW9uIHJ1bGUgZW5zdXJlcyBuZXcgdmlldyBpbnN0YW5jZSBhcmUgYWJsZVxuICAvLyB0byBtYXBwZWQgdG8gb2xkIGluc3RhbmNlIHdoZW4gc2V0T3B0aW9uIGFyZSBjYWxsZWQgaW5cbiAgLy8gbm8tbWVyZ2UgbW9kZS4gU28gd2UgZ2VuZXJhdGUgbW9kZWwgaWQgYnkgbmFtZSBhbmQgcGx1c1xuICAvLyB0eXBlIGluIHZpZXcgaWQuXG4gIC8vIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgYW1vbmcgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmVuaWVudFxuICAvLyB0byBzcGVjaWZ5IG11bHRpIGNvbXBvbmVudHMgKGxpa2Ugc2VyaWVzKSBieSBvbmUgbmFtZS5cbiAgLy8gRW5zdXJlIHRoYXQgZWFjaCBpZCBpcyBkaXN0aW5jdC5cbiAgdmFyIGlkTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTtcbiAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHZhciBleGlzdENwdCA9IGl0ZW0uZXhpc3Q7XG4gICAgZXhpc3RDcHQgJiYgaWRNYXAuc2V0KGV4aXN0Q3B0LmlkLCBpdGVtKTtcbiAgfSk7XG4gIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG4gICAgenJVdGlsLmFzc2VydCghb3B0IHx8IG9wdC5pZCA9PSBudWxsIHx8ICFpZE1hcC5nZXQob3B0LmlkKSB8fCBpZE1hcC5nZXQob3B0LmlkKSA9PT0gaXRlbSwgJ2lkIGR1cGxpY2F0ZXM6ICcgKyAob3B0ICYmIG9wdC5pZCkpO1xuICAgIG9wdCAmJiBvcHQuaWQgIT0gbnVsbCAmJiBpZE1hcC5zZXQob3B0LmlkLCBpdGVtKTtcbiAgICAhaXRlbS5rZXlJbmZvICYmIChpdGVtLmtleUluZm8gPSB7fSk7XG4gIH0pOyAvLyBNYWtlIG5hbWUgYW5kIGlkLlxuXG4gIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICB2YXIga2V5SW5mbyA9IGl0ZW0ua2V5SW5mbztcblxuICAgIGlmICghaXNPYmplY3Qob3B0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbmFtZSBjYW4gYmUgb3ZlcndpdHRlbi4gQ29uc2lkZXIgY2FzZTogYXhpcy5uYW1lID0gJzIwa20nLlxuICAgIC8vIEJ1dCBpZCBnZW5lcmF0ZWQgYnkgbmFtZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLCB3aGljaCBhZmZlY3RcbiAgICAvLyBvbmx5IGluIHRoYXQgY2FzZTogc2V0T3B0aW9uIHdpdGggJ25vdCBtZXJnZSBtb2RlJyBhbmQgdmlld1xuICAgIC8vIGluc3RhbmNlIHdpbGwgYmUgcmVjcmVhdGVkLCB3aGljaCBjYW4gYmUgYWNjZXB0ZWQuXG5cblxuICAgIGtleUluZm8ubmFtZSA9IG9wdC5uYW1lICE9IG51bGwgPyBvcHQubmFtZSArICcnIDogZXhpc3RDcHQgPyBleGlzdENwdC5uYW1lIDogJ1xcMC0nOyAvLyBuYW1lIG1heSBiZSBkaXNwbGF5ZWQgb24gc2NyZWVuLCBzbyB1c2UgJy0nLlxuXG4gICAgaWYgKGV4aXN0Q3B0KSB7XG4gICAgICBrZXlJbmZvLmlkID0gZXhpc3RDcHQuaWQ7XG4gICAgfSBlbHNlIGlmIChvcHQuaWQgIT0gbnVsbCkge1xuICAgICAga2V5SW5mby5pZCA9IG9wdC5pZCArICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb25zaWRlciB0aGlzIHNpdHVhdG9pbjpcbiAgICAgIC8vICBvcHRpb25BOiBbe25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9LCB7Li59XVxuICAgICAgLy8gIG9wdGlvbkIgW3suLn0sIHtuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfV1cbiAgICAgIC8vIFNlcmllcyB3aXRoIHRoZSBzYW1lIG5hbWUgYmV0d2VlbiBvcHRpb25BIGFuZCBvcHRpb25CXG4gICAgICAvLyBzaG91bGQgYmUgbWFwcGVkLlxuICAgICAgdmFyIGlkTnVtID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBrZXlJbmZvLmlkID0gJ1xcMCcgKyBrZXlJbmZvLm5hbWUgKyAnXFwwJyArIGlkTnVtKys7XG4gICAgICB9IHdoaWxlIChpZE1hcC5nZXQoa2V5SW5mby5pZCkpO1xuICAgIH1cblxuICAgIGlkTWFwLnNldChrZXlJbmZvLmlkLCBpdGVtKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjcHRPcHRpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0lkSW5uZXIoY3B0T3B0aW9uKSB7XG4gIHJldHVybiBpc09iamVjdChjcHRPcHRpb24pICYmIGNwdE9wdGlvbi5pZCAmJiAoY3B0T3B0aW9uLmlkICsgJycpLmluZGV4T2YoJ1xcMF9lY19cXDAnKSA9PT0gMDtcbn1cbi8qKlxuICogQSBoZWxwZXIgZm9yIHJlbW92aW5nIGR1cGxpY2F0ZSBpdGVtcyBiZXR3ZWVuIGJhdGNoQSBhbmQgYmF0Y2hCLFxuICogYW5kIGluIHRoZW1zZWx2ZXMsIGFuZCBjYXRlZ29yaXplIGJ5IHNlcmllcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEEgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hCIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgQXJyYXkuPE9iamVjdD4+fSByZXN1bHQ6IFtyZXN1bHRCYXRjaEEsIHJlc3VsdEJhdGNoQl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXByZXNzQmF0Y2hlcyhiYXRjaEEsIGJhdGNoQikge1xuICB2YXIgbWFwQSA9IHt9O1xuICB2YXIgbWFwQiA9IHt9O1xuICBtYWtlTWFwKGJhdGNoQSB8fCBbXSwgbWFwQSk7XG4gIG1ha2VNYXAoYmF0Y2hCIHx8IFtdLCBtYXBCLCBtYXBBKTtcbiAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcblxuICBmdW5jdGlvbiBtYWtlTWFwKHNvdXJjZUJhdGNoLCBtYXAsIG90aGVyTWFwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZUJhdGNoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzSWQgPSBzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZDtcbiAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoc291cmNlQmF0Y2hbaV0uZGF0YUluZGV4KTtcbiAgICAgIHZhciBvdGhlckRhdGFJbmRpY2VzID0gb3RoZXJNYXAgJiYgb3RoZXJNYXBbc2VyaWVzSWRdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRhdGFJbmRpY2VzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gZGF0YUluZGljZXNbal07XG5cbiAgICAgICAgaWYgKG90aGVyRGF0YUluZGljZXMgJiYgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdKSB7XG4gICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAobWFwW3Nlcmllc0lkXSB8fCAobWFwW3Nlcmllc0lkXSA9IHt9KSlbZGF0YUluZGV4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCwgaXNEYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoaSkgJiYgbWFwW2ldICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzRGF0YSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCtpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtYXBUb0FycmF5KG1hcFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgZGF0YUluZGljZXMubGVuZ3RoICYmIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHNlcmllc0lkOiBpLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgQ29udGFpbnMgZGF0YUluZGV4IChtZWFucyByYXdJbmRleCkgLyBkYXRhSW5kZXhJbnNpZGUgLyBuYW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIG9mIHdoaWNoIGNhbiBiZSBBcnJheSBvciBwcmltYXJ5IHR5cGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGRhdGFJbmRleCBJZiBub3QgZm91bmQsIHJldHVybiB1bmRlZmluZWQvbnVsbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1ZXJ5RGF0YUluZGV4KGRhdGEsIHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuZGF0YUluZGV4SW5zaWRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5kYXRhSW5kZXhJbnNpZGU7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgIHJldHVybiB6clV0aWwuaXNBcnJheShwYXlsb2FkLmRhdGFJbmRleCkgPyB6clV0aWwubWFwKHBheWxvYWQuZGF0YUluZGV4LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZSYXdJbmRleCh2YWx1ZSk7XG4gICAgfSkgOiBkYXRhLmluZGV4T2ZSYXdJbmRleChwYXlsb2FkLmRhdGFJbmRleCk7XG4gIH0gZWxzZSBpZiAocGF5bG9hZC5uYW1lICE9IG51bGwpIHtcbiAgICByZXR1cm4genJVdGlsLmlzQXJyYXkocGF5bG9hZC5uYW1lKSA/IHpyVXRpbC5tYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZOYW1lKHZhbHVlKTtcbiAgICB9KSA6IGRhdGEuaW5kZXhPZk5hbWUocGF5bG9hZC5uYW1lKTtcbiAgfVxufVxuLyoqXG4gKiBFbmFibGUgcHJvcGVydHkgc3RvcmFnZSB0byBhbnkgaG9zdCBvYmplY3QuXG4gKiBOb3RpY2U6IFNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIHZhciBnZXQgPSBtb2RlbFVpdGwubWFrZUdldHRlcigpO1xuICpcbiAqIGZ1bmN0aW9uIHNvbWUoaG9zdE9iaikge1xuICogICAgICBnZXQoaG9zdE9iaikuX3NvbWVQcm9wZXJ0eSA9IDEyMTI7XG4gKiAgICAgIC4uLlxuICogfVxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleSA9ICdcXDBfX2VjX3Byb3BfZ2V0dGVyXycgKyBpbmRleCsrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaG9zdE9iaikge1xuICAgICAgcmV0dXJuIGhvc3RPYmpba2V5XSB8fCAoaG9zdE9ialtrZXldID0ge30pO1xuICAgIH07XG4gIH07XG59KCk7XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4LCBzZXJpZXNJZCwgc2VyaWVzTmFtZSxcbiAqICAgICAgICAgICAgZ2VvSW5kZXgsIGdlb0lkLCBnZW9OYW1lLFxuICogICAgICAgICAgICBibWFwSW5kZXgsIGJtYXBJZCwgYm1hcE5hbWUsXG4gKiAgICAgICAgICAgIHhBeGlzSW5kZXgsIHhBeGlzSWQsIHhBeGlzTmFtZSxcbiAqICAgICAgICAgICAgeUF4aXNJbmRleCwgeUF4aXNJZCwgeUF4aXNOYW1lLFxuICogICAgICAgICAgICBncmlkSW5kZXgsIGdyaWRJZCwgZ3JpZE5hbWUsXG4gKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICogICAgICAgIH1cbiAqICAgICAgICBFYWNoIHByb3BlcnRpZXMgY2FuIGJlIG51bWJlcnxzdHJpbmd8QXJyYXkuPG51bWJlcj58QXJyYXkuPHN0cmluZz5cbiAqICAgICAgICBGb3IgZXhhbXBsZSwgYSBmaW5kZXIgY291bGQgYmVcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHNlcmllc0luZGV4OiAzLFxuICogICAgICAgICAgICBnZW9JZDogWydhYScsICdjYyddLFxuICogICAgICAgICAgICBncmlkTmFtZTogWyd4eCcsICdyciddXG4gKiAgICAgICAgfVxuICogICAgICAgIHh4eEluZGV4IGNhbiBiZSBzZXQgYXMgJ2FsbCcgKG1lYW5zIGFsbCB4eHgpIG9yICdub25lJyAobWVhbnMgbm90IHNwZWNpZnkpXG4gKiAgICAgICAgSWYgbm90aGluZyBvciBudWxsL3VuZGVmaW5lZCBzcGVjaWZpZWQsIHJldHVybiBub3RoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5kZWZhdWx0TWFpblR5cGVdXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0LmluY2x1ZGVNYWluVHlwZXNdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBsaWtlOlxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgc2VyaWVzTW9kZWxzOiBbc2VyaWVzTW9kZWwxLCBzZXJpZXNNb2RlbDJdLFxuICogICAgICAgICAgICBzZXJpZXNNb2RlbDogc2VyaWVzTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAqICAgICAgICAgICAgZ2VvTW9kZWxzOiBbZ2VvTW9kZWwxLCBnZW9Nb2RlbDJdLFxuICogICAgICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAqICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgfVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VGaW5kZXIoZWNNb2RlbCwgZmluZGVyLCBvcHQpIHtcbiAgaWYgKHpyVXRpbC5pc1N0cmluZyhmaW5kZXIpKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialtmaW5kZXIgKyAnSW5kZXgnXSA9IDA7XG4gICAgZmluZGVyID0gb2JqO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRNYWluVHlwZSA9IG9wdCAmJiBvcHQuZGVmYXVsdE1haW5UeXBlO1xuXG4gIGlmIChkZWZhdWx0TWFpblR5cGUgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdJbmRleCcpICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnSWQnKSAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ05hbWUnKSkge1xuICAgIGZpbmRlcltkZWZhdWx0TWFpblR5cGUgKyAnSW5kZXgnXSA9IDA7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG4gIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGZpbmRlcltrZXldOyAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cblxuICAgIGlmIChrZXkgPT09ICdkYXRhSW5kZXgnIHx8IGtleSA9PT0gJ2RhdGFJbmRleEluc2lkZScpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEtleSA9IGtleS5tYXRjaCgvXihcXHcrKShJbmRleHxJZHxOYW1lKSQvKSB8fCBbXTtcbiAgICB2YXIgbWFpblR5cGUgPSBwYXJzZWRLZXlbMV07XG4gICAgdmFyIHF1ZXJ5VHlwZSA9IChwYXJzZWRLZXlbMl0gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIW1haW5UeXBlIHx8ICFxdWVyeVR5cGUgfHwgdmFsdWUgPT0gbnVsbCB8fCBxdWVyeVR5cGUgPT09ICdpbmRleCcgJiYgdmFsdWUgPT09ICdub25lJyB8fCBvcHQgJiYgb3B0LmluY2x1ZGVNYWluVHlwZXMgJiYgenJVdGlsLmluZGV4T2Yob3B0LmluY2x1ZGVNYWluVHlwZXMsIG1haW5UeXBlKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlQYXJhbSA9IHtcbiAgICAgIG1haW5UeXBlOiBtYWluVHlwZVxuICAgIH07XG5cbiAgICBpZiAocXVlcnlUeXBlICE9PSAnaW5kZXgnIHx8IHZhbHVlICE9PSAnYWxsJykge1xuICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIG1vZGVscyA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHF1ZXJ5UGFyYW0pO1xuICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICByZXN1bHRbbWFpblR5cGUgKyAnTW9kZWwnXSA9IG1vZGVsc1swXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGRhdGFEaW1Ub0Nvb3JkRGltKGRhdGEsIGRhdGFEaW0pIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnM7XG4gIGRhdGFEaW0gPSBkYXRhLmdldERpbWVuc2lvbihkYXRhRGltKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltSXRlbSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1lbnNpb25zW2ldKTtcblxuICAgIGlmIChkaW1JdGVtLm5hbWUgPT09IGRhdGFEaW0pIHtcbiAgICAgIHJldHVybiBkaW1JdGVtLmNvb3JkRGltO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkRGltXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGF0YSBkaW1lbnNpb25zIG9uIHRoZSBjb29yZERpbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvb3JkRGltVG9EYXRhRGltKGRhdGEsIGNvb3JkRGltKSB7XG4gIHZhciBkYXRhRGltID0gW107XG4gIGVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuXG4gICAgaWYgKGRpbUl0ZW0uY29vcmREaW0gPT09IGNvb3JkRGltKSB7XG4gICAgICBkYXRhRGltW2RpbUl0ZW0uY29vcmREaW1JbmRleF0gPSBkaW1JdGVtLm5hbWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGFEaW07XG59XG4vKipcbiAqIEBzZWUge21vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9uc31cbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gb3RoZXJEaW0gQ2FuIGJlIGBvdGhlckRpbXNgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGxpa2UgJ2xhYmVsJyBvciAndG9vbHRpcCcuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGF0YSBkaW1lbnNpb25zIG9uIHRoZSBvdGhlckRpbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG90aGVyRGltVG9EYXRhRGltKGRhdGEsIG90aGVyRGltKSB7XG4gIHZhciBkYXRhRGltID0gW107XG4gIGVhY2goZGF0YS5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltTmFtZSkge1xuICAgIHZhciBkaW1JdGVtID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbU5hbWUpO1xuICAgIHZhciBvdGhlckRpbXMgPSBkaW1JdGVtLm90aGVyRGltcztcbiAgICB2YXIgZGltSW5kZXggPSBvdGhlckRpbXNbb3RoZXJEaW1dO1xuXG4gICAgaWYgKGRpbUluZGV4ICE9IG51bGwgJiYgZGltSW5kZXggIT09IGZhbHNlKSB7XG4gICAgICBkYXRhRGltW2RpbUluZGV4XSA9IGRpbUl0ZW0ubmFtZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YURpbTtcbn1cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcCkge1xuICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheTtcbmV4cG9ydHMuZGVmYXVsdEVtcGhhc2lzID0gZGVmYXVsdEVtcGhhc2lzO1xuZXhwb3J0cy5URVhUX1NUWUxFX09QVElPTlMgPSBURVhUX1NUWUxFX09QVElPTlM7XG5leHBvcnRzLmdldERhdGFJdGVtVmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlO1xuZXhwb3J0cy5pc0RhdGFJdGVtT3B0aW9uID0gaXNEYXRhSXRlbU9wdGlvbjtcbmV4cG9ydHMuY29udmVyRGF0YVZhbHVlID0gY29udmVyRGF0YVZhbHVlO1xuZXhwb3J0cy5jcmVhdGVEYXRhRm9ybWF0TW9kZWwgPSBjcmVhdGVEYXRhRm9ybWF0TW9kZWw7XG5leHBvcnRzLmRhdGFGb3JtYXRNaXhpbiA9IGRhdGFGb3JtYXRNaXhpbjtcbmV4cG9ydHMubWFwcGluZ1RvRXhpc3RzID0gbWFwcGluZ1RvRXhpc3RzO1xuZXhwb3J0cy5tYWtlSWRBbmROYW1lID0gbWFrZUlkQW5kTmFtZTtcbmV4cG9ydHMuaXNJZElubmVyID0gaXNJZElubmVyO1xuZXhwb3J0cy5jb21wcmVzc0JhdGNoZXMgPSBjb21wcmVzc0JhdGNoZXM7XG5leHBvcnRzLnF1ZXJ5RGF0YUluZGV4ID0gcXVlcnlEYXRhSW5kZXg7XG5leHBvcnRzLm1ha2VHZXR0ZXIgPSBtYWtlR2V0dGVyO1xuZXhwb3J0cy5wYXJzZUZpbmRlciA9IHBhcnNlRmluZGVyO1xuZXhwb3J0cy5kYXRhRGltVG9Db29yZERpbSA9IGRhdGFEaW1Ub0Nvb3JkRGltO1xuZXhwb3J0cy5jb29yZERpbVRvRGF0YURpbSA9IGNvb3JkRGltVG9EYXRhRGltO1xuZXhwb3J0cy5vdGhlckRpbVRvRGF0YURpbSA9IG90aGVyRGltVG9EYXRhRGltO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///234\n");

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n/**\n * Linear mapping a value from domain to range\n * @memberOf module:echarts/util/number\n * @param  {(number|Array.<number>)} val\n * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n * @param  {boolean} clamp\n * @return {(number|Array.<number>}\n */\n\n\nfunction linearMap(val, domain, range, clamp) {\n  var subDomain = domain[1] - domain[0];\n  var subRange = range[1] - range[0];\n\n  if (subDomain === 0) {\n    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n  } // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n\n\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= domain[0]) {\n        return range[0];\n      } else if (val >= domain[1]) {\n        return range[1];\n      }\n    } else {\n      if (val >= domain[0]) {\n        return range[0];\n      } else if (val <= domain[1]) {\n        return range[1];\n      }\n    }\n  } else {\n    if (val === domain[0]) {\n      return range[0];\n    }\n\n    if (val === domain[1]) {\n      return range[1];\n    }\n  }\n\n  return (val - domain[0]) / subDomain * subRange + range[0];\n}\n/**\n * Convert a percent string to absolute number.\n * Returns NaN if percent is not a valid string or number\n * @memberOf module:echarts/util/number\n * @param {string|number} percent\n * @param {number} all\n * @return {number}\n */\n\n\nfunction parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n\n  if (typeof percent === 'string') {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n\n    return parseFloat(percent);\n  }\n\n  return percent == null ? NaN : +percent;\n}\n/**\n * (1) Fix rounding error of float numbers.\n * (2) Support return string to avoid scientific notation like '3.5e-7'.\n *\n * @param {number} x\n * @param {number} [precision]\n * @param {boolean} [returnStr]\n * @return {number|string}\n */\n\n\nfunction round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  } // Avoid range error\n\n\n  precision = Math.min(Math.max(0, precision), 20);\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n\nfunction asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\n * Get precision\n * @param {number} val\n */\n\n\nfunction getPrecision(val) {\n  val = +val;\n\n  if (isNaN(val)) {\n    return 0;\n  } // It is much faster than methods converting number to string as follows\n  //      var tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n\n\n  var e = 1;\n  var count = 0;\n\n  while (Math.round(val * e) / e !== val) {\n    e *= 10;\n    count++;\n  }\n\n  return count;\n}\n/**\n * @param {string|number} val\n * @return {number}\n */\n\n\nfunction getPrecisionSafe(val) {\n  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'\n\n  var eIndex = str.indexOf('e');\n\n  if (eIndex > 0) {\n    var precision = +str.slice(eIndex + 1);\n    return precision < 0 ? -precision : 0;\n  } else {\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n  }\n}\n/**\n * Minimal dicernible data precisioin according to a single pixel.\n *\n * @param {Array.<number>} dataExtent\n * @param {Array.<number>} pixelExtent\n * @return {number} precision\n */\n\n\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.\n\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\n * Get a data of given precision, assuring the sum of percentages\n * in valueList is 1.\n * The largest remainer method is used.\n * https://en.wikipedia.org/wiki/Largest_remainder_method\n *\n * @param {Array.<number>} valueList a list of all data\n * @param {number} idx index of the data to be processed in valueList\n * @param {number} precision integer number showing digits of precision\n * @return {number} percent ranging from 0 to 100\n */\n\n\nfunction getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n\n  if (sum === 0) {\n    return 0;\n  }\n\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  }); // Has remainding votes.\n\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    } // Add a vote to max remainder.\n\n\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n\n  return seats[idx] / digits;\n} // Number.MAX_SAFE_INTEGER, ie do not support.\n\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * To 0 - 2 * PI, considering negative radian.\n * @param {number} radian\n * @return {number}\n */\n\nfunction remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\n * @param {type} radian\n * @return {boolean}\n */\n\n\nfunction isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n/**\n * @param {string|Date|number} value These values can be accepted:\n *   + An instance of Date, represent a time in its own time zone.\n *   + Or string in a subset of ISO 8601, only including:\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n *     all of which will be treated as local time if time zone is not specified\n *     (see <https://momentjs.com/>).\n *   + Or other string format, including (all of which will be treated as loacal time):\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n *   + a timestamp, which represent a time in UTC.\n * @return {Date} date\n */\n\nfunction parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string') {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    } // Use local time when no timezone offset specifed.\n\n\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n        var hour = +match[4] || 0;\n\n        if (match[8].toUpperCase() !== 'Z') {\n          hour -= match[8].slice(0, 3);\n        }\n\n        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n      }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n\n  return new Date(Math.round(value));\n}\n/**\n * Quantity of a number. e.g. 0.1, 1, 10, 100\n *\n * @param  {number} val\n * @return {number}\n */\n\n\nfunction quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n\nfunction quantityExponent(val) {\n  return Math.floor(Math.log(val) / Math.LN10);\n}\n/**\n * find a “nice” number approximately equal to x. Round the number if round = true,\n * take ceiling if round = false. The primary observation is that the “nicest”\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n *\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n *\n * @param  {number} val Non-negative value.\n * @param  {boolean} round\n * @return {number}\n */\n\n\nfunction nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n\n  var nf;\n\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n\n  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\n * Order intervals asc, and split them when overlap.\n * expect(numberUtil.reformIntervals([\n *     {interval: [18, 62], close: [1, 1]},\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [1, 1]},\n *     {interval: [62, 150], close: [1, 1]},\n *     {interval: [106, 150], close: [1, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ])).toEqual([\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [0, 1]},\n *     {interval: [18, 62], close: [0, 1]},\n *     {interval: [62, 150], close: [0, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ]);\n * @param {Array.<Object>} list, where `close` mean open or close\n *        of the interval, and Infinity can be used.\n * @return {Array.<Object>} The origin list, which has been reformed.\n */\n\n\nfunction reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close = list[i].close;\n\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close[lg] = !lg ? 1 - currClose : 1;\n      }\n\n      curr = interval[lg];\n      currClose = close[lg];\n    }\n\n    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return list;\n\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\n * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n * subtraction forces infinities to NaN\n *\n * @param {*} v\n * @return {boolean}\n */\n\n\nfunction isNumeric(v) {\n  return v - parseFloat(v) >= 0;\n}\n\nexports.linearMap = linearMap;\nexports.parsePercent = parsePercent;\nexports.round = round;\nexports.asc = asc;\nexports.getPrecision = getPrecision;\nexports.getPrecisionSafe = getPrecisionSafe;\nexports.getPixelPrecision = getPixelPrecision;\nexports.getPercentWithPrecision = getPercentWithPrecision;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.remRadian = remRadian;\nexports.isRadianAroundZero = isRadianAroundZero;\nexports.parseDate = parseDate;\nexports.quantity = quantity;\nexports.nice = nice;\nexports.reformIntervals = reformIntervals;\nexports.isNumeric = isNumeric;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL251bWJlci5qcz80M2UzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUkFESUFOX0VQU0lMT04gPSAxZS00O1xuXG5mdW5jdGlvbiBfdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbn1cbi8qKlxuICogTGluZWFyIG1hcHBpbmcgYSB2YWx1ZSBmcm9tIGRvbWFpbiB0byByYW5nZVxuICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gKiBAcGFyYW0gIHsobnVtYmVyfEFycmF5LjxudW1iZXI+KX0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZG9tYWluIERvbWFpbiBleHRlbnQgZG9tYWluWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiBkb21haW5bMV1cbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAqIEByZXR1cm4geyhudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBsaW5lYXJNYXAodmFsLCBkb21haW4sIHJhbmdlLCBjbGFtcCkge1xuICB2YXIgc3ViRG9tYWluID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICB2YXIgc3ViUmFuZ2UgPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuXG4gIGlmIChzdWJEb21haW4gPT09IDApIHtcbiAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDAgPyByYW5nZVswXSA6IChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDI7XG4gIH0gLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgLy8gaXMgYSBob3RzcG90LlxuXG5cbiAgaWYgKGNsYW1wKSB7XG4gICAgaWYgKHN1YkRvbWFpbiA+IDApIHtcbiAgICAgIGlmICh2YWwgPD0gZG9tYWluWzBdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsID49IGRvbWFpblsxXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWwgPj0gZG9tYWluWzBdKSB7XG4gICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDw9IGRvbWFpblsxXSkge1xuICAgICAgICByZXR1cm4gcmFuZ2VbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPT09IGRvbWFpblswXSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IGRvbWFpblsxXSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAodmFsIC0gZG9tYWluWzBdKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcmFuZ2VbMF07XG59XG4vKipcbiAqIENvbnZlcnQgYSBwZXJjZW50IHN0cmluZyB0byBhYnNvbHV0ZSBudW1iZXIuXG4gKiBSZXR1cm5zIE5hTiBpZiBwZXJjZW50IGlzIG5vdCBhIHZhbGlkIHN0cmluZyBvciBudW1iZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0ge251bWJlcn0gYWxsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQocGVyY2VudCwgYWxsKSB7XG4gIHN3aXRjaCAocGVyY2VudCkge1xuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgIHBlcmNlbnQgPSAnNTAlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHBlcmNlbnQgPSAnMTAwJSc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGVyY2VudCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoX3RyaW0ocGVyY2VudCkubWF0Y2goLyUkLykpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBlcmNlbnQgPT0gbnVsbCA/IE5hTiA6ICtwZXJjZW50O1xufVxuLyoqXG4gKiAoMSkgRml4IHJvdW5kaW5nIGVycm9yIG9mIGZsb2F0IG51bWJlcnMuXG4gKiAoMikgU3VwcG9ydCByZXR1cm4gc3RyaW5nIHRvIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAnMy41ZS03Jy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5TdHJdXG4gKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gcm91bmQoeCwgcHJlY2lzaW9uLCByZXR1cm5TdHIpIHtcbiAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgcHJlY2lzaW9uID0gMTA7XG4gIH0gLy8gQXZvaWQgcmFuZ2UgZXJyb3JcblxuXG4gIHByZWNpc2lvbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHByZWNpc2lvbiksIDIwKTtcbiAgeCA9ICgreCkudG9GaXhlZChwcmVjaXNpb24pO1xuICByZXR1cm4gcmV0dXJuU3RyID8geCA6ICt4O1xufVxuXG5mdW5jdGlvbiBhc2MoYXJyKSB7XG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTtcbiAgcmV0dXJuIGFycjtcbn1cbi8qKlxuICogR2V0IHByZWNpc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKHZhbCkge1xuICB2YWwgPSArdmFsO1xuXG4gIGlmIChpc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSXQgaXMgbXVjaCBmYXN0ZXIgdGhhbiBtZXRob2RzIGNvbnZlcnRpbmcgbnVtYmVyIHRvIHN0cmluZyBhcyBmb2xsb3dzXG4gIC8vICAgICAgdmFyIHRtcCA9IHZhbC50b1N0cmluZygpO1xuICAvLyAgICAgIHJldHVybiB0bXAubGVuZ3RoIC0gMSAtIHRtcC5pbmRleE9mKCcuJyk7XG4gIC8vIGVzcGVjaWFsbHkgd2hlbiBwcmVjaXNpb24gaXMgbG93XG5cblxuICB2YXIgZSA9IDE7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgd2hpbGUgKE1hdGgucm91bmQodmFsICogZSkgLyBlICE9PSB2YWwpIHtcbiAgICBlICo9IDEwO1xuICAgIGNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQcmVjaXNpb25TYWZlKHZhbCkge1xuICB2YXIgc3RyID0gdmFsLnRvU3RyaW5nKCk7IC8vIENvbnNpZGVyIHNjaWVudGlmaWMgbm90YXRpb246ICczLjRlLTEyJyAnMy40ZSsxMidcblxuICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcblxuICBpZiAoZUluZGV4ID4gMCkge1xuICAgIHZhciBwcmVjaXNpb24gPSArc3RyLnNsaWNlKGVJbmRleCArIDEpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPCAwID8gLXByZWNpc2lvbiA6IDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRvdEluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICByZXR1cm4gZG90SW5kZXggPCAwID8gMCA6IHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG4gIH1cbn1cbi8qKlxuICogTWluaW1hbCBkaWNlcm5pYmxlIGRhdGEgcHJlY2lzaW9pbiBhY2NvcmRpbmcgdG8gYSBzaW5nbGUgcGl4ZWwuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGl4ZWxFeHRlbnRcbiAqIEByZXR1cm4ge251bWJlcn0gcHJlY2lzaW9uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQaXhlbFByZWNpc2lvbihkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTsgLy8gdG9GaXhlZCgpIGRpZ2l0cyBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjAuXG5cbiAgdmFyIHByZWNpc2lvbiA9IE1hdGgubWluKE1hdGgubWF4KC1kYXRhUXVhbnRpdHkgKyBzaXplUXVhbnRpdHksIDApLCAyMCk7XG4gIHJldHVybiAhaXNGaW5pdGUocHJlY2lzaW9uKSA/IDIwIDogcHJlY2lzaW9uO1xufVxuLyoqXG4gKiBHZXQgYSBkYXRhIG9mIGdpdmVuIHByZWNpc2lvbiwgYXNzdXJpbmcgdGhlIHN1bSBvZiBwZXJjZW50YWdlc1xuICogaW4gdmFsdWVMaXN0IGlzIDEuXG4gKiBUaGUgbGFyZ2VzdCByZW1haW5lciBtZXRob2QgaXMgdXNlZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhcmdlc3RfcmVtYWluZGVyX21ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlTGlzdCBhIGxpc3Qgb2YgYWxsIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHggaW5kZXggb2YgdGhlIGRhdGEgdG8gYmUgcHJvY2Vzc2VkIGluIHZhbHVlTGlzdFxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiBpbnRlZ2VyIG51bWJlciBzaG93aW5nIGRpZ2l0cyBvZiBwcmVjaXNpb25cbiAqIEByZXR1cm4ge251bWJlcn0gcGVyY2VudCByYW5naW5nIGZyb20gMCB0byAxMDBcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uKHZhbHVlTGlzdCwgaWR4LCBwcmVjaXNpb24pIHtcbiAgaWYgKCF2YWx1ZUxpc3RbaWR4XSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHN1bSA9IHpyVXRpbC5yZWR1Y2UodmFsdWVMaXN0LCBmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICByZXR1cm4gYWNjICsgKGlzTmFOKHZhbCkgPyAwIDogdmFsKTtcbiAgfSwgMCk7XG5cbiAgaWYgKHN1bSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRpZ2l0cyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICB2YXIgdm90ZXNQZXJRdW90YSA9IHpyVXRpbC5tYXAodmFsdWVMaXN0LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIChpc05hTih2YWwpID8gMCA6IHZhbCkgLyBzdW0gKiBkaWdpdHMgKiAxMDA7XG4gIH0pO1xuICB2YXIgdGFyZ2V0U2VhdHMgPSBkaWdpdHMgKiAxMDA7XG4gIHZhciBzZWF0cyA9IHpyVXRpbC5tYXAodm90ZXNQZXJRdW90YSwgZnVuY3Rpb24gKHZvdGVzKSB7XG4gICAgLy8gQXNzaWduIGF1dG9tYXRpYyBzZWF0cy5cbiAgICByZXR1cm4gTWF0aC5mbG9vcih2b3Rlcyk7XG4gIH0pO1xuICB2YXIgY3VycmVudFN1bSA9IHpyVXRpbC5yZWR1Y2Uoc2VhdHMsIGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgIHJldHVybiBhY2MgKyB2YWw7XG4gIH0sIDApO1xuICB2YXIgcmVtYWluZGVyID0genJVdGlsLm1hcCh2b3Rlc1BlclF1b3RhLCBmdW5jdGlvbiAodm90ZXMsIGlkeCkge1xuICAgIHJldHVybiB2b3RlcyAtIHNlYXRzW2lkeF07XG4gIH0pOyAvLyBIYXMgcmVtYWluZGluZyB2b3Rlcy5cblxuICB3aGlsZSAoY3VycmVudFN1bSA8IHRhcmdldFNlYXRzKSB7XG4gICAgLy8gRmluZCBuZXh0IGxhcmdlc3QgcmVtYWluZGVyLlxuICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heElkID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZW1haW5kZXIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChyZW1haW5kZXJbaV0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gcmVtYWluZGVyW2ldO1xuICAgICAgICBtYXhJZCA9IGk7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgYSB2b3RlIHRvIG1heCByZW1haW5kZXIuXG5cblxuICAgICsrc2VhdHNbbWF4SWRdO1xuICAgIHJlbWFpbmRlclttYXhJZF0gPSAwO1xuICAgICsrY3VycmVudFN1bTtcbiAgfVxuXG4gIHJldHVybiBzZWF0c1tpZHhdIC8gZGlnaXRzO1xufSAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgaWUgZG8gbm90IHN1cHBvcnQuXG5cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuLyoqXG4gKiBUbyAwIC0gMiAqIFBJLCBjb25zaWRlcmluZyBuZWdhdGl2ZSByYWRpYW4uXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gcmVtUmFkaWFuKHJhZGlhbikge1xuICB2YXIgcGkyID0gTWF0aC5QSSAqIDI7XG4gIHJldHVybiAocmFkaWFuICUgcGkyICsgcGkyKSAlIHBpMjtcbn1cbi8qKlxuICogQHBhcmFtIHt0eXBlfSByYWRpYW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1JhZGlhbkFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiAtUkFESUFOX0VQU0lMT04gJiYgdmFsIDwgUkFESUFOX0VQU0lMT047XG59XG5cbnZhciBUSU1FX1JFRyA9IC9eKD86KFxcZHs0fSkoPzpbLVxcL10oXFxkezEsMn0pKD86Wy1cXC9dKFxcZHsxLDJ9KSg/OltUIF0oXFxkezEsMn0pKD86OihcXGRcXGQpKD86OihcXGRcXGQpKD86Wy4sXShcXGQrKSk/KT8pPyhafFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQpPyk/KT8pPyk/JC87IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV8bnVtYmVyfSB2YWx1ZSBUaGVzZSB2YWx1ZXMgY2FuIGJlIGFjY2VwdGVkOlxuICogICArIEFuIGluc3RhbmNlIG9mIERhdGUsIHJlcHJlc2VudCBhIHRpbWUgaW4gaXRzIG93biB0aW1lIHpvbmUuXG4gKiAgICsgT3Igc3RyaW5nIGluIGEgc3Vic2V0IG9mIElTTyA4NjAxLCBvbmx5IGluY2x1ZGluZzpcbiAqICAgICArIG9ubHkgeWVhciwgbW9udGgsIGRhdGU6ICcyMDEyLTAzJywgJzIwMTItMDMtMDEnLCAnMjAxMi0wMy0wMSAwNScsICcyMDEyLTAzLTAxIDA1OjA2JyxcbiAqICAgICArIHNlcGFyYXRlZCB3aXRoIFQgb3Igc3BhY2U6ICcyMDEyLTAzLTAxVDEyOjIyOjMzLjEyMycsICcyMDEyLTAzLTAxIDEyOjIyOjMzLjEyMycsXG4gKiAgICAgKyB0aW1lIHpvbmU6ICcyMDEyLTAzLTAxVDEyOjIyOjMzWicsICcyMDEyLTAzLTAxVDEyOjIyOjMzKzgwMDAnLCAnMjAxMi0wMy0wMVQxMjoyMjozMy0wNTowMCcsXG4gKiAgICAgYWxsIG9mIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBsb2NhbCB0aW1lIGlmIHRpbWUgem9uZSBpcyBub3Qgc3BlY2lmaWVkXG4gKiAgICAgKHNlZSA8aHR0cHM6Ly9tb21lbnRqcy5jb20vPikuXG4gKiAgICsgT3Igb3RoZXIgc3RyaW5nIGZvcm1hdCwgaW5jbHVkaW5nIChhbGwgb2Ygd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGxvYWNhbCB0aW1lKTpcbiAqICAgICAnMjAxMicsICcyMDEyLTMtMScsICcyMDEyLzMvMScsICcyMDEyLzAzLzAxJyxcbiAqICAgICAnMjAwOS82LzEyIDI6MDAnLCAnMjAwOS82LzEyIDI6MDU6MDgnLCAnMjAwOS82LzEyIDI6MDU6MDguMTIzJ1xuICogICArIGEgdGltZXN0YW1wLCB3aGljaCByZXByZXNlbnQgYSB0aW1lIGluIFVUQy5cbiAqIEByZXR1cm4ge0RhdGV9IGRhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZURhdGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRGlmZmVyZW50IGJyb3dzZXJzIHBhcnNlIGRhdGUgaW4gZGlmZmVyZW50IHdheSwgc28gd2UgcGFyc2UgaXQgbWFudWFsbHkuXG4gICAgLy8gU29tZSBvdGhlciBpc3N1ZXM6XG4gICAgLy8gbmV3IERhdGUoJzE5NzAtMDEtMDEnKSBpcyBVVEMsXG4gICAgLy8gbmV3IERhdGUoJzE5NzAvMDEvMDEnKSBhbmQgbmV3IERhdGUoJzE5NzAtMS0wMScpIGlzIGxvY2FsLlxuICAgIC8vIFNlZSBpc3N1ZSAjMzYyM1xuICAgIHZhciBtYXRjaCA9IFRJTUVfUkVHLmV4ZWModmFsdWUpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gcmV0dXJuIEludmFsaWQgRGF0ZS5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH0gLy8gVXNlIGxvY2FsIHRpbWUgd2hlbiBubyB0aW1lem9uZSBvZmZzZXQgc3BlY2lmZWQuXG5cblxuICAgIGlmICghbWF0Y2hbOF0pIHtcbiAgICAgIC8vIG1hdGNoW25dIGNhbiBvbmx5IGJlIHN0cmluZyBvciB1bmRlZmluZWQuXG4gICAgICAvLyBCdXQgdGFrZSBjYXJlIG9mICcxMicgKyAxID0+ICcxMjEnLlxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCttYXRjaFsxXSwgKyhtYXRjaFsyXSB8fCAxKSAtIDEsICttYXRjaFszXSB8fCAxLCArbWF0Y2hbNF0gfHwgMCwgKyhtYXRjaFs1XSB8fCAwKSwgK21hdGNoWzZdIHx8IDAsICttYXRjaFs3XSB8fCAwKTtcbiAgICB9IC8vIFRpbWV6b25lb2Zmc2V0IG9mIEphdmFzY3JpcHQgRGF0ZSBoYXMgY29uc2lkZXJlZCBEU1QgKERheWxpZ2h0IFNhdmluZyBUaW1lLFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRheWxpZ2h0LXNhdmluZy10aW1lLWFkanVzdG1lbnQpLlxuICAgIC8vIEZvciBleGFtcGxlLCBzeXN0ZW0gdGltZXpvbmUgaXMgc2V0IGFzIFwiVGltZSBab25lOiBBbWVyaWNhL1Rvcm9udG9cIixcbiAgICAvLyB0aGVuIHRoZXNlIGNvZGUgd2lsbCBnZXQgZGlmZmVyZW50IHJlc3VsdDpcbiAgICAvLyBgbmV3IERhdGUoMTQ3ODQxMTk5OTk5OSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgIC8vIGdldCAyNDBgXG4gICAgLy8gYG5ldyBEYXRlKDE0Nzg0MTIwMDAwMDApLmdldFRpbWV6b25lT2Zmc2V0KCk7ICAvLyBnZXQgMzAwYFxuICAgIC8vIFNvIHdlIHNob3VsZCBub3QgdXNlIGBuZXcgRGF0ZWAsIGJ1dCB1c2UgYERhdGUuVVRDYC5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGhvdXIgPSArbWF0Y2hbNF0gfHwgMDtcblxuICAgICAgICBpZiAobWF0Y2hbOF0udG9VcHBlckNhc2UoKSAhPT0gJ1onKSB7XG4gICAgICAgICAgaG91ciAtPSBtYXRjaFs4XS5zbGljZSgwLCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrbWF0Y2hbMV0sICsobWF0Y2hbMl0gfHwgMSkgLSAxLCArbWF0Y2hbM10gfHwgMSwgaG91ciwgKyhtYXRjaFs1XSB8fCAwKSwgK21hdGNoWzZdIHx8IDAsICttYXRjaFs3XSB8fCAwKSk7XG4gICAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQodmFsdWUpKTtcbn1cbi8qKlxuICogUXVhbnRpdHkgb2YgYSBudW1iZXIuIGUuZy4gMC4xLCAxLCAxMCwgMTAwXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YW50aXR5KHZhbCkge1xuICByZXR1cm4gTWF0aC5wb3coMTAsIHF1YW50aXR5RXhwb25lbnQodmFsKSk7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXR5RXhwb25lbnQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApO1xufVxuLyoqXG4gKiBmaW5kIGEg4oCcbmljZeKAnSBudW1iZXIgYXBwcm94aW1hdGVseSBlcXVhbCB0byB4LiBSb3VuZCB0aGUgbnVtYmVyIGlmIHJvdW5kID0gdHJ1ZSxcbiAqIHRha2UgY2VpbGluZyBpZiByb3VuZCA9IGZhbHNlLiBUaGUgcHJpbWFyeSBvYnNlcnZhdGlvbiBpcyB0aGF0IHRoZSDigJxuaWNlc3TigJ1cbiAqIG51bWJlcnMgaW4gZGVjaW1hbCBhcmUgMSwgMiwgYW5kIDUsIGFuZCBhbGwgcG93ZXItb2YtdGVuIG11bHRpcGxlcyBvZiB0aGVzZSBudW1iZXJzLlxuICpcbiAqIFNlZSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsIE5vbi1uZWdhdGl2ZSB2YWx1ZS5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBuaWNlKHZhbCwgcm91bmQpIHtcbiAgdmFyIGV4cG9uZW50ID0gcXVhbnRpdHlFeHBvbmVudCh2YWwpO1xuICB2YXIgZXhwMTAgPSBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICB2YXIgZiA9IHZhbCAvIGV4cDEwOyAvLyAxIDw9IGYgPCAxMFxuXG4gIHZhciBuZjtcblxuICBpZiAocm91bmQpIHtcbiAgICBpZiAoZiA8IDEuNSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIuNSkge1xuICAgICAgbmYgPSAyO1xuICAgIH0gZWxzZSBpZiAoZiA8IDQpIHtcbiAgICAgIG5mID0gMztcbiAgICB9IGVsc2UgaWYgKGYgPCA3KSB7XG4gICAgICBuZiA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5mID0gMTA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChmIDwgMSkge1xuICAgICAgbmYgPSAxO1xuICAgIH0gZWxzZSBpZiAoZiA8IDIpIHtcbiAgICAgIG5mID0gMjtcbiAgICB9IGVsc2UgaWYgKGYgPCAzKSB7XG4gICAgICBuZiA9IDM7XG4gICAgfSBlbHNlIGlmIChmIDwgNSkge1xuICAgICAgbmYgPSA1O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZiA9IDEwO1xuICAgIH1cbiAgfVxuXG4gIHZhbCA9IG5mICogZXhwMTA7IC8vIEZpeCAzICogMC4xID09PSAwLjMwMDAwMDAwMDAwMDAwMDA0IGlzc3VlIChzZWUgSUVFRSA3NTQpLlxuICAvLyAyMCBpcyB0aGUgdXBwcGVyIGJvdW5kIG9mIHRvRml4ZWQuXG5cbiAgcmV0dXJuIGV4cG9uZW50ID49IC0yMCA/ICt2YWwudG9GaXhlZChleHBvbmVudCA8IDAgPyAtZXhwb25lbnQgOiAwKSA6IHZhbDtcbn1cbi8qKlxuICogT3JkZXIgaW50ZXJ2YWxzIGFzYywgYW5kIHNwbGl0IHRoZW0gd2hlbiBvdmVybGFwLlxuICogZXhwZWN0KG51bWJlclV0aWwucmVmb3JtSW50ZXJ2YWxzKFtcbiAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstSW5maW5pdHksIC03MF0sIGNsb3NlOiBbMCwgMF19LFxuICogICAgIHtpbnRlcnZhbDogWy03MCwgLTI2XSwgY2xvc2U6IFsxLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzYyLCAxNTBdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFsxMDYsIDE1MF0sIGNsb3NlOiBbMSwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICogXSkpLnRvRXF1YWwoW1xuICogICAgIHtpbnRlcnZhbDogWy1JbmZpbml0eSwgLTcwXSwgY2xvc2U6IFswLCAwXX0sXG4gKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAqICAgICB7aW50ZXJ2YWw6IFstMjYsIDE4XSwgY2xvc2U6IFswLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbMTgsIDYyXSwgY2xvc2U6IFswLCAxXX0sXG4gKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMCwgMV19LFxuICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICogXSk7XG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBsaXN0LCB3aGVyZSBgY2xvc2VgIG1lYW4gb3BlbiBvciBjbG9zZVxuICogICAgICAgIG9mIHRoZSBpbnRlcnZhbCwgYW5kIEluZmluaXR5IGNhbiBiZSB1c2VkLlxuICogQHJldHVybiB7QXJyYXkuPE9iamVjdD59IFRoZSBvcmlnaW4gbGlzdCwgd2hpY2ggaGFzIGJlZW4gcmVmb3JtZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZWZvcm1JbnRlcnZhbHMobGlzdCkge1xuICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gbGl0dGxlVGhhbihhLCBiLCAwKSA/IC0xIDogMTtcbiAgfSk7XG4gIHZhciBjdXJyID0gLUluZmluaXR5O1xuICB2YXIgY3VyckNsb3NlID0gMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOykge1xuICAgIHZhciBpbnRlcnZhbCA9IGxpc3RbaV0uaW50ZXJ2YWw7XG4gICAgdmFyIGNsb3NlID0gbGlzdFtpXS5jbG9zZTtcblxuICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICBpZiAoaW50ZXJ2YWxbbGddIDw9IGN1cnIpIHtcbiAgICAgICAgaW50ZXJ2YWxbbGddID0gY3VycjtcbiAgICAgICAgY2xvc2VbbGddID0gIWxnID8gMSAtIGN1cnJDbG9zZSA6IDE7XG4gICAgICB9XG5cbiAgICAgIGN1cnIgPSBpbnRlcnZhbFtsZ107XG4gICAgICBjdXJyQ2xvc2UgPSBjbG9zZVtsZ107XG4gICAgfVxuXG4gICAgaWYgKGludGVydmFsWzBdID09PSBpbnRlcnZhbFsxXSAmJiBjbG9zZVswXSAqIGNsb3NlWzFdICE9PSAxKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xuXG4gIGZ1bmN0aW9uIGxpdHRsZVRoYW4oYSwgYiwgbGcpIHtcbiAgICByZXR1cm4gYS5pbnRlcnZhbFtsZ10gPCBiLmludGVydmFsW2xnXSB8fCBhLmludGVydmFsW2xnXSA9PT0gYi5pbnRlcnZhbFtsZ10gJiYgKGEuY2xvc2VbbGddIC0gYi5jbG9zZVtsZ10gPT09ICghbGcgPyAxIDogLTEpIHx8ICFsZyAmJiBsaXR0bGVUaGFuKGEsIGIsIDEpKTtcbiAgfVxufVxuLyoqXG4gKiBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gKiAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gKiBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAqXG4gKiBAcGFyYW0geyp9IHZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc051bWVyaWModikge1xuICByZXR1cm4gdiAtIHBhcnNlRmxvYXQodikgPj0gMDtcbn1cblxuZXhwb3J0cy5saW5lYXJNYXAgPSBsaW5lYXJNYXA7XG5leHBvcnRzLnBhcnNlUGVyY2VudCA9IHBhcnNlUGVyY2VudDtcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuYXNjID0gYXNjO1xuZXhwb3J0cy5nZXRQcmVjaXNpb24gPSBnZXRQcmVjaXNpb247XG5leHBvcnRzLmdldFByZWNpc2lvblNhZmUgPSBnZXRQcmVjaXNpb25TYWZlO1xuZXhwb3J0cy5nZXRQaXhlbFByZWNpc2lvbiA9IGdldFBpeGVsUHJlY2lzaW9uO1xuZXhwb3J0cy5nZXRQZXJjZW50V2l0aFByZWNpc2lvbiA9IGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uO1xuZXhwb3J0cy5NQVhfU0FGRV9JTlRFR0VSID0gTUFYX1NBRkVfSU5URUdFUjtcbmV4cG9ydHMucmVtUmFkaWFuID0gcmVtUmFkaWFuO1xuZXhwb3J0cy5pc1JhZGlhbkFyb3VuZFplcm8gPSBpc1JhZGlhbkFyb3VuZFplcm87XG5leHBvcnRzLnBhcnNlRGF0ZSA9IHBhcnNlRGF0ZTtcbmV4cG9ydHMucXVhbnRpdHkgPSBxdWFudGl0eTtcbmV4cG9ydHMubmljZSA9IG5pY2U7XG5leHBvcnRzLnJlZm9ybUludGVydmFscyA9IHJlZm9ybUludGVydmFscztcbmV4cG9ydHMuaXNOdW1lcmljID0gaXNOdW1lcmljO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL251bWJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///235\n");

/***/ }),
/* 236 */
/***/ (function(module, exports) {

eval("var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个向量\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * 复制向量数据\n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 克隆一个向量\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 设置向量的两个项\n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} 结果\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * 向量相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * 向量缩放后相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * 向量相减\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * 向量长度\n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * 向量长度平方\n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * 向量乘法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * 向量除法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * 向量点乘\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * 向量缩放\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * 向量归一化\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * 计算向量间距离\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * 向量距离平方\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * 求负向量\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * 插值两个点\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * 矩阵左乘向量\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * 求两个向量最小值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * 求两个向量最大值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcz82NjU0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuXG4gIGlmICh4ID09IG51bGwpIHtcbiAgICB4ID0gMDtcbiAgfVxuXG4gIGlmICh5ID09IG51bGwpIHtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuWQkemHj+aVsOaNrlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWFi+mahuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUodikge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIHYxLCB2MiwgYSkge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/plb/luqZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gbGVuKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChsZW5TcXVhcmUodikpO1xufVxuXG52YXIgbGVuZ3RoID0gbGVuOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLyoqXG4gKiDlkJHph4/plb/luqblubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGxlblNxdWFyZSh2KSB7XG4gIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xufVxuXG52YXIgbGVuZ3RoU3F1YXJlID0gbGVuU3F1YXJlO1xuLyoqXG4gKiDlkJHph4/kuZjms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuZnVuY3Rpb24gbXVsKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mZpOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/ngrnkuZhcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIHYsIHMpIHtcbiAgb3V0WzBdID0gdlswXSAqIHM7XG4gIG91dFsxXSA9IHZbMV0gKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/lvZLkuIDljJZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIHYpIHtcbiAgdmFyIGQgPSBsZW4odik7XG5cbiAgaWYgKGQgPT09IDApIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKHYxLCB2Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KCh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKSk7XG59XG5cbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIOWQkemHj+i3neemu+W5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlKHYxLCB2Mikge1xuICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xufVxuXG52YXIgZGlzdFNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuLyoqXG4gKiDmsYLotJ/lkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCB2KSB7XG4gIG91dFswXSA9IC12WzBdO1xuICBvdXRbMV0gPSAtdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5o+S5YC85Lik5Liq54K5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCB2MSwgdjIsIHQpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteW3puS5mOWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybShvdXQsIHYsIG0pIHtcbiAgdmFyIHggPSB2WzBdO1xuICB2YXIgeSA9IHZbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5zdWIgPSBzdWI7XG5leHBvcnRzLmxlbiA9IGxlbjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5TcXVhcmUgPSBsZW5TcXVhcmU7XG5leHBvcnRzLmxlbmd0aFNxdWFyZSA9IGxlbmd0aFNxdWFyZTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy5kaXYgPSBkaXY7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbmV4cG9ydHMuZGlzdGFuY2VTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbmV4cG9ydHMuZGlzdFNxdWFyZSA9IGRpc3RTcXVhcmU7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///236\n");

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {// (1) The code `if (__DEV__) ...` can be removed by build tool.\n// (2) If intend to use `__DEV__`, this module should be imported. Use a global\n// variable `__DEV__` may cause that miss the declaration (see #6535), or the\n// declaration is behind of the using position (for example in `Model.extent`,\n// And tools like rollup can not analysis the dependency if not import).\nvar dev; // In browser\n\nif (typeof window !== 'undefined') {\n  dev = window.__DEV__;\n} // In node\nelse if (typeof global !== 'undefined') {\n    dev = global.__DEV__;\n  }\n\nif (typeof dev === 'undefined') {\n  dev = true;\n}\n\nvar __DEV__ = dev;\nexports.__DEV__ = __DEV__;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb25maWcuanM/MmY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAoMSkgVGhlIGNvZGUgYGlmIChfX0RFVl9fKSAuLi5gIGNhbiBiZSByZW1vdmVkIGJ5IGJ1aWxkIHRvb2wuXG4vLyAoMikgSWYgaW50ZW5kIHRvIHVzZSBgX19ERVZfX2AsIHRoaXMgbW9kdWxlIHNob3VsZCBiZSBpbXBvcnRlZC4gVXNlIGEgZ2xvYmFsXG4vLyB2YXJpYWJsZSBgX19ERVZfX2AgbWF5IGNhdXNlIHRoYXQgbWlzcyB0aGUgZGVjbGFyYXRpb24gKHNlZSAjNjUzNSksIG9yIHRoZVxuLy8gZGVjbGFyYXRpb24gaXMgYmVoaW5kIG9mIHRoZSB1c2luZyBwb3NpdGlvbiAoZm9yIGV4YW1wbGUgaW4gYE1vZGVsLmV4dGVudGAsXG4vLyBBbmQgdG9vbHMgbGlrZSByb2xsdXAgY2FuIG5vdCBhbmFseXNpcyB0aGUgZGVwZW5kZW5jeSBpZiBub3QgaW1wb3J0KS5cbnZhciBkZXY7IC8vIEluIGJyb3dzZXJcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRldiA9IHdpbmRvdy5fX0RFVl9fO1xufSAvLyBJbiBub2RlXG5lbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRldiA9IGdsb2JhbC5fX0RFVl9fO1xuICB9XG5cbmlmICh0eXBlb2YgZGV2ID09PSAndW5kZWZpbmVkJykge1xuICBkZXYgPSB0cnVlO1xufVxuXG52YXIgX19ERVZfXyA9IGRldjtcbmV4cG9ydHMuX19ERVZfXyA9IF9fREVWX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///237\n");

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(268);\n\nvar zrUtil = __webpack_require__(230);\n\nvar PathProxy = __webpack_require__(260);\n\nvar pathContain = __webpack_require__(364);\n\nvar Pattern = __webpack_require__(291);\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanM/YzExOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///238\n");

/***/ }),
/* 239 */
/***/ (function(module, exports) {

eval("/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qcz85Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZWNoYXJ0c+iuvuWkh+eOr+Wig+ivhuWIq1xuICpcbiAqIEBkZXNjIGVjaGFydHPln7rkuo5DYW52YXPvvIznuq9KYXZhc2NyaXB05Zu+6KGo5bqT77yM5o+Q5L6b55u06KeC77yM55Sf5Yqo77yM5Y+v5Lqk5LqS77yM5Y+v5Liq5oCn5YyW5a6a5Yi255qE5pWw5o2u57uf6K6h5Zu+6KGo44CCXG4gKiBAYXV0aG9yIGZpcmVkZVtmaXJlZGVAZmlyZWRlLnVzXVxuICogQGRlc2MgdGhhbmtzIHplcHRvLlxuICovXG52YXIgZW52ID0ge307XG5cbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAvLyBJbiBub2RlXG4gIGVudiA9IHtcbiAgICBicm93c2VyOiB7fSxcbiAgICBvczoge30sXG4gICAgbm9kZTogdHJ1ZSxcbiAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgIGNhbnZhc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBzdmdTdXBwb3J0ZWQ6IHRydWVcbiAgfTtcbn0gZWxzZSB7XG4gIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gZW52OyAvLyBaZXB0by5qc1xuLy8gKGMpIDIwMTAtMjAxMyBUaG9tYXMgRnVjaHNcbi8vIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5mdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgdmFyIG9zID0ge307XG4gIHZhciBicm93c2VyID0ge307IC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuXG4gIHZhciBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKTsgLy8gdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgLy8gdmFyIHdlYnZpZXcgPSB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pICYmICFjaHJvbWU7XG5cbiAgdmFyIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKSAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICB8fCB1YS5tYXRjaCgvVHJpZGVudFxcLy4rP3J2OigoW1xcZC5dKykpLyk7XG4gIHZhciBlZGdlID0gdWEubWF0Y2goL0VkZ2VcXC8oW1xcZC5dKykvKTsgLy8gSUUgMTIgYW5kIDEyK1xuXG4gIHZhciB3ZUNoYXQgPSAvbWljcm9tZXNzZW5nZXIvaS50ZXN0KHVhKTsgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgLy8gLSBkaXNjZXJuIChtb3JlKSBiZXR3ZWVuIG11bHRpcGxlIGJyb3dzZXJzIG9uIGFuZHJvaWRcbiAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XG4gIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gIC8vIC0gcG9zc2libHkgZGV2aWRlIGluIG9zLCBkZXZpY2UgYW5kIGJyb3dzZXIgaGFzaGVzXG4gIC8vIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG4gIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG5cbiAgaWYgKGZpcmVmb3gpIHtcbiAgICBicm93c2VyLmZpcmVmb3ggPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG4gIH0gLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAvLyBpZiAod2VidmlldykgYnJvd3Nlci53ZWJ2aWV3ID0gdHJ1ZTtcblxuXG4gIGlmIChpZSkge1xuICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICB9XG5cbiAgaWYgKGVkZ2UpIHtcbiAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGVkZ2VbMV07XG4gIH0gLy8gSXQgaXMgZGlmZmljdWx0IHRvIGRldGVjdCBXZUNoYXQgaW4gV2luIFBob25lIHByZWNpc2VseSwgYmVjYXVzZSB1YSBjYW5cbiAgLy8gbm90IGJlIHNldCBvbiB3aW4gcGhvbmUuIFNvIHdlIGRvIG5vdCBjb25zaWRlciBXaW4gUGhvbmUuXG5cblxuICBpZiAod2VDaGF0KSB7XG4gICAgYnJvd3Nlci53ZUNoYXQgPSB0cnVlO1xuICB9IC8vIG9zLnRhYmxldCA9ICEhKGlwYWQgfHwgcGxheWJvb2sgfHwgKGFuZHJvaWQgJiYgIXVhLm1hdGNoKC9Nb2JpbGUvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAvLyAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cblxuICByZXR1cm4ge1xuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgb3M6IG9zLFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgIC8vIGNhbnZhc1N1cHBvcnRlZCA6ICEoYnJvd3Nlci5pZSAmJiBwYXJzZUZsb2F0KGJyb3dzZXIudmVyc2lvbikgPCA5KVxuICAgIGNhbnZhc1N1cHBvcnRlZDogISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0LFxuICAgIHN2Z1N1cHBvcnRlZDogdHlwZW9mIFNWR1JlY3QgIT09ICd1bmRlZmluZWQnLFxuICAgIC8vIEBzZWUgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgxNzAyOS93aGF0cy10aGUtYmVzdC13YXktdG8tZGV0ZWN0LWEtdG91Y2gtc2NyZWVuLWRldmljZS11c2luZy1qYXZhc2NyaXB0PlxuICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgIC8vIGRlZmF1bHQsIHNvIHdlIGRvbnQgY2hlY2sgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIGZvciB0aGVtIGhlcmUuXG4gICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgIHBvaW50ZXJFdmVudHNTdXBwb3J0ZWQ6ICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3cgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgLy8gQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAmJiAoYnJvd3Nlci5lZGdlIHx8IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDExKVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///239\n");

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__api_getData__ = __webpack_require__(87);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_env__ = __webpack_require__(88);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vuex__ = __webpack_require__(89);\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tdata: function data() {\n\t\treturn {\n\t\t\tbaseImgPath: __WEBPACK_IMPORTED_MODULE_4__config_env__[\"a\" /* baseImgPath */]\n\t\t};\n\t},\n\tcreated: function created() {\n\t\tif (!this.adminInfo.id) {\n\t\t\tthis.getAdminData();\n\t\t}\n\t},\n\n\tcomputed: __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_vuex__[\"b\" /* mapState */])(['adminInfo'])),\n\tmethods: __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_vuex__[\"c\" /* mapActions */])(['getAdminData']), {\n\t\thandleCommand: function handleCommand(command) {\n\t\t\tvar _this = this;\n\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {\n\t\t\t\tvar res;\n\t\t\t\treturn __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tswitch (_context.prev = _context.next) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tif (!(command == 'home')) {\n\t\t\t\t\t\t\t\t\t_context.next = 4;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t_this.$router.push('/manage');\n\t\t\t\t\t\t\t\t_context.next = 9;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tif (!(command == 'signout')) {\n\t\t\t\t\t\t\t\t\t_context.next = 9;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t_context.next = 7;\n\t\t\t\t\t\t\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__api_getData__[\"b\" /* signout */])();\n\n\t\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\t\tres = _context.sent;\n\n\t\t\t\t\t\t\t\tif (res.status == 1) {\n\t\t\t\t\t\t\t\t\t_this.$message({\n\t\t\t\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t\t\t\t\tmessage: '退出成功'\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t_this.$router.push('/');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_this.$message({\n\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\tmessage: res.message\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcase 9:\n\t\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\t\treturn _context.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, _callee, _this);\n\t\t\t}))();\n\t\t}\n\t})\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2hlYWRUb3AudnVlP2M0ODIiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJfY29udGFpbmVyXCI+XG5cblx0XHQ8ZWwtYnJlYWRjcnVtYiBzZXBhcmF0b3I9XCIvXCI+XG5cdFx0XHQ8ZWwtYnJlYWRjcnVtYi1pdGVtIDp0bz1cInsgcGF0aDogJy9tYW5hZ2UnIH1cIj7pppbpobU8L2VsLWJyZWFkY3J1bWItaXRlbT5cblx0XHRcdDxlbC1icmVhZGNydW1iLWl0ZW0gdi1mb3I9XCIoaXRlbSwgaW5kZXgpIGluICRyb3V0ZS5tZXRhXCIgOmtleT1cImluZGV4XCI+e3tpdGVtfX08L2VsLWJyZWFkY3J1bWItaXRlbT5cblx0XHQ8L2VsLWJyZWFkY3J1bWI+XG5cdFx0PGVsLWRyb3Bkb3duIEBjb21tYW5kPVwiaGFuZGxlQ29tbWFuZFwiIG1lbnUtYWxpZ249J3N0YXJ0Jz5cblx0XHRcdDxpbWcgOnNyYz1cImJhc2VJbWdQYXRoICsgYWRtaW5JbmZvLmF2YXRhclwiIGNsYXNzPVwiYXZhdG9yXCI+XG5cdFx0XHQ8ZWwtZHJvcGRvd24tbWVudSBzbG90PVwiZHJvcGRvd25cIj5cblx0XHRcdFx0PGVsLWRyb3Bkb3duLWl0ZW0gY29tbWFuZD1cImhvbWVcIj7pppbpobU8L2VsLWRyb3Bkb3duLWl0ZW0+XG5cdFx0XHRcdDxlbC1kcm9wZG93bi1pdGVtIGNvbW1hbmQ9XCJzaWdub3V0XCI+6YCA5Ye6PC9lbC1kcm9wZG93bi1pdGVtPlxuXHRcdFx0PC9lbC1kcm9wZG93bi1tZW51PlxuXHRcdDwvZWwtZHJvcGRvd24+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXHRpbXBvcnQge3NpZ25vdXR9IGZyb20gJ0AvYXBpL2dldERhdGEnXG5cdGltcG9ydCB7YmFzZUltZ1BhdGh9IGZyb20gJ0AvY29uZmlnL2Vudidcblx0aW1wb3J0IHttYXBBY3Rpb25zLCBtYXBTdGF0ZX0gZnJvbSAndnVleCdcblxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBcdGRhdGEoKXtcbiAgICBcdFx0cmV0dXJuIHtcbiAgICBcdFx0XHRiYXNlSW1nUGF0aCxcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdGNyZWF0ZWQoKXtcbiAgICBcdFx0aWYgKCF0aGlzLmFkbWluSW5mby5pZCkge1xuICAgIFx0XHRcdHRoaXMuZ2V0QWRtaW5EYXRhKClcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdGNvbXB1dGVkOiB7XG4gICAgXHRcdC4uLm1hcFN0YXRlKFsnYWRtaW5JbmZvJ10pLFxuICAgIFx0fSxcblx0XHRtZXRob2RzOiB7XG5cdFx0XHQuLi5tYXBBY3Rpb25zKFsnZ2V0QWRtaW5EYXRhJ10pLFxuXHRcdFx0YXN5bmMgaGFuZGxlQ29tbWFuZChjb21tYW5kKSB7XG5cdFx0XHRcdGlmIChjb21tYW5kID09ICdob21lJykge1xuXHRcdFx0XHRcdHRoaXMuJHJvdXRlci5wdXNoKCcvbWFuYWdlJyk7XG5cdFx0XHRcdH1lbHNlIGlmKGNvbW1hbmQgPT0gJ3NpZ25vdXQnKXtcblx0XHRcdFx0XHRjb25zdCByZXMgPSBhd2FpdCBzaWdub3V0KClcblx0XHRcdFx0XHRpZiAocmVzLnN0YXR1cyA9PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiRtZXNzYWdlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAn6YCA5Ye65oiQ5YqfJ1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKCcvJyk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHR0aGlzLiRtZXNzYWdlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzLm1lc3NhZ2Vcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vc3R5bGUvbWl4aW4nO1xuXHQuaGVhZGVyX2NvbnRhaW5lcntcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjRUZGMkY3O1xuXHRcdGhlaWdodDogNjBweDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdHBhZGRpbmctbGVmdDogMjBweDtcblx0fVxuXHQuYXZhdG9ye1xuXHRcdC53aCgzNnB4LCAzNnB4KTtcblx0XHRib3JkZXItcmFkaXVzOiA1MCU7XG5cdFx0bWFyZ2luLXJpZ2h0OiAzN3B4O1xuXHR9XG5cdC5lbC1kcm9wZG93bi1tZW51X19pdGVte1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBoZWFkVG9wLnZ1ZT85MGFkN2U1NiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBakJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0JBO0FBcEJBO0FBZEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///240\n");

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(243)\n\nvar Component = __webpack_require__(86)(\n  /* script */\n  __webpack_require__(240),\n  /* template */\n  __webpack_require__(242),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"D:\\\\Study\\\\project\\\\vueManageSys\\\\VuemanageSys\\\\vue2-manage-master\\\\src\\\\components\\\\headTop.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] headTop.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (true) {(function () {\n  var hotAPI = __webpack_require__(51)\n  hotAPI.install(__webpack_require__(1), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-b5680e22\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-b5680e22\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWU/ZWNmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3tcXFwibWluaW1pemVcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1iNTY4MGUyMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IWxlc3MtbG9hZGVyP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9oZWFkVG9wLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9oZWFkVG9wLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYjU2ODBlMjJcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaGVhZFRvcC52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkQ6XFxcXFN0dWR5XFxcXHByb2plY3RcXFxcdnVlTWFuYWdlU3lzXFxcXFZ1ZW1hbmFnZVN5c1xcXFx2dWUyLW1hbmFnZS1tYXN0ZXJcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcaGVhZFRvcC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBoZWFkVG9wLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1iNTY4MGUyMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWI1NjgwZTIyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL2hlYWRUb3AudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///241\n");

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"header_container\"\n  }, [_c('el-breadcrumb', {\n    attrs: {\n      \"separator\": \"/\"\n    }\n  }, [_c('el-breadcrumb-item', {\n    attrs: {\n      \"to\": {\n        path: '/manage'\n      }\n    }\n  }, [_vm._v(\"首页\")]), _vm._v(\" \"), _vm._l((_vm.$route.meta), function(item, index) {\n    return _c('el-breadcrumb-item', {\n      key: index\n    }, [_vm._v(_vm._s(item))])\n  })], 2), _vm._v(\" \"), _c('el-dropdown', {\n    attrs: {\n      \"menu-align\": \"start\"\n    },\n    on: {\n      \"command\": _vm.handleCommand\n    }\n  }, [_c('img', {\n    staticClass: \"avator\",\n    attrs: {\n      \"src\": _vm.baseImgPath + _vm.adminInfo.avatar\n    }\n  }), _vm._v(\" \"), _c('el-dropdown-menu', {\n    attrs: {\n      \"slot\": \"dropdown\"\n    },\n    slot: \"dropdown\"\n  }, [_c('el-dropdown-item', {\n    attrs: {\n      \"command\": \"home\"\n    }\n  }, [_vm._v(\"首页\")]), _vm._v(\" \"), _c('el-dropdown-item', {\n    attrs: {\n      \"command\": \"signout\"\n    }\n  }, [_vm._v(\"退出\")])], 1)], 1)], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (true) {\n  module.hot.accept()\n  if (module.hot.data) {\n     __webpack_require__(51).rerender(\"data-v-b5680e22\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWU/ZTNkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJoZWFkZXJfY29udGFpbmVyXCJcbiAgfSwgW19jKCdlbC1icmVhZGNydW1iJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInNlcGFyYXRvclwiOiBcIi9cIlxuICAgIH1cbiAgfSwgW19jKCdlbC1icmVhZGNydW1iLWl0ZW0nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidG9cIjoge1xuICAgICAgICBwYXRoOiAnL21hbmFnZSdcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCLpppbpobVcIildKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChfdm0uJHJvdXRlLm1ldGEpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfYygnZWwtYnJlYWRjcnVtYi1pdGVtJywge1xuICAgICAga2V5OiBpbmRleFxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKGl0ZW0pKV0pXG4gIH0pXSwgMiksIF92bS5fdihcIiBcIiksIF9jKCdlbC1kcm9wZG93bicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJtZW51LWFsaWduXCI6IFwic3RhcnRcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY29tbWFuZFwiOiBfdm0uaGFuZGxlQ29tbWFuZFxuICAgIH1cbiAgfSwgW19jKCdpbWcnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYXZhdG9yXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwic3JjXCI6IF92bS5iYXNlSW1nUGF0aCArIF92bS5hZG1pbkluZm8uYXZhdGFyXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2VsLWRyb3Bkb3duLW1lbnUnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwic2xvdFwiOiBcImRyb3Bkb3duXCJcbiAgICB9LFxuICAgIHNsb3Q6IFwiZHJvcGRvd25cIlxuICB9LCBbX2MoJ2VsLWRyb3Bkb3duLWl0ZW0nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiY29tbWFuZFwiOiBcImhvbWVcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIummlumhtVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZWwtZHJvcGRvd24taXRlbScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJjb21tYW5kXCI6IFwic2lnbm91dFwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwi6YCA5Ye6XCIpXSldLCAxKV0sIDEpXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtYjU2ODBlMjJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1iNTY4MGUyMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWVcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///242\n");

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(231);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(53)(\"422a2155\", content, false);\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(231, function() {\n     var newContent = __webpack_require__(231);\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWU/OThmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWI1NjgwZTIyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9oZWFkVG9wLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNDIyYTIxNTVcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWI1NjgwZTIyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9oZWFkVG9wLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XFxcIm1pbmltaXplXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYjU2ODBlMjJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1xcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2hlYWRUb3AudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj97XCJtaW5pbWl6ZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWI1NjgwZTIyXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1wic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvaGVhZFRvcC52dWVcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///243\n");

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(236);\n\nvar matrix = __webpack_require__(253);\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // 矩阵右乘\n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcz83NmY2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4vbWF0cml4XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuZnVuY3Rpb24gQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgdGhpcy54ID0geDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMueSA9IHk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn1cblxuQm91bmRpbmdSZWN0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICovXG4gIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICB2YXIgeSA9IG1hdGhNaW4ob3RoZXIueSwgdGhpcy55KTtcbiAgICB0aGlzLndpZHRoID0gbWF0aE1heChvdGhlci54ICsgb3RoZXIud2lkdGgsIHRoaXMueCArIHRoaXMud2lkdGgpIC0geDtcbiAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgob3RoZXIueSArIG90aGVyLmhlaWdodCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpIC0geTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICogQG1ldGhvZHNcbiAgICovXG4gIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGx0ID0gW107XG4gICAgdmFyIHJiID0gW107XG4gICAgdmFyIGxiID0gW107XG4gICAgdmFyIHJ0ID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgLy8gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKVxuICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbHRbMF0gPSBsYlswXSA9IHRoaXMueDtcbiAgICAgIGx0WzFdID0gcnRbMV0gPSB0aGlzLnk7XG4gICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgIHJiWzFdID0gbGJbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obHQsIGx0LCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocmIsIHJiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocnQsIHJ0LCBtKTtcbiAgICAgIHRoaXMueCA9IG1hdGhNaW4obHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdGhpcy55ID0gbWF0aE1pbihsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHRoaXMud2lkdGggPSBtYXhYIC0gdGhpcy54O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgIH07XG4gIH0oKSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgc3ggPSBiLndpZHRoIC8gYS53aWR0aDtcbiAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuICAgIHZhciBtID0gbWF0cml4LmNyZWF0ZSgpOyAvLyDnn6npmLXlj7PkuZhcblxuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW2IueCwgYi55XSk7XG4gICAgcmV0dXJuIG07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAoIWIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIShiIGluc3RhbmNlb2YgQm91bmRpbmdSZWN0KSkge1xuICAgICAgLy8gTm9ybWFsaXplIG5lZ2F0aXZlIHdpZHRoL2hlaWdodC5cbiAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgIH1cblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYXgwID0gYS54O1xuICAgIHZhciBheDEgPSBhLnggKyBhLndpZHRoO1xuICAgIHZhciBheTAgPSBhLnk7XG4gICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuICAgIHZhciBieDAgPSBiLng7XG4gICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgdmFyIGJ5MCA9IGIueTtcbiAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG4gICAgcmV0dXJuICEoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgfSxcbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgcmV0dXJuIHggPj0gcmVjdC54ICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiB5ID49IHJlY3QueSAmJiB5IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdGhpcy54ID0gb3RoZXIueDtcbiAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgfSxcbiAgcGxhaW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R8bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnlcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LndpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cbkJvdW5kaW5nUmVjdC5jcmVhdGUgPSBmdW5jdGlvbiAocmVjdCkge1xuICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gQm91bmRpbmdSZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///244\n");

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar textContain = __webpack_require__(250);\n\nvar numberUtil = __webpack_require__(235);\n\n/**\n * 每三位默认加,格式化\n * @param {string|number} x\n * @return {string}\n */\nfunction addCommas(x) {\n  if (isNaN(x)) {\n    return '-';\n  }\n\n  x = (x + '').split('.');\n  return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n}\n/**\n * @param {string} str\n * @param {boolean} [upperCaseFirst=false]\n * @return {string} str\n */\n\n\nfunction toCamelCase(str, upperCaseFirst) {\n  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\n    return group1.toUpperCase();\n  });\n\n  if (upperCaseFirst && str) {\n    str = str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  return str;\n}\n\nvar normalizeCssArray = zrUtil.normalizeCssArray;\n\nfunction encodeHTML(source) {\n  return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n\nvar TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\nvar wrapVar = function (varName, seriesIdx) {\n  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n};\n/**\n * Template formatter\n * @param {string} tpl\n * @param {Array.<Object>|Object} paramsList\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTpl(tpl, paramsList, encode) {\n  if (!zrUtil.isArray(paramsList)) {\n    paramsList = [paramsList];\n  }\n\n  var seriesLen = paramsList.length;\n\n  if (!seriesLen) {\n    return '';\n  }\n\n  var $vars = paramsList[0].$vars || [];\n\n  for (var i = 0; i < $vars.length; i++) {\n    var alias = TPL_VAR_ALIAS[i];\n    var val = wrapVar(alias, 0);\n    tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n  }\n\n  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n    for (var k = 0; k < $vars.length; k++) {\n      var val = paramsList[seriesIdx][$vars[k]];\n      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);\n    }\n  }\n\n  return tpl;\n}\n/**\n * simple Template formatter\n *\n * @param {string} tpl\n * @param {Object} param\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTplSimple(tpl, param, encode) {\n  zrUtil.each(param, function (value, key) {\n    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);\n  });\n  return tpl;\n}\n/**\n * @param {string} color\n * @param {string} [extraCssText]\n * @return {string}\n */\n\n\nfunction getTooltipMarker(color, extraCssText) {\n  return color ? '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>' : '';\n}\n/**\n * @param {string} str\n * @return {string}\n * @inner\n */\n\n\nvar s2d = function (str) {\n  return str < 10 ? '0' + str : str;\n};\n/**\n * ISO Date format\n * @param {string} tpl\n * @param {number} value\n * @param {boolean} [isUTC=false] Default in local time.\n *           see `module:echarts/scale/Time`\n *           and `module:echarts/util/number#parseDate`.\n * @inner\n */\n\n\nfunction formatTime(tpl, value, isUTC) {\n  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n    tpl = 'MM-dd\\nyyyy';\n  }\n\n  var date = numberUtil.parseDate(value);\n  var utc = isUTC ? 'UTC' : '';\n  var y = date['get' + utc + 'FullYear']();\n  var M = date['get' + utc + 'Month']() + 1;\n  var d = date['get' + utc + 'Date']();\n  var h = date['get' + utc + 'Hours']();\n  var m = date['get' + utc + 'Minutes']();\n  var s = date['get' + utc + 'Seconds']();\n  tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n  return tpl;\n}\n/**\n * Capital first\n * @param {string} str\n * @return {string}\n */\n\n\nfunction capitalFirst(str) {\n  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n}\n\nvar truncateText = textContain.truncateText;\nvar getTextRect = textContain.getBoundingRect;\nexports.addCommas = addCommas;\nexports.toCamelCase = toCamelCase;\nexports.normalizeCssArray = normalizeCssArray;\nexports.encodeHTML = encodeHTML;\nexports.formatTpl = formatTpl;\nexports.formatTplSimple = formatTplSimple;\nexports.getTooltipMarker = getTooltipMarker;\nexports.formatTime = formatTime;\nexports.capitalFirst = capitalFirst;\nexports.truncateText = truncateText;\nexports.getTextRect = getTextRect;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL2Zvcm1hdC5qcz83ZjcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi90ZXh0XCIpO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxuLyoqXG4gKiDmr4/kuInkvY3pu5jorqTliqAs5qC85byP5YyWXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHhcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYWRkQ29tbWFzKHgpIHtcbiAgaWYgKGlzTmFOKHgpKSB7XG4gICAgcmV0dXJuICctJztcbiAgfVxuXG4gIHggPSAoeCArICcnKS5zcGxpdCgnLicpO1xuICByZXR1cm4geFswXS5yZXBsYWNlKC8oXFxkezEsM30pKD89KD86XFxkezN9KSsoPyFcXGQpKS9nLCAnJDEsJykgKyAoeC5sZW5ndGggPiAxID8gJy4nICsgeFsxXSA6ICcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBbdXBwZXJDYXNlRmlyc3Q9ZmFsc2VdXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICovXG5cblxuZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyLCB1cHBlckNhc2VGaXJzdCkge1xuICBzdHIgPSAoc3RyIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cDEpIHtcbiAgICByZXR1cm4gZ3JvdXAxLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xuXG4gIGlmICh1cHBlckNhc2VGaXJzdCAmJiBzdHIpIHtcbiAgICBzdHIgPSBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG52YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSB6clV0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUwoc291cmNlKSB7XG4gIHJldHVybiBTdHJpbmcoc291cmNlKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbnZhciBUUExfVkFSX0FMSUFTID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJ107XG5cbnZhciB3cmFwVmFyID0gZnVuY3Rpb24gKHZhck5hbWUsIHNlcmllc0lkeCkge1xuICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9Jztcbn07XG4vKipcbiAqIFRlbXBsYXRlIGZvcm1hdHRlclxuICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFRwbCh0cGwsIHBhcmFtc0xpc3QsIGVuY29kZSkge1xuICBpZiAoIXpyVXRpbC5pc0FycmF5KHBhcmFtc0xpc3QpKSB7XG4gICAgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgfVxuXG4gIHZhciBzZXJpZXNMZW4gPSBwYXJhbXNMaXN0Lmxlbmd0aDtcblxuICBpZiAoIXNlcmllc0xlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciAkdmFycyA9IHBhcmFtc0xpc3RbMF0uJHZhcnMgfHwgW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbGlhcyA9IFRQTF9WQVJfQUxJQVNbaV07XG4gICAgdmFyIHZhbCA9IHdyYXBWYXIoYWxpYXMsIDApO1xuICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICB9XG5cbiAgZm9yICh2YXIgc2VyaWVzSWR4ID0gMDsgc2VyaWVzSWR4IDwgc2VyaWVzTGVuOyBzZXJpZXNJZHgrKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB2YWwgPSBwYXJhbXNMaXN0W3Nlcmllc0lkeF1bJHZhcnNba11dO1xuICAgICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cGw7XG59XG4vKipcbiAqIHNpbXBsZSBUZW1wbGF0ZSBmb3JtYXR0ZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFRwbFNpbXBsZSh0cGwsIHBhcmFtLCBlbmNvZGUpIHtcbiAgenJVdGlsLmVhY2gocGFyYW0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdHBsID0gdHBsLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbHVlKSA6IHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB0cGw7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IFtleHRyYUNzc1RleHRdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUb29sdGlwTWFya2VyKGNvbG9yLCBleHRyYUNzc1RleHQpIHtcbiAgcmV0dXJuIGNvbG9yID8gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXJpZ2h0OjVweDsnICsgJ2JvcmRlci1yYWRpdXM6MTBweDt3aWR0aDo5cHg7aGVpZ2h0OjlweDtiYWNrZ3JvdW5kLWNvbG9yOicgKyBlbmNvZGVIVE1MKGNvbG9yKSArICc7JyArIChleHRyYUNzc1RleHQgfHwgJycpICsgJ1wiPjwvc3Bhbj4nIDogJyc7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBpbm5lclxuICovXG5cblxudmFyIHMyZCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ciA8IDEwID8gJzAnICsgc3RyIDogc3RyO1xufTtcbi8qKlxuICogSVNPIERhdGUgZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVVRDPWZhbHNlXSBEZWZhdWx0IGluIGxvY2FsIHRpbWUuXG4gKiAgICAgICAgICAgc2VlIGBtb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lYFxuICogICAgICAgICAgIGFuZCBgbW9kdWxlOmVjaGFydHMvdXRpbC9udW1iZXIjcGFyc2VEYXRlYC5cbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0VGltZSh0cGwsIHZhbHVlLCBpc1VUQykge1xuICBpZiAodHBsID09PSAnd2VlaycgfHwgdHBsID09PSAnbW9udGgnIHx8IHRwbCA9PT0gJ3F1YXJ0ZXInIHx8IHRwbCA9PT0gJ2hhbGYteWVhcicgfHwgdHBsID09PSAneWVhcicpIHtcbiAgICB0cGwgPSAnTU0tZGRcXG55eXl5JztcbiAgfVxuXG4gIHZhciBkYXRlID0gbnVtYmVyVXRpbC5wYXJzZURhdGUodmFsdWUpO1xuICB2YXIgdXRjID0gaXNVVEMgPyAnVVRDJyA6ICcnO1xuICB2YXIgeSA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnRnVsbFllYXInXSgpO1xuICB2YXIgTSA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnTW9udGgnXSgpICsgMTtcbiAgdmFyIGQgPSBkYXRlWydnZXQnICsgdXRjICsgJ0RhdGUnXSgpO1xuICB2YXIgaCA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnSG91cnMnXSgpO1xuICB2YXIgbSA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnTWludXRlcyddKCk7XG4gIHZhciBzID0gZGF0ZVsnZ2V0JyArIHV0YyArICdTZWNvbmRzJ10oKTtcbiAgdHBsID0gdHBsLnJlcGxhY2UoJ01NJywgczJkKE0pKS5yZXBsYWNlKCdNJywgTSkucmVwbGFjZSgneXl5eScsIHkpLnJlcGxhY2UoJ3l5JywgeSAlIDEwMCkucmVwbGFjZSgnZGQnLCBzMmQoZCkpLnJlcGxhY2UoJ2QnLCBkKS5yZXBsYWNlKCdoaCcsIHMyZChoKSkucmVwbGFjZSgnaCcsIGgpLnJlcGxhY2UoJ21tJywgczJkKG0pKS5yZXBsYWNlKCdtJywgbSkucmVwbGFjZSgnc3MnLCBzMmQocykpLnJlcGxhY2UoJ3MnLCBzKTtcbiAgcmV0dXJuIHRwbDtcbn1cbi8qKlxuICogQ2FwaXRhbCBmaXJzdFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gY2FwaXRhbEZpcnN0KHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSA6IHN0cjtcbn1cblxudmFyIHRydW5jYXRlVGV4dCA9IHRleHRDb250YWluLnRydW5jYXRlVGV4dDtcbnZhciBnZXRUZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdDtcbmV4cG9ydHMuYWRkQ29tbWFzID0gYWRkQ29tbWFzO1xuZXhwb3J0cy50b0NhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlO1xuZXhwb3J0cy5ub3JtYWxpemVDc3NBcnJheSA9IG5vcm1hbGl6ZUNzc0FycmF5O1xuZXhwb3J0cy5lbmNvZGVIVE1MID0gZW5jb2RlSFRNTDtcbmV4cG9ydHMuZm9ybWF0VHBsID0gZm9ybWF0VHBsO1xuZXhwb3J0cy5mb3JtYXRUcGxTaW1wbGUgPSBmb3JtYXRUcGxTaW1wbGU7XG5leHBvcnRzLmdldFRvb2x0aXBNYXJrZXIgPSBnZXRUb29sdGlwTWFya2VyO1xuZXhwb3J0cy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcbmV4cG9ydHMuY2FwaXRhbEZpcnN0ID0gY2FwaXRhbEZpcnN0O1xuZXhwb3J0cy50cnVuY2F0ZVRleHQgPSB0cnVuY2F0ZVRleHQ7XG5leHBvcnRzLmdldFRleHRSZWN0ID0gZ2V0VGV4dFJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvZm9ybWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///245\n");

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar env = __webpack_require__(239);\n\nvar clazzUtil = __webpack_require__(247);\n\nvar lineStyleMixin = __webpack_require__(346);\n\nvar areaStyleMixin = __webpack_require__(343);\n\nvar textStyleMixin = __webpack_require__(347);\n\nvar itemStyleMixin = __webpack_require__(345);\n\n/**\n * @module echarts/model/Model\n */\nvar mixin = zrUtil.mixin;\n/**\n * @alias module:echarts/model/Model\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} [parentModel]\n * @param {module:echarts/model/Global} [ecModel]\n */\n\nfunction Model(option, parentModel, ecModel) {\n  /**\n   * @type {module:echarts/model/Model}\n   * @readOnly\n   */\n  this.parentModel = parentModel;\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @type {Object}\n   * @protected\n   */\n\n  this.option = option; // Simple optimization\n  // if (this.init) {\n  //     if (arguments.length <= 4) {\n  //         this.init(option, parentModel, ecModel, extraOpt);\n  //     }\n  //     else {\n  //         this.init.apply(this, arguments);\n  //     }\n  // }\n}\n\nModel.prototype = {\n  constructor: Model,\n\n  /**\n   * Model 的初始化函数\n   * @param {Object} option\n   */\n  init: null,\n\n  /**\n   * 从新的 Option merge\n   */\n  mergeOption: function (option) {\n    zrUtil.merge(this.option, option, true);\n  },\n\n  /**\n   * @param {string|Array.<string>} path\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  get: function (path, ignoreParent) {\n    if (path == null) {\n      return this.option;\n    }\n\n    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));\n  },\n\n  /**\n   * @param {string} key\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  getShallow: function (key, ignoreParent) {\n    var option = this.option;\n    var val = option == null ? option : option[key];\n    var parentModel = !ignoreParent && getParent(this, key);\n\n    if (val == null && parentModel) {\n      val = parentModel.getShallow(key);\n    }\n\n    return val;\n  },\n\n  /**\n   * @param {string|Array.<string>} [path]\n   * @param {module:echarts/model/Model} [parentModel]\n   * @return {module:echarts/model/Model}\n   */\n  getModel: function (path, parentModel) {\n    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));\n    var thisParentModel;\n    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);\n    return new Model(obj, parentModel, this.ecModel);\n  },\n\n  /**\n   * If model has option\n   */\n  isEmpty: function () {\n    return this.option == null;\n  },\n  restoreData: function () {},\n  // Pending\n  clone: function () {\n    var Ctor = this.constructor;\n    return new Ctor(zrUtil.clone(this.option));\n  },\n  setReadOnly: function (properties) {\n    clazzUtil.setReadOnly(this, properties);\n  },\n  // If path is null/undefined, return null/undefined.\n  parsePath: function (path) {\n    if (typeof path === 'string') {\n      path = path.split('.');\n    }\n\n    return path;\n  },\n\n  /**\n   * @param {Function} getParentMethod\n   *        param {Array.<string>|string} path\n   *        return {module:echarts/model/Model}\n   */\n  customizeGetParent: function (getParentMethod) {\n    clazzUtil.set(this, 'getParent', getParentMethod);\n  },\n  isAnimationEnabled: function () {\n    if (!env.node) {\n      if (this.option.animation != null) {\n        return !!this.option.animation;\n      } else if (this.parentModel) {\n        return this.parentModel.isAnimationEnabled();\n      }\n    }\n  }\n};\n\nfunction doGet(obj, pathArr, parentModel) {\n  for (var i = 0; i < pathArr.length; i++) {\n    // Ignore empty\n    if (!pathArr[i]) {\n      continue;\n    } // obj could be number/string/... (like 0)\n\n\n    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  if (obj == null && parentModel) {\n    obj = parentModel.get(pathArr);\n  }\n\n  return obj;\n} // `path` can be null/undefined\n\n\nfunction getParent(model, path) {\n  var getParentMethod = clazzUtil.get(model, 'getParent');\n  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n} // Enable Model.extend.\n\n\nclazzUtil.enableClassExtend(Model);\nmixin(Model, lineStyleMixin);\nmixin(Model, areaStyleMixin);\nmixin(Model, textStyleMixin);\nmixin(Model, itemStyleMixin);\nvar _default = Model;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9Nb2RlbC5qcz9mNGRmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvZW52XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBsaW5lU3R5bGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2xpbmVTdHlsZVwiKTtcblxudmFyIGFyZWFTdHlsZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vYXJlYVN0eWxlXCIpO1xuXG52YXIgdGV4dFN0eWxlTWl4aW4gPSByZXF1aXJlKFwiLi9taXhpbi90ZXh0U3R5bGVcIik7XG5cbnZhciBpdGVtU3R5bGVNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2l0ZW1TdHlsZVwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvTW9kZWxcbiAqL1xudmFyIG1peGluID0genJVdGlsLm1peGluO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IFtlY01vZGVsXVxuICovXG5cbmZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLnBhcmVudE1vZGVsID0gcGFyZW50TW9kZWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5vcHRpb24gPSBvcHRpb247IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgLy8gaWYgKHRoaXMuaW5pdCkge1xuICAvLyAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gNCkge1xuICAvLyAgICAgICAgIHRoaXMuaW5pdChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG4gIC8vICAgICB9XG4gIC8vICAgICBlbHNlIHtcbiAgLy8gICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgLy8gICAgIH1cbiAgLy8gfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNb2RlbCxcblxuICAvKipcbiAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICovXG4gIGluaXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIOS7juaWsOeahCBPcHRpb24gbWVyZ2VcbiAgICovXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvR2V0KHRoaXMub3B0aW9uLCB0aGlzLnBhcnNlUGF0aChwYXRoKSwgIWlnbm9yZVBhcmVudCAmJiBnZXRQYXJlbnQodGhpcywgcGF0aCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVBhcmVudD1mYWxzZV1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGdldFNoYWxsb3c6IGZ1bmN0aW9uIChrZXksIGlnbm9yZVBhcmVudCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgdmFsID0gb3B0aW9uID09IG51bGwgPyBvcHRpb24gOiBvcHRpb25ba2V5XTtcbiAgICB2YXIgcGFyZW50TW9kZWwgPSAhaWdub3JlUGFyZW50ICYmIGdldFBhcmVudCh0aGlzLCBrZXkpO1xuXG4gICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtwYXRoXVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xuICAgIHZhciBvYmogPSBwYXRoID09IG51bGwgPyB0aGlzLm9wdGlvbiA6IGRvR2V0KHRoaXMub3B0aW9uLCBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCkpO1xuICAgIHZhciB0aGlzUGFyZW50TW9kZWw7XG4gICAgcGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbCB8fCAodGhpc1BhcmVudE1vZGVsID0gZ2V0UGFyZW50KHRoaXMsIHBhdGgpKSAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aCk7XG4gICAgcmV0dXJuIG5ldyBNb2RlbChvYmosIHBhcmVudE1vZGVsLCB0aGlzLmVjTW9kZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBtb2RlbCBoYXMgb3B0aW9uXG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uID09IG51bGw7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcbiAgLy8gUGVuZGluZ1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBDdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XG4gIH0sXG4gIHNldFJlYWRPbmx5OiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgIGNsYXp6VXRpbC5zZXRSZWFkT25seSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfSxcbiAgLy8gSWYgcGF0aCBpcyBudWxsL3VuZGVmaW5lZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICBwYXJzZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0UGFyZW50TWV0aG9kXG4gICAqICAgICAgICBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBwYXRoXG4gICAqICAgICAgICByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgY3VzdG9taXplR2V0UGFyZW50OiBmdW5jdGlvbiAoZ2V0UGFyZW50TWV0aG9kKSB7XG4gICAgY2xhenpVdGlsLnNldCh0aGlzLCAnZ2V0UGFyZW50JywgZ2V0UGFyZW50TWV0aG9kKTtcbiAgfSxcbiAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlbnYubm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9uLmFuaW1hdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9uLmFuaW1hdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvR2V0KG9iaiwgcGF0aEFyciwgcGFyZW50TW9kZWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gSWdub3JlIGVtcHR5XG4gICAgaWYgKCFwYXRoQXJyW2ldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIG9iaiBjb3VsZCBiZSBudW1iZXIvc3RyaW5nLy4uLiAobGlrZSAwKVxuXG5cbiAgICBvYmogPSBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgPyBvYmpbcGF0aEFycltpXV0gOiBudWxsO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwpIHtcbiAgICBvYmogPSBwYXJlbnRNb2RlbC5nZXQocGF0aEFycik7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSAvLyBgcGF0aGAgY2FuIGJlIG51bGwvdW5kZWZpbmVkXG5cblxuZnVuY3Rpb24gZ2V0UGFyZW50KG1vZGVsLCBwYXRoKSB7XG4gIHZhciBnZXRQYXJlbnRNZXRob2QgPSBjbGF6elV0aWwuZ2V0KG1vZGVsLCAnZ2V0UGFyZW50Jyk7XG4gIHJldHVybiBnZXRQYXJlbnRNZXRob2QgPyBnZXRQYXJlbnRNZXRob2QuY2FsbChtb2RlbCwgcGF0aCkgOiBtb2RlbC5wYXJlbnRNb2RlbDtcbn0gLy8gRW5hYmxlIE1vZGVsLmV4dGVuZC5cblxuXG5jbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoTW9kZWwpO1xubWl4aW4oTW9kZWwsIGxpbmVTdHlsZU1peGluKTtcbm1peGluKE1vZGVsLCBhcmVhU3R5bGVNaXhpbik7XG5taXhpbihNb2RlbCwgdGV4dFN0eWxlTWl4aW4pO1xubWl4aW4oTW9kZWwsIGl0ZW1TdHlsZU1peGluKTtcbnZhciBfZGVmYXVsdCA9IE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///246\n");

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar TYPE_DELIMITER = '.';\nvar IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\nvar MEMBER_PRIFIX = '\\0ec_\\0';\n/**\n * Hide private class member.\n * The same behavior as `host[name] = value;` (can be right-value)\n * @public\n */\n\nfunction set(host, name, value) {\n  return host[MEMBER_PRIFIX + name] = value;\n}\n/**\n * Hide private class member.\n * The same behavior as `host[name];`\n * @public\n */\n\n\nfunction get(host, name) {\n  return host[MEMBER_PRIFIX + name];\n}\n/**\n * For hidden private class member.\n * The same behavior as `host.hasOwnProperty(name);`\n * @public\n */\n\n\nfunction hasOwn(host, name) {\n  return host.hasOwnProperty(MEMBER_PRIFIX + name);\n}\n/**\n * Notice, parseClassType('') should returns {main: '', sub: ''}\n * @public\n */\n\n\nfunction parseClassType(componentType) {\n  var ret = {\n    main: '',\n    sub: ''\n  };\n\n  if (componentType) {\n    componentType = componentType.split(TYPE_DELIMITER);\n    ret.main = componentType[0] || '';\n    ret.sub = componentType[1] || '';\n  }\n\n  return ret;\n}\n/**\n * @public\n */\n\n\nfunction checkClassType(componentType) {\n  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType \"' + componentType + '\" illegal');\n}\n/**\n * @public\n */\n\n\nfunction enableClassExtend(RootClass, mandatoryMethods) {\n  RootClass.$constructor = RootClass;\n\n  RootClass.extend = function (proto) {\n    var superClass = this;\n\n    var ExtendedClass = function () {\n      if (!proto.$constructor) {\n        superClass.apply(this, arguments);\n      } else {\n        proto.$constructor.apply(this, arguments);\n      }\n    };\n\n    zrUtil.extend(ExtendedClass.prototype, proto);\n    ExtendedClass.extend = this.extend;\n    ExtendedClass.superCall = superCall;\n    ExtendedClass.superApply = superApply;\n    zrUtil.inherits(ExtendedClass, this);\n    ExtendedClass.superClass = superClass;\n    return ExtendedClass;\n  };\n} // superCall should have class info, which can not be fetch from 'this'.\n// Consider this case:\n// class A has method f,\n// class B inherits class A, overrides method f, f call superApply('f'),\n// class C inherits class B, do not overrides method f,\n// then when method of class C is called, dead loop occured.\n\n\nfunction superCall(context, methodName) {\n  var args = zrUtil.slice(arguments, 2);\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n\nfunction superApply(context, methodName, args) {\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n/**\n * @param {Object} entity\n * @param {Object} options\n * @param {boolean} [options.registerWhenExtend]\n * @public\n */\n\n\nfunction enableClassManagement(entity, options) {\n  options = options || {};\n  /**\n   * Component model classes\n   * key: componentType,\n   * value:\n   *     componentClass, when componentType is 'xxx'\n   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n   * @type {Object}\n   */\n\n  var storage = {};\n\n  entity.registerClass = function (Clazz, componentType) {\n    if (componentType) {\n      checkClassType(componentType);\n      componentType = parseClassType(componentType);\n\n      if (!componentType.sub) {\n        storage[componentType.main] = Clazz;\n      } else if (componentType.sub !== IS_CONTAINER) {\n        var container = makeContainer(componentType);\n        container[componentType.sub] = Clazz;\n      }\n    }\n\n    return Clazz;\n  };\n\n  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n    var Clazz = storage[componentMainType];\n\n    if (Clazz && Clazz[IS_CONTAINER]) {\n      Clazz = subType ? Clazz[subType] : null;\n    }\n\n    if (throwWhenNotFound && !Clazz) {\n      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');\n    }\n\n    return Clazz;\n  };\n\n  entity.getClassesByMainType = function (componentType) {\n    componentType = parseClassType(componentType);\n    var result = [];\n    var obj = storage[componentType.main];\n\n    if (obj && obj[IS_CONTAINER]) {\n      zrUtil.each(obj, function (o, type) {\n        type !== IS_CONTAINER && result.push(o);\n      });\n    } else {\n      result.push(obj);\n    }\n\n    return result;\n  };\n\n  entity.hasClass = function (componentType) {\n    // Just consider componentType.main.\n    componentType = parseClassType(componentType);\n    return !!storage[componentType.main];\n  };\n  /**\n   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n   */\n\n\n  entity.getAllClassMainTypes = function () {\n    var types = [];\n    zrUtil.each(storage, function (obj, type) {\n      types.push(type);\n    });\n    return types;\n  };\n  /**\n   * If a main type is container and has sub types\n   * @param  {string}  mainType\n   * @return {boolean}\n   */\n\n\n  entity.hasSubTypes = function (componentType) {\n    componentType = parseClassType(componentType);\n    var obj = storage[componentType.main];\n    return obj && obj[IS_CONTAINER];\n  };\n\n  entity.parseClassType = parseClassType;\n\n  function makeContainer(componentType) {\n    var container = storage[componentType.main];\n\n    if (!container || !container[IS_CONTAINER]) {\n      container = storage[componentType.main] = {};\n      container[IS_CONTAINER] = true;\n    }\n\n    return container;\n  }\n\n  if (options.registerWhenExtend) {\n    var originalExtend = entity.extend;\n\n    if (originalExtend) {\n      entity.extend = function (proto) {\n        var ExtendedClass = originalExtend.call(this, proto);\n        return entity.registerClass(ExtendedClass, proto.type);\n      };\n    }\n  }\n\n  return entity;\n}\n/**\n * @param {string|Array.<string>} properties\n */\n\n\nfunction setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11\n  // if (!zrUtil.isArray(properties)) {\n  //     properties = properties != null ? [properties] : [];\n  // }\n  // zrUtil.each(properties, function (prop) {\n  //     var value = obj[prop];\n  //     Object.defineProperty\n  //         && Object.defineProperty(obj, prop, {\n  //             value: value, writable: false\n  //         });\n  //     zrUtil.isArray(obj[prop])\n  //         && Object.freeze\n  //         && Object.freeze(obj[prop]);\n  // });\n}\n\nexports.set = set;\nexports.get = get;\nexports.hasOwn = hasOwn;\nexports.parseClassType = parseClassType;\nexports.enableClassExtend = enableClassExtend;\nexports.enableClassManagement = enableClassManagement;\nexports.setReadOnly = setReadOnly;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL2NsYXp6LmpzPzNlNjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBUWVBFX0RFTElNSVRFUiA9ICcuJztcbnZhciBJU19DT05UQUlORVIgPSAnX19fRUNfX0NPTVBPTkVOVF9fQ09OVEFJTkVSX19fJztcbnZhciBNRU1CRVJfUFJJRklYID0gJ1xcMGVjX1xcMCc7XG4vKipcbiAqIEhpZGUgcHJpdmF0ZSBjbGFzcyBtZW1iZXIuXG4gKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXSA9IHZhbHVlO2AgKGNhbiBiZSByaWdodC12YWx1ZSlcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzZXQoaG9zdCwgbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGhvc3RbTUVNQkVSX1BSSUZJWCArIG5hbWVdID0gdmFsdWU7XG59XG4vKipcbiAqIEhpZGUgcHJpdmF0ZSBjbGFzcyBtZW1iZXIuXG4gKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXTtgXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoaG9zdCwgbmFtZSkge1xuICByZXR1cm4gaG9zdFtNRU1CRVJfUFJJRklYICsgbmFtZV07XG59XG4vKipcbiAqIEZvciBoaWRkZW4gcHJpdmF0ZSBjbGFzcyBtZW1iZXIuXG4gKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtgXG4gKiBAcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBoYXNPd24oaG9zdCwgbmFtZSkge1xuICByZXR1cm4gaG9zdC5oYXNPd25Qcm9wZXJ0eShNRU1CRVJfUFJJRklYICsgbmFtZSk7XG59XG4vKipcbiAqIE5vdGljZSwgcGFyc2VDbGFzc1R5cGUoJycpIHNob3VsZCByZXR1cm5zIHttYWluOiAnJywgc3ViOiAnJ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgdmFyIHJldCA9IHtcbiAgICBtYWluOiAnJyxcbiAgICBzdWI6ICcnXG4gIH07XG5cbiAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XG4gICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xuICAgIHJldC5zdWIgPSBjb21wb25lbnRUeXBlWzFdIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gY2hlY2tDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkge1xuICB6clV0aWwuYXNzZXJ0KC9eW2EtekEtWjAtOV9dKyhbLl1bYS16QS1aMC05X10rKT8kLy50ZXN0KGNvbXBvbmVudFR5cGUpLCAnY29tcG9uZW50VHlwZSBcIicgKyBjb21wb25lbnRUeXBlICsgJ1wiIGlsbGVnYWwnKTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZW5hYmxlQ2xhc3NFeHRlbmQoUm9vdENsYXNzLCBtYW5kYXRvcnlNZXRob2RzKSB7XG4gIFJvb3RDbGFzcy4kY29uc3RydWN0b3IgPSBSb290Q2xhc3M7XG5cbiAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgIHZhciBzdXBlckNsYXNzID0gdGhpcztcblxuICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFwcm90by4kY29uc3RydWN0b3IpIHtcbiAgICAgICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG8uJGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcbiAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XG4gICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xuICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XG4gIH07XG59IC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxuLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXG4vLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcbi8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG8gbm90IG92ZXJyaWRlcyBtZXRob2QgZixcbi8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxuXG5cbmZ1bmN0aW9uIHN1cGVyQ2FsbChjb250ZXh0LCBtZXRob2ROYW1lKSB7XG4gIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzdXBlckFwcGx5KGNvbnRleHQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZF1cbiAqIEBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZUNsYXNzTWFuYWdlbWVudChlbnRpdHksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIC8qKlxuICAgKiBDb21wb25lbnQgbW9kZWwgY2xhc3Nlc1xuICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXG4gICAqIHZhbHVlOlxuICAgKiAgICAgY29tcG9uZW50Q2xhc3MsIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4J1xuICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHZhciBzdG9yYWdlID0ge307XG5cbiAgZW50aXR5LnJlZ2lzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhenosIGNvbXBvbmVudFR5cGUpIHtcbiAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgY2hlY2tDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcbiAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudFR5cGUuc3ViICE9PSBJU19DT05UQUlORVIpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XG4gICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ2xheno7XG4gIH07XG5cbiAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudE1haW5UeXBlLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xuICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50TWFpblR5cGVdO1xuXG4gICAgaWYgKENsYXp6ICYmIENsYXp6W0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQgJiYgIUNsYXp6KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIXN1YlR5cGUgPyBjb21wb25lbnRNYWluVHlwZSArICcuJyArICd0eXBlIHNob3VsZCBiZSBzcGVjaWZpZWQuJyA6ICdDb21wb25lbnQgJyArIGNvbXBvbmVudE1haW5UeXBlICsgJy4nICsgKHN1YlR5cGUgfHwgJycpICsgJyBub3QgZXhpc3RzLiBMb2FkIGl0IGZpcnN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBDbGF6ejtcbiAgfTtcblxuICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcblxuICAgIGlmIChvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgIHpyVXRpbC5lYWNoKG9iaiwgZnVuY3Rpb24gKG8sIHR5cGUpIHtcbiAgICAgICAgdHlwZSAhPT0gSVNfQ09OVEFJTkVSICYmIHJlc3VsdC5wdXNoKG8pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBlbnRpdHkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxuICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICByZXR1cm4gISFzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG4gIH07XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxuICAgKi9cblxuXG4gIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gICAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbiAgfTtcbiAgLyoqXG4gICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBtYWluVHlwZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG4gICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcbiAgfTtcblxuICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcblxuICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XG4gICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcbiAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XG4gICAgdmFyIG9yaWdpbmFsRXh0ZW5kID0gZW50aXR5LmV4dGVuZDtcblxuICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xuICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gZW50aXR5LnJlZ2lzdGVyQ2xhc3MoRXh0ZW5kZWRDbGFzcywgcHJvdG8udHlwZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbnRpdHk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwcm9wZXJ0aWVzXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRSZWFkT25seShvYmosIHByb3BlcnRpZXMpIHsvLyBGSVhNRSBJdCBzZWVtcyBicm9rZW4gaW4gSUU4IHNpbXVsYXRpb24gb2YgSUUxMVxuICAvLyBpZiAoIXpyVXRpbC5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gIC8vICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPSBudWxsID8gW3Byb3BlcnRpZXNdIDogW107XG4gIC8vIH1cbiAgLy8genJVdGlsLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgLy8gICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAvLyAgICAgICAgICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgLy8gICAgICAgICAgICAgdmFsdWU6IHZhbHVlLCB3cml0YWJsZTogZmFsc2VcbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgIHpyVXRpbC5pc0FycmF5KG9ialtwcm9wXSlcbiAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplXG4gIC8vICAgICAgICAgJiYgT2JqZWN0LmZyZWV6ZShvYmpbcHJvcF0pO1xuICAvLyB9KTtcbn1cblxuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuaGFzT3duID0gaGFzT3duO1xuZXhwb3J0cy5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xuZXhwb3J0cy5lbmFibGVDbGFzc0V4dGVuZCA9IGVuYWJsZUNsYXNzRXh0ZW5kO1xuZXhwb3J0cy5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBlbmFibGVDbGFzc01hbmFnZW1lbnQ7XG5leHBvcnRzLnNldFJlYWRPbmx5ID0gc2V0UmVhZE9ubHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvY2xhenouanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///247\n");

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Model = __webpack_require__(246);\n\nvar componentUtil = __webpack_require__(265);\n\nvar clazzUtil = __webpack_require__(247);\n\nvar layout = __webpack_require__(249);\n\nvar boxLayoutMixin = __webpack_require__(344);\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\nvar arrayPush = Array.prototype.push;\n/**\n * @alias module:echarts/model/Component\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {module:echarts/model/Model} ecModel\n */\n\nvar ComponentModel = Model.extend({\n  type: 'component',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  id: '',\n\n  /**\n   * @readOnly\n   */\n  name: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  mainType: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  subType: '',\n\n  /**\n   * @readOnly\n   * @type {number}\n   */\n  componentIndex: 0,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n  ecModel: null,\n\n  /**\n   * key: componentType\n   * value:  Component model list, can not be null.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @readOnly\n   */\n  dependentModels: [],\n\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  uid: null,\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  $constructor: function (option, parentModel, ecModel, extraOpt) {\n    Model.call(this, option, parentModel, ecModel, extraOpt);\n    this.uid = componentUtil.getUID('componentModel');\n  },\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n  },\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n    var themeModel = ecModel.getTheme();\n    zrUtil.merge(option, themeModel.get(this.mainType));\n    zrUtil.merge(option, this.getDefaultOption());\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (option, extraOpt) {\n    zrUtil.merge(this.option, option, true);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(this.option, option, layoutMode);\n    }\n  },\n  // Hooker after init or mergeOption\n  optionUpdated: function (newCptOption, isInit) {},\n  getDefaultOption: function () {\n    if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n      var optList = [];\n      var Class = this.constructor;\n\n      while (Class) {\n        var opt = Class.prototype.defaultOption;\n        opt && optList.push(opt);\n        Class = Class.superClass;\n      }\n\n      var defaultOption = {};\n\n      for (var i = optList.length - 1; i >= 0; i--) {\n        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n      }\n\n      clazzUtil.set(this, '__defaultOption', defaultOption);\n    }\n\n    return clazzUtil.get(this, '__defaultOption');\n  },\n  getReferringComponents: function (mainType) {\n    return this.ecModel.queryComponents({\n      mainType: mainType,\n      index: this.get(mainType + 'Index', true),\n      id: this.get(mainType + 'Id', true)\n    });\n  }\n}); // Reset ComponentModel.extend, add preConstruct.\n// clazzUtil.enableClassExtend(\n//     ComponentModel,\n//     function (option, parentModel, ecModel, extraOpt) {\n//         // Set dependentModels, componentIndex, name, id, mainType, subType.\n//         zrUtil.extend(this, extraOpt);\n//         this.uid = componentUtil.getUID('componentModel');\n//         // this.setReadOnly([\n//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n//         //     'dependentModels', 'componentIndex'\n//         // ]);\n//     }\n// );\n// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(ComponentModel, {\n  registerWhenExtend: true\n});\ncomponentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.\n\ncomponentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\nfunction getDependencies(componentType) {\n  var deps = [];\n  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n    arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n  }); // Ensure main type\n\n  return zrUtil.map(deps, function (type) {\n    return clazzUtil.parseClassType(type).main;\n  });\n}\n\nzrUtil.mixin(ComponentModel, boxLayoutMixin);\nvar _default = ComponentModel;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9Db21wb25lbnQuanM/MGUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4vTW9kZWxcIik7XG5cbnZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY29tcG9uZW50XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBsYXlvdXQgPSByZXF1aXJlKFwiLi4vdXRpbC9sYXlvdXRcIik7XG5cbnZhciBib3hMYXlvdXRNaXhpbiA9IHJlcXVpcmUoXCIuL21peGluL2JveExheW91dFwiKTtcblxuLyoqXG4gKiBDb21wb25lbnQgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKi9cbnZhciBhcnJheVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBwYXJlbnRNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gZWNNb2RlbFxuICovXG5cbnZhciBDb21wb25lbnRNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG4gIHR5cGU6ICdjb21wb25lbnQnLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGlkOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBtYWluVHlwZTogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3ViVHlwZTogJycsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgY29tcG9uZW50SW5kZXg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZWNNb2RlbDogbnVsbCxcblxuICAvKipcbiAgICoga2V5OiBjb21wb25lbnRUeXBlXG4gICAqIHZhbHVlOiAgQ29tcG9uZW50IG1vZGVsIGxpc3QsIGNhbiBub3QgYmUgbnVsbC5cbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBkZXBlbmRlbnRNb2RlbHM6IFtdLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHVpZDogbnVsbCxcblxuICAvKipcbiAgICogU3VwcG9ydCBtZXJnZSBsYXlvdXQgcGFyYW1zLlxuICAgKiBPbmx5IHN1cHBvcnQgJ2JveCcgbm93IChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0KS5cbiAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9IE9iamVjdCBjYW4gYmUge2lnbm9yZVNpemU6IHRydWV9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgbGF5b3V0TW9kZTogbnVsbCxcbiAgJGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICBNb2RlbC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcbiAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCdjb21wb25lbnRNb2RlbCcpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG4gIH0sXG4gIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG4gICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgIH1cbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIGV4dHJhT3B0KSB7XG4gICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuXG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXMub3B0aW9uLCBvcHRpb24sIGxheW91dE1vZGUpO1xuICAgIH1cbiAgfSxcbiAgLy8gSG9va2VyIGFmdGVyIGluaXQgb3IgbWVyZ2VPcHRpb25cbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKG5ld0NwdE9wdGlvbiwgaXNJbml0KSB7fSxcbiAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2xhenpVdGlsLmhhc093bih0aGlzLCAnX19kZWZhdWx0T3B0aW9uJykpIHtcbiAgICAgIHZhciBvcHRMaXN0ID0gW107XG4gICAgICB2YXIgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICB3aGlsZSAoQ2xhc3MpIHtcbiAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xuICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XG4gICAgICAgIENsYXNzID0gQ2xhc3Muc3VwZXJDbGFzcztcbiAgICAgIH1cblxuICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IG9wdExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbiA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9uLCBvcHRMaXN0W2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2xhenpVdGlsLnNldCh0aGlzLCAnX19kZWZhdWx0T3B0aW9uJywgZGVmYXVsdE9wdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXp6VXRpbC5nZXQodGhpcywgJ19fZGVmYXVsdE9wdGlvbicpO1xuICB9LFxuICBnZXRSZWZlcnJpbmdDb21wb25lbnRzOiBmdW5jdGlvbiAobWFpblR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICBpbmRleDogdGhpcy5nZXQobWFpblR5cGUgKyAnSW5kZXgnLCB0cnVlKSxcbiAgICAgIGlkOiB0aGlzLmdldChtYWluVHlwZSArICdJZCcsIHRydWUpXG4gICAgfSk7XG4gIH1cbn0pOyAvLyBSZXNldCBDb21wb25lbnRNb2RlbC5leHRlbmQsIGFkZCBwcmVDb25zdHJ1Y3QuXG4vLyBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoXG4vLyAgICAgQ29tcG9uZW50TW9kZWwsXG4vLyAgICAgZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4vLyAgICAgICAgIC8vIFNldCBkZXBlbmRlbnRNb2RlbHMsIGNvbXBvbmVudEluZGV4LCBuYW1lLCBpZCwgbWFpblR5cGUsIHN1YlR5cGUuXG4vLyAgICAgICAgIHpyVXRpbC5leHRlbmQodGhpcywgZXh0cmFPcHQpO1xuLy8gICAgICAgICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCdjb21wb25lbnRNb2RlbCcpO1xuLy8gICAgICAgICAvLyB0aGlzLnNldFJlYWRPbmx5KFtcbi8vICAgICAgICAgLy8gICAgICd0eXBlJywgJ2lkJywgJ3VpZCcsICduYW1lJywgJ21haW5UeXBlJywgJ3N1YlR5cGUnLFxuLy8gICAgICAgICAvLyAgICAgJ2RlcGVuZGVudE1vZGVscycsICdjb21wb25lbnRJbmRleCdcbi8vICAgICAgICAgLy8gXSk7XG4vLyAgICAgfVxuLy8gKTtcbi8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cblxuY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDb21wb25lbnRNb2RlbCwge1xuICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbn0pO1xuY29tcG9uZW50VXRpbC5lbmFibGVTdWJUeXBlRGVmYXVsdGVyKENvbXBvbmVudE1vZGVsKTsgLy8gQWRkIGNhcGFiaWxpdHkgb2YgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwuXG5cbmNvbXBvbmVudFV0aWwuZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWwoQ29tcG9uZW50TW9kZWwsIGdldERlcGVuZGVuY2llcyk7XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjb21wb25lbnRUeXBlKSB7XG4gIHZhciBkZXBzID0gW107XG4gIHpyVXRpbC5lYWNoKENvbXBvbmVudE1vZGVsLmdldENsYXNzZXNCeU1haW5UeXBlKGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoQ2xhenopIHtcbiAgICBhcnJheVB1c2guYXBwbHkoZGVwcywgQ2xhenoucHJvdG90eXBlLmRlcGVuZGVuY2llcyB8fCBbXSk7XG4gIH0pOyAvLyBFbnN1cmUgbWFpbiB0eXBlXG5cbiAgcmV0dXJuIHpyVXRpbC5tYXAoZGVwcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gY2xhenpVdGlsLnBhcnNlQ2xhc3NUeXBlKHR5cGUpLm1haW47XG4gIH0pO1xufVxuXG56clV0aWwubWl4aW4oQ29tcG9uZW50TW9kZWwsIGJveExheW91dE1peGluKTtcbnZhciBfZGVmYXVsdCA9IENvbXBvbmVudE1vZGVsO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///248\n");

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar BoundingRect = __webpack_require__(244);\n\nvar _number = __webpack_require__(235);\n\nvar parsePercent = _number.parsePercent;\n\nvar formatUtil = __webpack_require__(245);\n\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var position = child.position;\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    position[0] = x;\n    position[1] = y;\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.x, containerWidth);\n  var y = parsePercent(positionInfo.y, containerHeight);\n  var x2 = parsePercent(positionInfo.x2, containerWidth);\n  var y2 = parsePercent(positionInfo.y2, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\n\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n\n  if (!h && !v) {\n    return;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  positionInfo = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransfrom),\n  // we can just only modify el.position to get final result.\n\n  var elPos = el.position;\n  var dx = h ? positionInfo.x - rect.x : 0;\n  var dy = v ? positionInfo.y - rect.y : 0;\n  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\n\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\n\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  !zrUtil.isObject(opt) && (opt = {});\n  var ignoreSize = opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n\n          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n            newParams[name] = targetOption[name];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}\n\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nexports.HV_NAMES = HV_NAMES;\nexports.box = box;\nexports.vbox = vbox;\nexports.hbox = hbox;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutRect = getLayoutRect;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.getLayoutParams = getLayoutParams;\nexports.copyLayoutParams = copyLayoutParams;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL2xheW91dC5qcz8yYjFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuL251bWJlclwiKTtcblxudmFyIHBhcnNlUGVyY2VudCA9IF9udW1iZXIucGFyc2VQZXJjZW50O1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcblxuLy8gTGF5b3V0IGhlbHBlcnMgZm9yIGVhY2ggY29tcG9uZW50IHBvc2l0aW9uaW5nXG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIExPQ0FUSU9OX1BBUkFNUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCddO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cblxudmFyIEhWX05BTUVTID0gW1snd2lkdGgnLCAnbGVmdCcsICdyaWdodCddLCBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ11dO1xuXG5mdW5jdGlvbiBib3hMYXlvdXQob3JpZW50LCBncm91cCwgZ2FwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmIChtYXhXaWR0aCA9PSBudWxsKSB7XG4gICAgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIGlmIChtYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xuICB9XG5cbiAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XG4gIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uO1xuICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XG4gICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBuZXh0WDtcbiAgICB2YXIgbmV4dFk7XG5cbiAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/IC1uZXh0Q2hpbGRSZWN0LnggKyByZWN0LnggOiAwKTtcbiAgICAgIG5leHRYID0geCArIG1vdmVYOyAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhXaWR0aCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG4gICAgICAvLyBGSVhNRSBjb21wYXJlIGJlZm9yZSBhZGRpbmcgZ2FwP1xuXG4gICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogY29uc2lkZXIgcmVjdC55IGlzIG5vdCBgMGA/XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gLW5leHRDaGlsZFJlY3QueSArIHJlY3QueSA6IDApO1xuICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7IC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heEhlaWdodCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG5cbiAgICAgIGlmIChuZXh0WSA+IG1heEhlaWdodCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgIHggKz0gY3VycmVudExpbmVNYXhTaXplICsgZ2FwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgbmV4dFkgPSBtb3ZlWTtcbiAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC53aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3NpdGlvblswXSA9IHg7XG4gICAgcG9zaXRpb25bMV0gPSB5O1xuICAgIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8geCA9IG5leHRYICsgZ2FwIDogeSA9IG5leHRZICsgZ2FwO1xuICB9KTtcbn1cbi8qKlxuICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxuXG52YXIgYm94ID0gYm94TGF5b3V0O1xuLyoqXG4gKiBWQm94IGxheW91dGluZ1xuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPUluZmluaXR5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gKi9cblxudmFyIHZib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAndmVydGljYWwnKTtcbi8qKlxuICogSEJveCBsYXlvdXRpbmdcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PUluZmluaXR5XVxuICovXG5cbnZhciBoYm94ID0genJVdGlsLmN1cnJ5KGJveExheW91dCwgJ2hvcml6b250YWwnKTtcbi8qKlxuICogSWYgeCBvciB4MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdjZW50ZXInICdsZWZ0JyAncmlnaHQnLFxuICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKiBJZiB5IG9yIHkyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ21pZGRsZScgJ3RvcCcgJ2JvdHRvbScsXG4gKiB0aGUgaGVpZ2h0IHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby54Ml1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby55Ml1cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0IHt3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAqIEByZXR1cm4ge09iamVjdH0ge3dpZHRoLCBoZWlnaHR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlU2l6ZShwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG4gIHZhciB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54LCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby55LCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgeDIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLngyLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciB5MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueTIsIGNvbnRhaW5lckhlaWdodCk7XG4gIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG4gIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgIGhlaWdodDogTWF0aC5tYXgoeTIgLSB5IC0gbWFyZ2luWzBdIC0gbWFyZ2luWzJdLCAwKVxuICB9O1xufVxuLyoqXG4gKiBQYXJzZSBwb3NpdGlvbiBpbmZvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5sZWZ0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5yaWdodF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5ib3R0b21dXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uaGVpZ2h0XVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmFzcGVjdF0gQXNwZWN0IGlzIHdpZHRoIC8gaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbbWFyZ2luXVxuICpcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuICB2YXIgbGVmdCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ubGVmdCwgY29udGFpbmVyV2lkdGgpO1xuICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XG4gIHZhciByaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcbiAgdmFyIGJvdHRvbSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uYm90dG9tLCBjb250YWluZXJIZWlnaHQpO1xuICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XG4gIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmhlaWdodCwgY29udGFpbmVySGVpZ2h0KTtcbiAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7IC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XG5cbiAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIGhvcml6b250YWxNYXJnaW4gLSBsZWZ0O1xuICB9XG5cbiAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcDtcbiAgfVxuXG4gIGlmIChhc3BlY3QgIT0gbnVsbCkge1xuICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG5vdCBnaXZlblxuICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgLy8gMi4gQXNwZWN0IG11c3QgYmUga2VlcGVkXG4gICAgLy8gMy4gR3JhcGggc2hvdWxkIHRha2UgdGhlIHNwYWNlIGFzIG1vcmUgYXMgcG9zc2libGVcbiAgICAvLyBGSVhNRVxuICAgIC8vIE1hcmdpbiBpcyBub3QgY29uc2lkZXJlZCwgYmVjYXVzZSB0aGVyZSBpcyBubyBjYXNlIHRoYXQgYm90aFxuICAgIC8vIHVzaW5nIG1hcmdpbiBhbmQgYXNwZWN0IHNvIGZhci5cbiAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoICogMC44O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ICogMC44O1xuICAgICAgfVxuICAgIH0gLy8gQ2FsY3VsYXRlIHdpZHRoIG9yIGhlaWdodCB3aXRoIGdpdmVuIGFzcGVjdFxuXG5cbiAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfVxuICB9IC8vIElmIGxlZnQgaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGxlZnQgZnJvbSByaWdodCBhbmQgd2lkdGhcblxuXG4gIGlmIChpc05hTihsZWZ0KSkge1xuICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICB9XG5cbiAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgfSAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcblxuXG4gIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3dpdGNoIChwb3NpdGlvbkluZm8udG9wIHx8IHBvc2l0aW9uSW5mby5ib3R0b20pIHtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgYnJlYWs7XG4gIH0gLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG5cblxuICBsZWZ0ID0gbGVmdCB8fCAwO1xuICB0b3AgPSB0b3AgfHwgMDtcblxuICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgLy8gV2lkdGggbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgd2lkdGhcbiAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gIH1cblxuICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gIH1cblxuICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gIHJldHVybiByZWN0O1xufVxuLyoqXG4gKiBQb3NpdGlvbiBhIHpyIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAqICBHcm91cCBwb3NpdGlvbiBpcyBzcGVjaWZpZWQgYnkgZWl0aGVyXG4gKiAge2xlZnQsIHRvcH0sIHtyaWdodCwgYm90dG9tfVxuICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXG4gKlxuICogTG9naWM6XG4gKiAgICAgMS4gU2NhbGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAyLiBSb3RhdGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAqICAgICAzLiBUcmFzbGF0ZSAod2l0aCBlbC5wb3NpdGlvbiBieSB0aGlzIG1ldGhvZClcbiAqIFNvIHRoaXMgbWV0aG9kIG9ubHkgZml4ZXMgdGhlIGxhc3Qgc3RlcCAnVHJhc2xhdGUnLCB3aGljaCBkb2VzIG5vdCBhZmZlY3RcbiAqIHNjYWxpbmcgYW5kIHJvdGF0aW5nLlxuICpcbiAqIElmIGJlIGNhbGxlZCByZXBlYXRseSB3aXRoIHRoZSBzYW1lIGlucHV0IGVsLCB0aGUgc2FtZSByZXN1bHQgd2lsbCBiZSBnb3R0ZW4uXG4gKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCBTaG91bGQgaGF2ZSBgZ2V0Qm91bmRpbmdSZWN0YCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ubGVmdF1cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYm90dG9tXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLndpZHRoXSBPbmx5IGZvciBvcHQuYm91bmRpbmdNb2RlbDogJ3JhdydcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5oZWlnaHRdIE9ubHkgZm9yIG9wdC5ib3VuZGluZ01vZGVsOiAncmF3J1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHQuaHY9WzEsMV1dIE9ubHkgaG9yaXpvbnRhbCBvciBvbmx5IHZlcnRpY2FsLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdC5ib3VuZGluZ01vZGU9J2FsbCddXG4gKiAgICAgICAgU3BlY2lmeSBob3cgdG8gY2FsY3VsYXRlIGJvdW5kaW5nUmVjdCB3aGVuIGxvY2F0aW5nLlxuICogICAgICAgICdhbGwnOiBQb3NpdGlvbiB0aGUgYm91bmRpbmdSZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgYW5kIHVpb25lZFxuICogICAgICAgICAgICAgICBib3RoIGl0c2VsZiBhbmQgaXRzIGRlc2NlbmRhbnRzLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgc2ltcGxpZXMgY29uZmluZSB0aGUgZWxlbWVudHMgaW4gdGhlIGJvdW5kaW5nXG4gKiAgICAgICAgICAgICAgIG9mIHRoZWlyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXG4gKiAgICAgICAgJ3Jhdyc6IFBvc2l0aW9uIHRoZSBib3VuZGluZ1JlY3QgdGhhdCBpcyBub3QgdHJhbnNmb3JtZWQgYW5kIG9ubHkgaXRzZWxmLlxuICogICAgICAgICAgICAgICBUaGlzIG1vZGUgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgYSBlbGVtZW50IGNhbiBvdmVyZmxvdyBpdHNcbiAqICAgICAgICAgICAgICAgY29udGFpbmVyLiAoQ29uc2lkZXIgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcbiAqICAgICAgICAgICAgICAgSW4gdGhpcyBtb2RlIHBvc2l0aW9uSW5mby53aWR0aC9oZWlnaHQgY2FuIG9ubHkgYmUgbnVtYmVyLlxuICovXG5cblxuZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50KGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XG4gIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcbiAgdmFyIHYgPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzFdO1xuICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XG5cbiAgaWYgKCFoICYmICF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlY3Q7XG5cbiAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcbiAgICByZWN0ID0gZWwudHlwZSA9PT0gJ2dyb3VwJyA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKSA6IGVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcblxuICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsLmdldExvY2FsVHJhbnNmb3JtKCk7IC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG5cbiAgICAgIHJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgfVxuICB9IC8vIFRoZSByZWFsIHdpZHRoIGFuZCBoZWlnaHQgY2FuIG5vdCBiZSBzcGVjaWZpZWQgYnV0IGNhbGN1bGF0ZWQgYnkgdGhlIGdpdmVuIGVsLlxuXG5cbiAgcG9zaXRpb25JbmZvID0gZ2V0TGF5b3V0UmVjdCh6clV0aWwuZGVmYXVsdHMoe1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfSwgcG9zaXRpb25JbmZvKSwgY29udGFpbmVyUmVjdCwgbWFyZ2luKTsgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXG4gIC8vIChzZWUgenJlbmRlci9jb3JlL1RyYW5zZm9ybWFibGUjZ2V0TG9jYWxUcmFuc2Zyb20pLFxuICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxuXG4gIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xuICB2YXIgZHggPSBoID8gcG9zaXRpb25JbmZvLnggLSByZWN0LnggOiAwO1xuICB2YXIgZHkgPSB2ID8gcG9zaXRpb25JbmZvLnkgLSByZWN0LnkgOiAwO1xuICBlbC5hdHRyKCdwb3NpdGlvbicsIGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycgPyBbZHgsIGR5XSA6IFtlbFBvc1swXSArIGR4LCBlbFBvc1sxXSArIGR5XSk7XG59XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gQ29udGFpbnMgc29tZSBvZiB0aGUgcHJvcGVydGllcyBpbiBIVl9OQU1FUy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBodklkeCAwOiBob3Jpem9udGFsOyAxOiB2ZXJ0aWNhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNpemVDYWxjdWxhYmxlKG9wdGlvbiwgaHZJZHgpIHtcbiAgcmV0dXJuIG9wdGlvbltIVl9OQU1FU1todklkeF1bMF1dICE9IG51bGwgfHwgb3B0aW9uW0hWX05BTUVTW2h2SWR4XVsxXV0gIT0gbnVsbCAmJiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzJdXSAhPSBudWxsO1xufVxuLyoqXG4gKiBDb25zaWRlciBDYXNlOlxuICogV2hlbiBkZWZ1bGF0IG9wdGlvbiBoYXMge2xlZnQ6IDAsIHdpZHRoOiAxMDB9LCBhbmQgd2Ugc2V0IHtyaWdodDogMH1cbiAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAqIHtyaWdodDogMH0gZG9lcyBub3QgdGFrZSBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG4gKiAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICAuLi5cbiAqICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbik7XG4gKiAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24oaW5wdXRQb3NpdGlvblBhcmFtcyk7XG4gKiAgICAgfSxcbiAqICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICogICAgICAgICBuZXdPcHRpb24gJiYgenJVdGlsLm1lcmdlKHRoaXNPcHRpb24sIG5ld09wdGlvbiwgdHJ1ZSk7XG4gKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldE9wdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG5ld09wdGlvblxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICogQHBhcmFtIHtib29sZWFufEFycmF5Ljxib29sZWFuPn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBVc2VkIGZvciB0aGUgY29tcG9uZW50c1xuICogIHRoYXQgd2lkdGggKG9yIGhlaWdodCkgc2hvdWxkIG5vdCBiZSBjYWxjdWxhdGVkIGJ5IGxlZnQgYW5kIHJpZ2h0IChvciB0b3AgYW5kIGJvdHRvbSkuXG4gKi9cblxuXG5mdW5jdGlvbiBtZXJnZUxheW91dFBhcmFtKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG4gIHZhciBpZ25vcmVTaXplID0gb3B0Lmlnbm9yZVNpemU7XG4gICF6clV0aWwuaXNBcnJheShpZ25vcmVTaXplKSAmJiAoaWdub3JlU2l6ZSA9IFtpZ25vcmVTaXplLCBpZ25vcmVTaXplXSk7XG4gIHZhciBoUmVzdWx0ID0gbWVyZ2UoSFZfTkFNRVNbMF0sIDApO1xuICB2YXIgdlJlc3VsdCA9IG1lcmdlKEhWX05BTUVTWzFdLCAxKTtcbiAgY29weShIVl9OQU1FU1swXSwgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgY29weShIVl9OQU1FU1sxXSwgdGFyZ2V0T3B0aW9uLCB2UmVzdWx0KTtcblxuICBmdW5jdGlvbiBtZXJnZShuYW1lcywgaHZJZHgpIHtcbiAgICB2YXIgbmV3UGFyYW1zID0ge307XG4gICAgdmFyIG5ld1ZhbHVlQ291bnQgPSAwO1xuICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICB2YXIgbWVyZ2VkVmFsdWVDb3VudCA9IDA7XG4gICAgdmFyIGVub3VnaFBhcmFtTnVtYmVyID0gMjtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgIH0pO1xuICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBDb25zaWRlciBjYXNlOiBuZXdPcHRpb24ud2lkdGggaXMgbnVsbCwgd2hpY2ggaXNcbiAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgaGFzUHJvcChuZXdPcHRpb24sIG5hbWUpICYmIChuZXdQYXJhbXNbbmFtZV0gPSBtZXJnZWRbbmFtZV0gPSBuZXdPcHRpb25bbmFtZV0pO1xuICAgICAgaGFzVmFsdWUobmV3UGFyYW1zLCBuYW1lKSAmJiBuZXdWYWx1ZUNvdW50Kys7XG4gICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICB9KTtcblxuICAgIGlmIChpZ25vcmVTaXplW2h2SWR4XSkge1xuICAgICAgLy8gT25seSBvbmUgb2YgbGVmdC9yaWdodCBpcyBwcmVtaXR0ZWQgdG8gZXhpc3QuXG4gICAgICBpZiAoaGFzVmFsdWUobmV3T3B0aW9uLCBuYW1lc1sxXSkpIHtcbiAgICAgICAgbWVyZ2VkW25hbWVzWzJdXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMl0pKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lc1sxXV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH0gLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgLy8gb3IgdGFyZ2V0T3B0aW9uOiB7cmlnaHQ6IC4uLn0gYW5kIG5ld09wdGlvbjoge3dpZHRoOiAuLi59LFxuICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgIC8vIGxpdHRsZSB0aGFuIGVub3VnaFBhcmFtTnVtYmVyLlxuXG5cbiAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgLy8gYWxsIG9yaWdpbiBwYXJhbXMgaW4gdGFyZ2V0T3B0aW9uLlxuICAgIGVsc2UgaWYgKG5ld1ZhbHVlQ291bnQgPj0gZW5vdWdoUGFyYW1OdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNQcm9wKG5ld1BhcmFtcywgbmFtZSkgJiYgaGFzUHJvcCh0YXJnZXRPcHRpb24sIG5hbWUpKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXNbbmFtZV0gPSB0YXJnZXRPcHRpb25bbmFtZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJvcChvYmosIG5hbWUpIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgcmV0dXJuIG9ialtuYW1lXSAhPSBudWxsICYmIG9ialtuYW1lXSAhPT0gJ2F1dG8nO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weShuYW1lcywgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UGFyYW1zKHNvdXJjZSkge1xuICByZXR1cm4gY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbn1cbi8qKlxuICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5TGF5b3V0UGFyYW1zKHRhcmdldCwgc291cmNlKSB7XG4gIHNvdXJjZSAmJiB0YXJnZXQgJiYgZWFjaChMT0NBVElPTl9QQVJBTVMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpICYmICh0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0cy5MT0NBVElPTl9QQVJBTVMgPSBMT0NBVElPTl9QQVJBTVM7XG5leHBvcnRzLkhWX05BTUVTID0gSFZfTkFNRVM7XG5leHBvcnRzLmJveCA9IGJveDtcbmV4cG9ydHMudmJveCA9IHZib3g7XG5leHBvcnRzLmhib3ggPSBoYm94O1xuZXhwb3J0cy5nZXRBdmFpbGFibGVTaXplID0gZ2V0QXZhaWxhYmxlU2l6ZTtcbmV4cG9ydHMuZ2V0TGF5b3V0UmVjdCA9IGdldExheW91dFJlY3Q7XG5leHBvcnRzLnBvc2l0aW9uRWxlbWVudCA9IHBvc2l0aW9uRWxlbWVudDtcbmV4cG9ydHMuc2l6ZUNhbGN1bGFibGUgPSBzaXplQ2FsY3VsYWJsZTtcbmV4cG9ydHMubWVyZ2VMYXlvdXRQYXJhbSA9IG1lcmdlTGF5b3V0UGFyYW07XG5leHBvcnRzLmdldExheW91dFBhcmFtcyA9IGdldExheW91dFBhcmFtcztcbmV4cG9ydHMuY29weUxheW91dFBhcmFtcyA9IGNvcHlMYXlvdXRQYXJhbXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///249\n");

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

eval("var BoundingRect = __webpack_require__(244);\n\nvar imageHelper = __webpack_require__(270);\n\nvar _util = __webpack_require__(230);\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanM/M2E0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkgOiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmdcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgLT0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KGZvbnQpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHJldHVybiAoc3R5bGUuZm9udFNpemUgfHwgc3R5bGUuZm9udEZhbWlseSkgJiYgW3N0eWxlLmZvbnRTdHlsZSwgc3R5bGUuZm9udFdlaWdodCwgKHN0eWxlLmZvbnRTaXplIHx8IDEyKSArICdweCcsIC8vIElmIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgYGZvbnRGYW1pbHlgIHNob3VsZCBub3QgYmUgaWdub3JlZC5cbiAgc3R5bGUuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKSB8fCBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xufVxuXG5leHBvcnRzLkRFRkFVTFRfRk9OVCA9IERFRkFVTFRfRk9OVDtcbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5nZXRXaWR0aCA9IGdldFdpZHRoO1xuZXhwb3J0cy5nZXRCb3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkanVzdFRleHRYID0gYWRqdXN0VGV4dFg7XG5leHBvcnRzLmFkanVzdFRleHRZID0gYWRqdXN0VGV4dFk7XG5leHBvcnRzLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCA9IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRMaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodDtcbmV4cG9ydHMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbmV4cG9ydHMucGFyc2VQbGFpblRleHQgPSBwYXJzZVBsYWluVGV4dDtcbmV4cG9ydHMucGFyc2VSaWNoVGV4dCA9IHBhcnNlUmljaFRleHQ7XG5leHBvcnRzLm1ha2VGb250ID0gbWFrZUZvbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///250\n");

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _vector = __webpack_require__(236);\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * 计算三次贝塞尔值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * 计算三次贝塞尔导数值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * 计算三次贝塞尔方程根，使用盛金公式\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算三次贝塞尔方程极限值的位置\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} 有效数目\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 细分三次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * 投射点到三次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] 投射点\n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * 计算二次方贝塞尔值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * 计算二次方贝塞尔导数值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * 计算二次方贝塞尔方程根\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算二次贝塞尔方程极限值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * 细分二次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * 投射点到二次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out 投射点\n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzPzk1MTEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciB2MkNyZWF0ZSA9IF92ZWN0b3IuY3JlYXRlO1xudmFyIHYyRGlzdFNxdWFyZSA9IF92ZWN0b3IuZGlzdFNxdWFyZTtcblxuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG52YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xudmFyIE9ORV9USElSRCA9IDEgLyAzOyAvLyDkuLTml7blj5jph49cblxudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YyID0gdjJDcmVhdGUoKTtcblxuZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKSArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gIHZhciBjID0gMyAqIChwMSAtIHAwKTtcbiAgdmFyIGQgPSBwMCAtIHZhbDtcbiAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgcm9vdHNbMF0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7IC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAvLyB0MSwgYSBpcyBub3QgemVyb1xuXG4gICAgICB2YXIgdDIgPSAtSyAvIDI7IC8vIHQyLCB0M1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG5cbiAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyO1xuICBvdXRbM10gPSBwMDEyMzsgLy8gU2VnMVxuXG4gIG91dFs0XSA9IHAwMTIzO1xuICBvdXRbNV0gPSBwMTIzO1xuICBvdXRbNl0gPSBwMjM7XG4gIG91dFs3XSA9IHAzO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIHByZXY7XG4gIHZhciBuZXh0O1xuICB2YXIgZDE7XG4gIHZhciBkMjtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gIHZhciBjID0gcDAgLSB2YWw7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICByZXR1cm4gMC41O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICB9XG59XG4vKipcbiAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7IC8vIFNlZzFcblxuICBvdXRbM10gPSBwMDEyO1xuICBvdXRbNF0gPSBwMTI7XG4gIG91dFs1XSA9IHAyO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cbmV4cG9ydHMuY3ViaWNBdCA9IGN1YmljQXQ7XG5leHBvcnRzLmN1YmljRGVyaXZhdGl2ZUF0ID0gY3ViaWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLmN1YmljUm9vdEF0ID0gY3ViaWNSb290QXQ7XG5leHBvcnRzLmN1YmljRXh0cmVtYSA9IGN1YmljRXh0cmVtYTtcbmV4cG9ydHMuY3ViaWNTdWJkaXZpZGUgPSBjdWJpY1N1YmRpdmlkZTtcbmV4cG9ydHMuY3ViaWNQcm9qZWN0UG9pbnQgPSBjdWJpY1Byb2plY3RQb2ludDtcbmV4cG9ydHMucXVhZHJhdGljQXQgPSBxdWFkcmF0aWNBdDtcbmV4cG9ydHMucXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5xdWFkcmF0aWNSb290QXQgPSBxdWFkcmF0aWNSb290QXQ7XG5leHBvcnRzLnF1YWRyYXRpY0V4dHJlbXVtID0gcXVhZHJhdGljRXh0cmVtdW07XG5leHBvcnRzLnF1YWRyYXRpY1N1YmRpdmlkZSA9IHF1YWRyYXRpY1N1YmRpdmlkZTtcbmV4cG9ydHMucXVhZHJhdGljUHJvamVjdFBvaW50ID0gcXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///251\n");

/***/ }),
/* 252 */
/***/ (function(module, exports) {

eval("/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * 事件分发器\n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * 单次触发绑定，trigger后销毁\n   *\n   * @param {string} event 事件名\n   * @param {Function} handler 响应函数\n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 绑定事件\n   * @param {string} event 事件名\n   * @param {Function} handler 事件处理函数\n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * 是否绑定了事件\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * 解绑事件\n   * @param {string} event 事件名\n   * @param {Function} [handler] 事件处理函数\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * 事件分发\n   *\n   * @param {string} type 事件类型\n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * 带有context的事件分发, 最后一个参数是事件回调的context\n   * @param {string} type 事件类型\n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; // 对象可以通过 onxxxx 绑定事件\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qcz8yMjNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4vKipcbiAqIOS6i+S7tuWIhuWPkeWZqFxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgLyoqXG4gICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiB0cnVlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnu5Hlrprkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogZmFsc2UsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICByZXR1cm4gX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOino+e7keS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSDkuovku7blpITnkIblh73mlbBcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+RXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW4puaciWNvbnRleHTnmoTkuovku7bliIblj5EsIOacgOWQjuS4gOS4quWPguaVsOaYr+S6i+S7tuWbnuiwg+eahGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59OyAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG52YXIgX2RlZmF1bHQgPSBFdmVudGZ1bDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///252\n");

/***/ }),
/* 253 */
/***/ (function(module, exports) {

eval("/**\n * 3x2矩阵操作类\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个单位矩阵\n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * 设置矩阵为单位矩阵\n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * 复制矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * 矩阵相乘\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * 平移变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * 旋转变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * 缩放变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * 求逆矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcz85N2EyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogM3gy55+p6Zi15pON5L2c57G7XG4gKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gKi9cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICBpZGVudGl0eShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgbSkge1xuICBvdXRbMF0gPSBtWzBdO1xuICBvdXRbMV0gPSBtWzFdO1xuICBvdXRbMl0gPSBtWzJdO1xuICBvdXRbM10gPSBtWzNdO1xuICBvdXRbNF0gPSBtWzRdO1xuICBvdXRbNV0gPSBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXnm7jkuZhcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gKi9cblxuXG5mdW5jdGlvbiBtdWwob3V0LCBtMSwgbTIpIHtcbiAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gb3V0MztcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5bmz56e75Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDml4vovazlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnvKnmlL7lj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB2eCA9IHZbMF07XG4gIHZhciB2eSA9IHZbMV07XG4gIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICBvdXRbMl0gPSBhWzJdICogdng7XG4gIG91dFszXSA9IGFbM10gKiB2eTtcbiAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICBvdXRbNV0gPSBhWzVdICogdnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxgumAhuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///253\n");

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar textContain = __webpack_require__(250);\n\nvar OrdinalScale = __webpack_require__(351);\n\nvar IntervalScale = __webpack_require__(264);\n\nvar Scale = __webpack_require__(257);\n\nvar numberUtil = __webpack_require__(235);\n\n__webpack_require__(352);\n\n__webpack_require__(350);\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = (model.get('data') || []).length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\n\n\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n  var textSpaceTakenRect;\n  var autoLabelInterval = 0;\n  var accumulatedLabelInterval = 0;\n  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n  var step = 1;\n\n  if (labels.length > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.floor(labels.length / 40);\n  }\n\n  for (var i = 0; i < tickCoords.length; i += step) {\n    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n    rect.x += tickCoord * Math.cos(rotation);\n    rect.y += tickCoord * Math.sin(rotation); // Magic number\n\n    rect.width *= 1.3;\n    rect.height *= 1.3;\n\n    if (!textSpaceTakenRect) {\n      textSpaceTakenRect = rect.clone();\n    } // There is no space for current label;\n    else if (textSpaceTakenRect.intersect(rect)) {\n        accumulatedLabelInterval++;\n        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n      } else {\n        textSpaceTakenRect.union(rect); // Reset\n\n        accumulatedLabelInterval = 0;\n      }\n  }\n\n  if (autoLabelInterval === 0 && step > 1) {\n    return step;\n  }\n\n  return (autoLabelInterval + 1) * step - 1;\n}\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\n\n\nfunction getFormattedLabels(axis, labelFormatter) {\n  var scale = axis.scale;\n  var labels = scale.getTicksLabels();\n  var ticks = scale.getTicks();\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return zrUtil.map(labels, labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return zrUtil.map(ticks, function (tick, idx) {\n      return labelFormatter(getAxisRawValue(axis, tick), idx);\n    }, this);\n  } else {\n    return labels;\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.getAxisLabelInterval = getAxisLabelInterval;\nexports.getFormattedLabels = getFormattedLabels;\nexports.getAxisRawValue = getAxisRawValue;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb29yZC9heGlzSGVscGVyLmpzPzQ3MzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgX19ERVZfXyA9IF9jb25maWcuX19ERVZfXztcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluL3RleHRcIik7XG5cbnZhciBPcmRpbmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvT3JkaW5hbFwiKTtcblxudmFyIEludGVydmFsU2NhbGUgPSByZXF1aXJlKFwiLi4vc2NhbGUvSW50ZXJ2YWxcIik7XG5cbnZhciBTY2FsZSA9IHJlcXVpcmUoXCIuLi9zY2FsZS9TY2FsZVwiKTtcblxudmFyIG51bWJlclV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9udW1iZXJcIik7XG5cbnJlcXVpcmUoXCIuLi9zY2FsZS9UaW1lXCIpO1xuXG5yZXF1aXJlKFwiLi4vc2NhbGUvTG9nXCIpO1xuXG4vKipcbiAqIEdldCBheGlzIHNjYWxlIGV4dGVudCBiZWZvcmUgbmljZWQuXG4gKiBJdGVtIG9mIHJldHVybmVkIGFycmF5IGNhbiBvbmx5IGJlIG51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5IGFuZCBOYU4pLlxuICovXG5mdW5jdGlvbiBnZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG4gIHZhciBtaW4gPSBtb2RlbC5nZXRNaW4oKTtcbiAgdmFyIG1heCA9IG1vZGVsLmdldE1heCgpO1xuICB2YXIgZml4TWluID0gbWluICE9IG51bGw7XG4gIHZhciBmaXhNYXggPSBtYXggIT0gbnVsbDtcbiAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gIHZhciBheGlzRGF0YUxlbjtcbiAgdmFyIGJvdW5kYXJ5R2FwO1xuICB2YXIgc3BhbjtcblxuICBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzRGF0YUxlbiA9IChtb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShib3VuZGFyeUdhcCkpIHtcbiAgICAgIGJvdW5kYXJ5R2FwID0gW2JvdW5kYXJ5R2FwIHx8IDAsIGJvdW5kYXJ5R2FwIHx8IDBdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgYm91bmRhcnlHYXAgPSBbMCwgMF07XG4gICAgfVxuXG4gICAgYm91bmRhcnlHYXBbMF0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFswXSwgMSk7XG4gICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgc3BhbiA9IG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0gfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pO1xuICB9IC8vIE5vdGljZTogV2hlbiBtaW4vbWF4IGlzIG5vdCBzZXQgKHRoYXQgaXMsIHdoZW4gdGhlcmUgYXJlIG51bGwvdW5kZWZpbmVkLFxuICAvLyB3aGljaCBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSksIHRoZXNlIGNhc2VzIHNob3VsZCBiZSBlbnN1cmVkOlxuICAvLyAoMSkgRm9yICdvcmRpbmFsJywgc2hvdyBhbGwgYXhpcy5kYXRhLlxuICAvLyAoMikgRm9yIG90aGVyczpcbiAgLy8gICAgICArIGBib3VuZGFyeUdhcGAgaXMgYXBwbGllZCAoaWYgbWluL21heCBzZXQsIGJvdW5kYXJ5R2FwIGlzXG4gIC8vICAgICAgZGlzYWJsZWQpLlxuICAvLyAgICAgICsgSWYgYG5lZWRDcm9zc1plcm9gLCBtaW4vbWF4IHNob3VsZCBiZSB6ZXJvLCBvdGhlcndpc2UsIG1pbi9tYXggc2hvdWxkXG4gIC8vICAgICAgYmUgdGhlIHJlc3VsdCB0aGF0IG9yaWdpbmFsRXh0ZW50IGVubGFyZ2VkIGJ5IGJvdW5kYXJ5R2FwLlxuICAvLyAoMykgSWYgbm8gZGF0YSwgaXQgc2hvdWxkIGJlIGVuc3VyZWQgdGhhdCBgc2NhbGUuc2V0QmxhbmtgIGlzIHNldC5cbiAgLy8gRklYTUVcbiAgLy8gKDEpIFdoZW4gbWluL21heCBpcyAnZGF0YU1pbicgb3IgJ2RhdGFNYXgnLCBzaG91bGQgYm91bmRhcnlHYXAgYmUgYWJsZSB0byB1c2VkP1xuICAvLyAoMikgV2hlbiBgbmVlZENyb3NzWmVyb2AgYW5kIGFsbCBkYXRhIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCBzaG91bGQgaXQgYmUgZW5zdXJlZFxuICAvLyB0aGF0IHRoZSByZXN1bHRzIHByb2Nlc3NlZCBieSBib3VuZGFyeUdhcCBhcmUgcG9zaXRpdmUvbmVnYXRpdmU/XG5cblxuICBpZiAobWluID09IG51bGwpIHtcbiAgICBtaW4gPSBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJyA/IGF4aXNEYXRhTGVuID8gMCA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyBheGlzRGF0YUxlbiA/IGF4aXNEYXRhTGVuIC0gMSA6IE5hTiA6IG9yaWdpbmFsRXh0ZW50WzFdICsgYm91bmRhcnlHYXBbMV0gKiBzcGFuO1xuICB9XG5cbiAgaWYgKG1pbiA9PT0gJ2RhdGFNaW4nKSB7XG4gICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1pbiA9IG1pbih7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgbWF4ID0gb3JpZ2luYWxFeHRlbnRbMV07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1heCA9IG1heCh7XG4gICAgICBtaW46IG9yaWdpbmFsRXh0ZW50WzBdLFxuICAgICAgbWF4OiBvcmlnaW5hbEV4dGVudFsxXVxuICAgIH0pO1xuICB9XG5cbiAgKG1pbiA9PSBudWxsIHx8ICFpc0Zpbml0ZShtaW4pKSAmJiAobWluID0gTmFOKTtcbiAgKG1heCA9PSBudWxsIHx8ICFpc0Zpbml0ZShtYXgpKSAmJiAobWF4ID0gTmFOKTtcbiAgc2NhbGUuc2V0QmxhbmsoenJVdGlsLmVxTmFOKG1pbikgfHwgenJVdGlsLmVxTmFOKG1heCkpOyAvLyBFdmFsdWF0ZSBpZiBheGlzIG5lZWRzIGNyb3NzIHplcm9cblxuICBpZiAobW9kZWwuZ2V0TmVlZENyb3NzWmVybygpKSB7XG4gICAgLy8gQXhpcyBpcyBvdmVyIHplcm8gYW5kIG1pbiBpcyBub3Qgc2V0XG4gICAgaWYgKG1pbiA+IDAgJiYgbWF4ID4gMCAmJiAhZml4TWluKSB7XG4gICAgICBtaW4gPSAwO1xuICAgIH0gLy8gQXhpcyBpcyB1bmRlciB6ZXJvIGFuZCBtYXggaXMgbm90IHNldFxuXG5cbiAgICBpZiAobWluIDwgMCAmJiBtYXggPCAwICYmICFmaXhNYXgpIHtcbiAgICAgIG1heCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIG5pY2VTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpIHtcbiAgdmFyIGV4dGVudCA9IGdldFNjYWxlRXh0ZW50KHNjYWxlLCBtb2RlbCk7XG4gIHZhciBmaXhNaW4gPSBtb2RlbC5nZXRNaW4oKSAhPSBudWxsO1xuICB2YXIgZml4TWF4ID0gbW9kZWwuZ2V0TWF4KCkgIT0gbnVsbDtcbiAgdmFyIHNwbGl0TnVtYmVyID0gbW9kZWwuZ2V0KCdzcGxpdE51bWJlcicpO1xuXG4gIGlmIChzY2FsZS50eXBlID09PSAnbG9nJykge1xuICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgfVxuXG4gIHZhciBzY2FsZVR5cGUgPSBzY2FsZS50eXBlO1xuICBzY2FsZS5zZXRFeHRlbnQoZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICBzY2FsZS5uaWNlRXh0ZW50KHtcbiAgICBzcGxpdE51bWJlcjogc3BsaXROdW1iZXIsXG4gICAgZml4TWluOiBmaXhNaW4sXG4gICAgZml4TWF4OiBmaXhNYXgsXG4gICAgbWluSW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWluSW50ZXJ2YWwnKSA6IG51bGwsXG4gICAgbWF4SW50ZXJ2YWw6IHNjYWxlVHlwZSA9PT0gJ2ludGVydmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyA/IG1vZGVsLmdldCgnbWF4SW50ZXJ2YWwnKSA6IG51bGxcbiAgfSk7IC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gIC8vIHRvIGJlIDYwLlxuICAvLyBGSVhNRVxuXG4gIHZhciBpbnRlcnZhbCA9IG1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcblxuICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgIHNjYWxlLnNldEludGVydmFsICYmIHNjYWxlLnNldEludGVydmFsKGludGVydmFsKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtzdHJpbmd9IFtheGlzVHlwZV0gRGVmYXVsdCByZXRyaWV2ZSBmcm9tIG1vZGVsLnR5cGVcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUJ5TW9kZWwobW9kZWwsIGF4aXNUeXBlKSB7XG4gIGF4aXNUeXBlID0gYXhpc1R5cGUgfHwgbW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgaWYgKGF4aXNUeXBlKSB7XG4gICAgc3dpdGNoIChheGlzVHlwZSkge1xuICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgY2FzZSAnY2F0ZWdvcnknOlxuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZShtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG5cbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAvLyBFeHRlbmRlZCBzY2FsZSwgbGlrZSB0aW1lIGFuZCBsb2dcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGF4aXMgY29yc3MgMFxuICovXG5cblxuZnVuY3Rpb24gaWZBeGlzQ3Jvc3NaZXJvKGF4aXMpIHtcbiAgdmFyIGRhdGFFeHRlbnQgPSBheGlzLnNjYWxlLmdldEV4dGVudCgpO1xuICB2YXIgbWluID0gZGF0YUV4dGVudFswXTtcbiAgdmFyIG1heCA9IGRhdGFFeHRlbnRbMV07XG4gIHJldHVybiAhKG1pbiA+IDAgJiYgbWF4ID4gMCB8fCBtaW4gPCAwICYmIG1heCA8IDApO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXNSb3RhdGUgMDogdG93YXJkcyByaWdodCBob3Jpem9udGFsbHksIGNsb2NrLXdpc2UgaXMgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xhYmVsUm90YXRlPTBdIDA6IHRvd2FyZHMgcmlnaHQgaG9yaXpvbnRhbGx5LCBjbG9jay13aXNlIGlzIG5lZ2F0aXZlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXhpc0xhYmVsSW50ZXJ2YWwodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBheGlzUm90YXRlLCBsYWJlbFJvdGF0ZSkge1xuICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgdmFyIHJvdGF0aW9uID0gKGF4aXNSb3RhdGUgLSBsYWJlbFJvdGF0ZSkgLyAxODAgKiBNYXRoLlBJO1xuICB2YXIgc3RlcCA9IDE7XG5cbiAgaWYgKGxhYmVscy5sZW5ndGggPiA0MCkge1xuICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICBzdGVwID0gTWF0aC5mbG9vcihsYWJlbHMubGVuZ3RoIC8gNDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrQ29vcmRzLmxlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgdmFyIHRpY2tDb29yZCA9IHRpY2tDb29yZHNbaV07IC8vIE5vdCBwcmVjaXNlLCBkbyBub3QgY29uc2lkZXIgYWxpZ24gYW5kIHZlcnRpY2FsIGFsaWduXG4gICAgLy8gYW5kIGVhY2ggZGlzdGFuY2UgZnJvbSBheGlzIGxpbmUgeWV0LlxuXG4gICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCcpO1xuICAgIHJlY3QueCArPSB0aWNrQ29vcmQgKiBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgcmVjdC55ICs9IHRpY2tDb29yZCAqIE1hdGguc2luKHJvdGF0aW9uKTsgLy8gTWFnaWMgbnVtYmVyXG5cbiAgICByZWN0LndpZHRoICo9IDEuMztcbiAgICByZWN0LmhlaWdodCAqPSAxLjM7XG5cbiAgICBpZiAoIXRleHRTcGFjZVRha2VuUmVjdCkge1xuICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgIH0gLy8gVGhlcmUgaXMgbm8gc3BhY2UgZm9yIGN1cnJlbnQgbGFiZWw7XG4gICAgZWxzZSBpZiAodGV4dFNwYWNlVGFrZW5SZWN0LmludGVyc2VjdChyZWN0KSkge1xuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgYXV0b0xhYmVsSW50ZXJ2YWwgPSBNYXRoLm1heChhdXRvTGFiZWxJbnRlcnZhbCwgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRTcGFjZVRha2VuUmVjdC51bmlvbihyZWN0KTsgLy8gUmVzZXRcblxuICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKGF1dG9MYWJlbEludGVydmFsID09PSAwICYmIHN0ZXAgPiAxKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gKGF1dG9MYWJlbEludGVydmFsICsgMSkgKiBzdGVwIC0gMTtcbn1cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGF4aXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZExhYmVscyhheGlzLCBsYWJlbEZvcm1hdHRlcikge1xuICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICB2YXIgbGFiZWxzID0gc2NhbGUuZ2V0VGlja3NMYWJlbHMoKTtcbiAgdmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcblxuICBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHRwbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7XG4gICAgICB9O1xuICAgIH0obGFiZWxGb3JtYXR0ZXIpOyAvLyBDb25zaWRlciBlbXB0eSBhcnJheVxuXG5cbiAgICByZXR1cm4genJVdGlsLm1hcChsYWJlbHMsIGxhYmVsRm9ybWF0dGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGlkeCkge1xuICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKGdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSwgaWR4KTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFiZWxzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSkge1xuICAvLyBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldExhYmVsKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5leHBvcnRzLmdldFNjYWxlRXh0ZW50ID0gZ2V0U2NhbGVFeHRlbnQ7XG5leHBvcnRzLm5pY2VTY2FsZUV4dGVudCA9IG5pY2VTY2FsZUV4dGVudDtcbmV4cG9ydHMuY3JlYXRlU2NhbGVCeU1vZGVsID0gY3JlYXRlU2NhbGVCeU1vZGVsO1xuZXhwb3J0cy5pZkF4aXNDcm9zc1plcm8gPSBpZkF4aXNDcm9zc1plcm87XG5leHBvcnRzLmdldEF4aXNMYWJlbEludGVydmFsID0gZ2V0QXhpc0xhYmVsSW50ZXJ2YWw7XG5leHBvcnRzLmdldEZvcm1hdHRlZExhYmVscyA9IGdldEZvcm1hdHRlZExhYmVscztcbmV4cG9ydHMuZ2V0QXhpc1Jhd1ZhbHVlID0gZ2V0QXhpc1Jhd1ZhbHVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb29yZC9heGlzSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///254\n");

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Eventful = __webpack_require__(252);\n\nexports.Dispatcher = Eventful;\n\nvar env = __webpack_require__(239);\n\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event对象\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // 做向上兼容\n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzPzI0ZmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4uL21peGluL0V2ZW50ZnVsXCIpO1xuXG5leHBvcnRzLkRpc3BhdGNoZXIgPSBFdmVudGZ1bDtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2VudlwiKTtcblxuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlzRG9tTGV2ZWwyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciBNT1VTRV9FVkVOVF9SRUcgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay87XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAvLyBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpIGRvbid0IGhhdmUgZ2V0Qm91bmRpbmdSZWN0XG4gIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9O1xufSAvLyBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZVxuXG5cbmZ1bmN0aW9uIGNsaWVudFRvTG9jYWwoZWwsIGUsIG91dCwgY2FsY3VsYXRlKSB7XG4gIG91dCA9IG91dCB8fCB7fTsgLy8gQWNjb3JkaW5nIHRvIHRoZSBXM0MgV29ya2luZyBEcmFmdCwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBzaG91bGQgYmUgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gIC8vIGlzIElFLiBXZWJraXQgdXNlcyB0aGUgYm9yZGVyIGVkZ2UsIE9wZXJhIHVzZXMgdGhlIGNvbnRlbnQgZWRnZSwgYW5kIEZpcmVGb3ggZG9lc1xuICAvLyBub3Qgc3VwcG9ydCB0aGUgcHJvcGVydGllcy5cbiAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgLy8gSW4genIgcGFpbnRlci5kb20sIHBhZGRpbmcgZWRnZSBlcXVhbHMgdG8gYm9yZGVyIGVkZ2UuXG4gIC8vIEZJWE1FXG4gIC8vIFdoZW4gbW91c2Vtb3ZlIGV2ZW50IHRyaWdnZXJlZCBvbiBlYyB0b29sdGlwLCB0YXJnZXQgaXMgbm90IHpyIHBhaW50ZXIuZG9tLCBhbmRcbiAgLy8gb2Zmc2V0WC9ZIGlzIHJlbGF0aXZlIHRvIGUudGFyZ2V0LCB3aGVyZSB0aGUgY2FsY3VsYXRpb24gb2YgenJYL1kgdmlhIG9mZnNldFgvWVxuICAvLyBpcyB0b28gY29tcGxleC4gU28gY3NzLXRyYW5zZnJvbSBkb250IHN1cHBvcnQgaW4gdGhpcyBjYXNlIHRlbXBvcmFyaWx5LlxuXG4gIGlmIChjYWxjdWxhdGUgfHwgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgfSAvLyBDYXV0aW9uOiBJbiBGaXJlRm94LCBsYXllclgvbGF5ZXJZIE1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWRcbiAgLy8gYW5jZXN0b3IgZWxlbWVudCwgc28gd2Ugc2hvdWxkIG1ha2Ugc3VyZSBlbCBpcyBwb3NpdGlvbmVkIChlLmcuLCBub3QgcG9zaXRpb246c3RhdGljKS5cbiAgLy8gQlRXMSwgV2Via2l0IGRvbid0IHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIEZGIGluIG5vbi1zaW1wbGUgY2FzZXMgKGxpa2UgYWRkXG4gIC8vIHpvb20tZmFjdG9yLCBvdmVyZmxvdyAvIG9wYWNpdHkgbGF5ZXJzLCB0cmFuc2Zvcm1zIC4uLilcbiAgLy8gQlRXMiwgKGV2Lm9mZnNldFkgfHwgZXYucGFnZVkgLSAkKGV2LnRhcmdldCkub2Zmc2V0KCkudG9wKSBpcyBub3QgY29ycmVjdCBpbiBwcmVzZXJ2ZS0zZC5cbiAgLy8gPGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84NTIzI2NvbW1lbnQ6MTQ+XG4gIC8vIEJUVzMsIEluIGZmLCBvZmZzZXRYL29mZnNldFkgaXMgYWx3YXlzIDAuXG4gIGVsc2UgaWYgKGVudi5icm93c2VyLmZpcmVmb3ggJiYgZS5sYXllclggIT0gbnVsbCAmJiBlLmxheWVyWCAhPT0gZS5vZmZzZXRYKSB7XG4gICAgICBvdXQuenJYID0gZS5sYXllclg7XG4gICAgICBvdXQuenJZID0gZS5sYXllclk7XG4gICAgfSAvLyBGb3IgSUU2KywgY2hyb21lLCBzYWZhcmksIG9wZXJhLiAoV2hlbiB3aWxsIGZmIHN1cHBvcnQgb2Zmc2V0WD8pXG4gICAgZWxzZSBpZiAoZS5vZmZzZXRYICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnpyWCA9IGUub2Zmc2V0WDtcbiAgICAgICAgb3V0LnpyWSA9IGUub2Zmc2V0WTtcbiAgICAgIH0gLy8gRm9yIHNvbWUgb3RoZXIgZGV2aWNlLCBlLmcuLCBJT1Mgc2FmYXJpLlxuICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KSB7XG4gIC8vIFRoaXMgd2VsbC1rbm93biBtZXRob2QgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBjc3MgdHJhbnNmb3JtLlxuICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgb3V0LnpyWCA9IGUuY2xpZW50WCAtIGJveC5sZWZ0O1xuICBvdXQuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbn1cbi8qKlxuICog5aaC5p6c5a2Y5Zyo56ys5LiJ5pa55bWM5YWl55qE5LiA5LqbZG9t6Kem5Y+R55qE5LqL5Lu277yM5oiWdG91Y2jkuovku7bvvIzpnIDopoHovazmjaLkuIDkuIvkuovku7blnZDmoIcuXG4gKiBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGVsLCBlLCBjYWxjdWxhdGUpIHtcbiAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gIGlmIChlLnpyWCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB2YXIgZXZlbnRUeXBlID0gZS50eXBlO1xuICB2YXIgaXNUb3VjaCA9IGV2ZW50VHlwZSAmJiBldmVudFR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuXG4gIGlmICghaXNUb3VjaCkge1xuICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUsIGNhbGN1bGF0ZSk7XG4gICAgZS56ckRlbHRhID0gZS53aGVlbERlbHRhID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnRUeXBlICE9ICd0b3VjaGVuZCcgPyBlLnRhcmdldFRvdWNoZXNbMF0gOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHRvdWNoICYmIGNsaWVudFRvTG9jYWwoZWwsIHRvdWNoLCBlLCBjYWxjdWxhdGUpO1xuICB9IC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHQ7IG90aGVyd2lzZTogMDtcbiAgLy8gU2VlIGpRdWVyeTogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4gIC8vIElmIGUud2hpY2ggaGFzIGJlZW4gZGVmaW5lZCwgaWYgbWF5IGJlIHJlYWRvbmx5LFxuICAvLyBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L3doaWNoXG5cblxuICB2YXIgYnV0dG9uID0gZS5idXR0b247XG5cbiAgaWYgKGUud2hpY2ggPT0gbnVsbCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBNT1VTRV9FVkVOVF9SRUcudGVzdChlLnR5cGUpKSB7XG4gICAgZS53aGljaCA9IGJ1dHRvbiAmIDEgPyAxIDogYnV0dG9uICYgMiA/IDMgOiBidXR0b24gJiA0ID8gMiA6IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4vKipcbiAqIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24uXG4gKiBOb3RpY2U6IGRvIG5vdCBkbyB0aGF0IGluIHpyZW5kZXIuIFVwcGVyIGFwcGxpY2F0aW9uXG4gKiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9ldmVudFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gKi9cblxuXG52YXIgc3RvcCA9IGlzRG9tTGV2ZWwyID8gZnVuY3Rpb24gKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59IDogZnVuY3Rpb24gKGUpIHtcbiAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiBub3RMZWZ0TW91c2UoZSkge1xuICAvLyBJZiBlLndoaWNoIGlzIHVuZGVmaW5lZCwgY29uc2lkZXJlZCBhcyBsZWZ0IG1vdXNlIGV2ZW50LlxuICByZXR1cm4gZS53aGljaCA+IDE7XG59IC8vIOWBmuWQkeS4iuWFvOWuuVxuXG5cbmV4cG9ydHMuY2xpZW50VG9Mb2NhbCA9IGNsaWVudFRvTG9jYWw7XG5leHBvcnRzLm5vcm1hbGl6ZUV2ZW50ID0gbm9ybWFsaXplRXZlbnQ7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMuc3RvcCA9IHN0b3A7XG5leHBvcnRzLm5vdExlZnRNb3VzZSA9IG5vdExlZnRNb3VzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///255\n");

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

eval("var LRU = __webpack_require__(286);\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzPzI4NGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExSVSA9IHJlcXVpcmUoXCIuLi9jb3JlL0xSVVwiKTtcblxudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAndHJhbnNwYXJlbnQnOiBbMCwgMCwgMCwgMF0sXG4gICdhbGljZWJsdWUnOiBbMjQwLCAyNDgsIDI1NSwgMV0sXG4gICdhbnRpcXVld2hpdGUnOiBbMjUwLCAyMzUsIDIxNSwgMV0sXG4gICdhcXVhJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgJ2FxdWFtYXJpbmUnOiBbMTI3LCAyNTUsIDIxMiwgMV0sXG4gICdhenVyZSc6IFsyNDAsIDI1NSwgMjU1LCAxXSxcbiAgJ2JlaWdlJzogWzI0NSwgMjQ1LCAyMjAsIDFdLFxuICAnYmlzcXVlJzogWzI1NSwgMjI4LCAxOTYsIDFdLFxuICAnYmxhY2snOiBbMCwgMCwgMCwgMV0sXG4gICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsIDIzNSwgMjA1LCAxXSxcbiAgJ2JsdWUnOiBbMCwgMCwgMjU1LCAxXSxcbiAgJ2JsdWV2aW9sZXQnOiBbMTM4LCA0MywgMjI2LCAxXSxcbiAgJ2Jyb3duJzogWzE2NSwgNDIsIDQyLCAxXSxcbiAgJ2J1cmx5d29vZCc6IFsyMjIsIDE4NCwgMTM1LCAxXSxcbiAgJ2NhZGV0Ymx1ZSc6IFs5NSwgMTU4LCAxNjAsIDFdLFxuICAnY2hhcnRyZXVzZSc6IFsxMjcsIDI1NSwgMCwgMV0sXG4gICdjaG9jb2xhdGUnOiBbMjEwLCAxMDUsIDMwLCAxXSxcbiAgJ2NvcmFsJzogWzI1NSwgMTI3LCA4MCwgMV0sXG4gICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsIDE0OSwgMjM3LCAxXSxcbiAgJ2Nvcm5zaWxrJzogWzI1NSwgMjQ4LCAyMjAsIDFdLFxuICAnY3JpbXNvbic6IFsyMjAsIDIwLCA2MCwgMV0sXG4gICdjeWFuJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgJ2RhcmtibHVlJzogWzAsIDAsIDEzOSwgMV0sXG4gICdkYXJrY3lhbic6IFswLCAxMzksIDEzOSwgMV0sXG4gICdkYXJrZ29sZGVucm9kJzogWzE4NCwgMTM0LCAxMSwgMV0sXG4gICdkYXJrZ3JheSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtncmVlbic6IFswLCAxMDAsIDAsIDFdLFxuICAnZGFya2dyZXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJra2hha2knOiBbMTg5LCAxODMsIDEwNywgMV0sXG4gICdkYXJrbWFnZW50YSc6IFsxMzksIDAsIDEzOSwgMV0sXG4gICdkYXJrb2xpdmVncmVlbic6IFs4NSwgMTA3LCA0NywgMV0sXG4gICdkYXJrb3JhbmdlJzogWzI1NSwgMTQwLCAwLCAxXSxcbiAgJ2RhcmtvcmNoaWQnOiBbMTUzLCA1MCwgMjA0LCAxXSxcbiAgJ2RhcmtyZWQnOiBbMTM5LCAwLCAwLCAxXSxcbiAgJ2RhcmtzYWxtb24nOiBbMjMzLCAxNTAsIDEyMiwgMV0sXG4gICdkYXJrc2VhZ3JlZW4nOiBbMTQzLCAxODgsIDE0MywgMV0sXG4gICdkYXJrc2xhdGVibHVlJzogWzcyLCA2MSwgMTM5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrc2xhdGVncmV5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3R1cnF1b2lzZSc6IFswLCAyMDYsIDIwOSwgMV0sXG4gICdkYXJrdmlvbGV0JzogWzE0OCwgMCwgMjExLCAxXSxcbiAgJ2RlZXBwaW5rJzogWzI1NSwgMjAsIDE0NywgMV0sXG4gICdkZWVwc2t5Ymx1ZSc6IFswLCAxOTEsIDI1NSwgMV0sXG4gICdkaW1ncmF5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZGltZ3JleSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RvZGdlcmJsdWUnOiBbMzAsIDE0NCwgMjU1LCAxXSxcbiAgJ2ZpcmVicmljayc6IFsxNzgsIDM0LCAzNCwgMV0sXG4gICdmbG9yYWx3aGl0ZSc6IFsyNTUsIDI1MCwgMjQwLCAxXSxcbiAgJ2ZvcmVzdGdyZWVuJzogWzM0LCAxMzksIDM0LCAxXSxcbiAgJ2Z1Y2hzaWEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnZ2FpbnNib3JvJzogWzIyMCwgMjIwLCAyMjAsIDFdLFxuICAnZ2hvc3R3aGl0ZSc6IFsyNDgsIDI0OCwgMjU1LCAxXSxcbiAgJ2dvbGQnOiBbMjU1LCAyMTUsIDAsIDFdLFxuICAnZ29sZGVucm9kJzogWzIxOCwgMTY1LCAzMiwgMV0sXG4gICdncmF5JzogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAnZ3JlZW4nOiBbMCwgMTI4LCAwLCAxXSxcbiAgJ2dyZWVueWVsbG93JzogWzE3MywgMjU1LCA0NywgMV0sXG4gICdncmV5JzogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAnaG9uZXlkZXcnOiBbMjQwLCAyNTUsIDI0MCwgMV0sXG4gICdob3RwaW5rJzogWzI1NSwgMTA1LCAxODAsIDFdLFxuICAnaW5kaWFucmVkJzogWzIwNSwgOTIsIDkyLCAxXSxcbiAgJ2luZGlnbyc6IFs3NSwgMCwgMTMwLCAxXSxcbiAgJ2l2b3J5JzogWzI1NSwgMjU1LCAyNDAsIDFdLFxuICAna2hha2knOiBbMjQwLCAyMzAsIDE0MCwgMV0sXG4gICdsYXZlbmRlcic6IFsyMzAsIDIzMCwgMjUwLCAxXSxcbiAgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LCAyNDAsIDI0NSwgMV0sXG4gICdsYXduZ3JlZW4nOiBbMTI0LCAyNTIsIDAsIDFdLFxuICAnbGVtb25jaGlmZm9uJzogWzI1NSwgMjUwLCAyMDUsIDFdLFxuICAnbGlnaHRibHVlJzogWzE3MywgMjE2LCAyMzAsIDFdLFxuICAnbGlnaHRjb3JhbCc6IFsyNDAsIDEyOCwgMTI4LCAxXSxcbiAgJ2xpZ2h0Y3lhbic6IFsyMjQsIDI1NSwgMjU1LCAxXSxcbiAgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwgMjUwLCAyMTAsIDFdLFxuICAnbGlnaHRncmF5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRncmVlbic6IFsxNDQsIDIzOCwgMTQ0LCAxXSxcbiAgJ2xpZ2h0Z3JleSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0cGluayc6IFsyNTUsIDE4MiwgMTkzLCAxXSxcbiAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwgMTYwLCAxMjIsIDFdLFxuICAnbGlnaHRzZWFncmVlbic6IFszMiwgMTc4LCAxNzAsIDFdLFxuICAnbGlnaHRza3libHVlJzogWzEzNSwgMjA2LCAyNTAsIDFdLFxuICAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHNsYXRlZ3JleSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwgMTk2LCAyMjIsIDFdLFxuICAnbGlnaHR5ZWxsb3cnOiBbMjU1LCAyNTUsIDIyNCwgMV0sXG4gICdsaW1lJzogWzAsIDI1NSwgMCwgMV0sXG4gICdsaW1lZ3JlZW4nOiBbNTAsIDIwNSwgNTAsIDFdLFxuICAnbGluZW4nOiBbMjUwLCAyNDAsIDIzMCwgMV0sXG4gICdtYWdlbnRhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ21hcm9vbic6IFsxMjgsIDAsIDAsIDFdLFxuICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsIDIwNSwgMTcwLCAxXSxcbiAgJ21lZGl1bWJsdWUnOiBbMCwgMCwgMjA1LCAxXSxcbiAgJ21lZGl1bW9yY2hpZCc6IFsxODYsIDg1LCAyMTEsIDFdLFxuICAnbWVkaXVtcHVycGxlJzogWzE0NywgMTEyLCAyMTksIDFdLFxuICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsIDE3OSwgMTEzLCAxXSxcbiAgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsIDEwNCwgMjM4LCAxXSxcbiAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsIDI1MCwgMTU0LCAxXSxcbiAgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwgMjA5LCAyMDQsIDFdLFxuICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwgMjEsIDEzMywgMV0sXG4gICdtaWRuaWdodGJsdWUnOiBbMjUsIDI1LCAxMTIsIDFdLFxuICAnbWludGNyZWFtJzogWzI0NSwgMjU1LCAyNTAsIDFdLFxuICAnbWlzdHlyb3NlJzogWzI1NSwgMjI4LCAyMjUsIDFdLFxuICAnbW9jY2FzaW4nOiBbMjU1LCAyMjgsIDE4MSwgMV0sXG4gICduYXZham93aGl0ZSc6IFsyNTUsIDIyMiwgMTczLCAxXSxcbiAgJ25hdnknOiBbMCwgMCwgMTI4LCAxXSxcbiAgJ29sZGxhY2UnOiBbMjUzLCAyNDUsIDIzMCwgMV0sXG4gICdvbGl2ZSc6IFsxMjgsIDEyOCwgMCwgMV0sXG4gICdvbGl2ZWRyYWInOiBbMTA3LCAxNDIsIDM1LCAxXSxcbiAgJ29yYW5nZSc6IFsyNTUsIDE2NSwgMCwgMV0sXG4gICdvcmFuZ2VyZWQnOiBbMjU1LCA2OSwgMCwgMV0sXG4gICdvcmNoaWQnOiBbMjE4LCAxMTIsIDIxNCwgMV0sXG4gICdwYWxlZ29sZGVucm9kJzogWzIzOCwgMjMyLCAxNzAsIDFdLFxuICAncGFsZWdyZWVuJzogWzE1MiwgMjUxLCAxNTIsIDFdLFxuICAncGFsZXR1cnF1b2lzZSc6IFsxNzUsIDIzOCwgMjM4LCAxXSxcbiAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LCAxMTIsIDE0NywgMV0sXG4gICdwYXBheWF3aGlwJzogWzI1NSwgMjM5LCAyMTMsIDFdLFxuICAncGVhY2hwdWZmJzogWzI1NSwgMjE4LCAxODUsIDFdLFxuICAncGVydSc6IFsyMDUsIDEzMywgNjMsIDFdLFxuICAncGluayc6IFsyNTUsIDE5MiwgMjAzLCAxXSxcbiAgJ3BsdW0nOiBbMjIxLCAxNjAsIDIyMSwgMV0sXG4gICdwb3dkZXJibHVlJzogWzE3NiwgMjI0LCAyMzAsIDFdLFxuICAncHVycGxlJzogWzEyOCwgMCwgMTI4LCAxXSxcbiAgJ3JlZCc6IFsyNTUsIDAsIDAsIDFdLFxuICAncm9zeWJyb3duJzogWzE4OCwgMTQzLCAxNDMsIDFdLFxuICAncm95YWxibHVlJzogWzY1LCAxMDUsIDIyNSwgMV0sXG4gICdzYWRkbGVicm93bic6IFsxMzksIDY5LCAxOSwgMV0sXG4gICdzYWxtb24nOiBbMjUwLCAxMjgsIDExNCwgMV0sXG4gICdzYW5keWJyb3duJzogWzI0NCwgMTY0LCA5NiwgMV0sXG4gICdzZWFncmVlbic6IFs0NiwgMTM5LCA4NywgMV0sXG4gICdzZWFzaGVsbCc6IFsyNTUsIDI0NSwgMjM4LCAxXSxcbiAgJ3NpZW5uYSc6IFsxNjAsIDgyLCA0NSwgMV0sXG4gICdzaWx2ZXInOiBbMTkyLCAxOTIsIDE5MiwgMV0sXG4gICdza3libHVlJzogWzEzNSwgMjA2LCAyMzUsIDFdLFxuICAnc2xhdGVibHVlJzogWzEwNiwgOTAsIDIwNSwgMV0sXG4gICdzbGF0ZWdyYXknOiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICdzbGF0ZWdyZXknOiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICdzbm93JzogWzI1NSwgMjUwLCAyNTAsIDFdLFxuICAnc3ByaW5nZ3JlZW4nOiBbMCwgMjU1LCAxMjcsIDFdLFxuICAnc3RlZWxibHVlJzogWzcwLCAxMzAsIDE4MCwgMV0sXG4gICd0YW4nOiBbMjEwLCAxODAsIDE0MCwgMV0sXG4gICd0ZWFsJzogWzAsIDEyOCwgMTI4LCAxXSxcbiAgJ3RoaXN0bGUnOiBbMjE2LCAxOTEsIDIxNiwgMV0sXG4gICd0b21hdG8nOiBbMjU1LCA5OSwgNzEsIDFdLFxuICAndHVycXVvaXNlJzogWzY0LCAyMjQsIDIwOCwgMV0sXG4gICd2aW9sZXQnOiBbMjM4LCAxMzAsIDIzOCwgMV0sXG4gICd3aGVhdCc6IFsyNDUsIDIyMiwgMTc5LCAxXSxcbiAgJ3doaXRlJzogWzI1NSwgMjU1LCAyNTUsIDFdLFxuICAnd2hpdGVzbW9rZSc6IFsyNDUsIDI0NSwgMjQ1LCAxXSxcbiAgJ3llbGxvdyc6IFsyNTUsIDI1NSwgMCwgMV0sXG4gICd5ZWxsb3dncmVlbic6IFsxNTQsIDIwNSwgNTAsIDFdXG59O1xuXG5mdW5jdGlvbiBjbGFtcENzc0J5dGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDM2MC5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7XG4gIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHtcbiAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIH1cblxuICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHtcbiAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIH1cblxuICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAxO1xuICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgaCAtPSAxO1xuICB9XG5cbiAgaWYgKGggKiA2IDwgMSkge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICB9XG5cbiAgaWYgKGggKiAyIDwgMSkge1xuICAgIHJldHVybiBtMjtcbiAgfVxuXG4gIGlmIChoICogMyA8IDIpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDY7XG4gIH1cblxuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIGxlcnBOdW1iZXIoYSwgYiwgcCkge1xuICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xufVxuXG5mdW5jdGlvbiBzZXRSZ2JhKG91dCwgciwgZywgYiwgYSkge1xuICBvdXRbMF0gPSByO1xuICBvdXRbMV0gPSBnO1xuICBvdXRbMl0gPSBiO1xuICBvdXRbM10gPSBhO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBjb3B5UmdiYShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxudmFyIGNvbG9yQ2FjaGUgPSBuZXcgTFJVKDIwKTtcbnZhciBsYXN0UmVtb3ZlZEFyciA9IG51bGw7XG5cbmZ1bmN0aW9uIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgLy8gUmV1c2UgcmVtb3ZlZCBhcnJheVxuICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICBjb3B5UmdiYShsYXN0UmVtb3ZlZEFyciwgcmdiYUFycik7XG4gIH1cblxuICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCByZ2JhQXJyLnNsaWNlKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgaWYgKCFjb2xvclN0cikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJnYmFBcnIgPSByZ2JhQXJyIHx8IFtdO1xuICB2YXIgY2FjaGVkID0gY29sb3JDYWNoZS5nZXQoY29sb3JTdHIpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY29weVJnYmEocmdiYUFyciwgY2FjaGVkKTtcbiAgfSAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuXG5cbiAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnOyAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cblxuICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTsgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICBjb3B5UmdiYShyZ2JhQXJyLCBrQ1NTQ29sb3JUYWJsZVtzdHJdKTtcbiAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICByZXR1cm4gcmdiYUFycjtcbiAgfSAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cblxuXG4gIGlmIChzdHIuY2hhckF0KDApID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZjAwKSA+PiA0IHwgKGl2ICYgMHhmMDApID4+IDgsIGl2ICYgMHhmMCB8IChpdiAmIDB4ZjApID4+IDQsIGl2ICYgMHhmIHwgKGl2ICYgMHhmKSA8PCA0LCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmZjAwMDApID4+IDE2LCAoaXYgJiAweGZmMDApID4+IDgsIGl2ICYgMHhmZiwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksXG4gICAgICBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG5cbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cblxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIC8vIEZhbGwgdGhyb3VnaC5cblxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSwgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSwgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSwgYWxwaGEpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zWzNdID0gcGFyc2VDc3NGbG9hdChwYXJhbXNbM10pO1xuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gIHJldHVybjtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqL1xuXG5cbmZ1bmN0aW9uIGhzbGEycmdiYShoc2xhLCByZ2JhKSB7XG4gIHZhciBoID0gKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwOyAvLyAwIC4uIDFcbiAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cblxuICB2YXIgcyA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsxXSk7XG4gIHZhciBsID0gcGFyc2VDc3NGbG9hdChoc2xhWzJdKTtcbiAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gIHJnYmEgPSByZ2JhIHx8IFtdO1xuICBzZXRSZ2JhKHJnYmEsIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLCAxKTtcblxuICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICByZ2JhWzNdID0gaHNsYVszXTtcbiAgfVxuXG4gIHJldHVybiByZ2JhO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICovXG5cblxuZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgaWYgKCFyZ2JhKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFJHQiBmcm9tIDAgdG8gMjU1XG5cblxuICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuICB2YXIgdk1pbiA9IE1hdGgubWluKFIsIEcsIEIpOyAvLyBNaW4uIHZhbHVlIG9mIFJHQlxuXG4gIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gIHZhciBIO1xuICB2YXIgUzsgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcblxuICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICBIID0gMDtcbiAgICBTID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoTCA8IDAuNSkge1xuICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhUiA9ICgodk1heCAtIFIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFHID0gKCh2TWF4IC0gRykgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUIgPSAoKHZNYXggLSBCKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG5cbiAgICBpZiAoUiA9PT0gdk1heCkge1xuICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICB9IGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgIEggPSAxIC8gMyArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICB9IGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgIEggPSAyIC8gMyArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICB9XG5cbiAgICBpZiAoSCA8IDApIHtcbiAgICAgIEggKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoSCA+IDEpIHtcbiAgICAgIEggLT0gMTtcbiAgICB9XG4gIH1cblxuICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgaHNsYS5wdXNoKHJnYmFbM10pO1xuICB9XG5cbiAgcmV0dXJuIGhzbGE7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gbGlmdChjb2xvciwgbGV2ZWwpIHtcbiAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvckFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvckFycltpXSA9ICgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gdG9IZXgoY29sb3IpIHtcbiAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvckFycikge1xuICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICtjb2xvckFyclsyXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICB9XG59XG4vKipcbiAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbGVycCBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gKi9cblxuXG5mdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG91dCA9IG91dCB8fCBbXTtcbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICBvdXRbM10gPSBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIGZhc3RNYXBUb0NvbG9yID0gZmFzdExlcnA7XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAqIEByZXR1cm4geyhzdHJpbmd8T2JqZWN0KX0gUmVzdWx0IGNvbG9yLiBJZiBmdWxsT3V0cHV0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBsZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gcGFyc2UoY29sb3JzW2xlZnRJbmRleF0pO1xuICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoW2NsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksIGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSldLCAncmdiYScpO1xuICByZXR1cm4gZnVsbE91dHB1dCA/IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSA6IGNvbG9yO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIG1hcFRvQ29sb3IgPSBsZXJwO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBsIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IpIHtcbiAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgaCAhPSBudWxsICYmIChjb2xvclswXSA9IGNsYW1wQ3NzQW5nbGUoaCkpO1xuICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyckNvbG9yIGxpa2UgWzEyLDMzLDQ0LDAuNF1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLiAoSWYgaW5wdXQgaWxsZWdhbCwgcmV0dXJuIHVuZGVmaW5lZCkuXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuXG4gIGlmICh0eXBlID09PSAncmdiYScgfHwgdHlwZSA9PT0gJ2hzdmEnIHx8IHR5cGUgPT09ICdoc2xhJykge1xuICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgKyAnKCcgKyBjb2xvclN0ciArICcpJztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMuZmFzdExlcnAgPSBmYXN0TGVycDtcbmV4cG9ydHMuZmFzdE1hcFRvQ29sb3IgPSBmYXN0TWFwVG9Db2xvcjtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLm1hcFRvQ29sb3IgPSBtYXBUb0NvbG9yO1xuZXhwb3J0cy5tb2RpZnlIU0wgPSBtb2RpZnlIU0w7XG5leHBvcnRzLm1vZGlmeUFscGhhID0gbW9kaWZ5QWxwaGE7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///256\n");

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

eval("var clazzUtil = __webpack_require__(247);\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\nfunction Scale(setting) {\n  this._setting = setting || {};\n  /**\n   * Extent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._extent = [Infinity, -Infinity];\n  /**\n   * Step is calculated in adjustExtent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._interval = 0;\n  this.init && this.init.apply(this, arguments);\n}\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\n\n\nScale.prototype.parse = function (val) {\n  // Notice: This would be a trap here, If the implementation\n  // of this method depends on extent, and this method is used\n  // before extent set (like in dataZoom), it would be wrong.\n  // Nevertheless, parse does not depend on extent generally.\n  return val;\n};\n\nScale.prototype.getSetting = function (name) {\n  return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n  var extent = this._extent;\n  return val >= extent[0] && val <= extent[1];\n};\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.normalize = function (val) {\n  var extent = this._extent;\n\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n\n  return (val - extent[0]) / (extent[1] - extent[0]);\n};\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.scale = function (val) {\n  var extent = this._extent;\n  return val * (extent[1] - extent[0]) + extent[0];\n};\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\n\n\nScale.prototype.unionExtent = function (other) {\n  var extent = this._extent;\n  other[0] < extent[0] && (extent[0] = other[0]);\n  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power\n  // this.setExtent(extent[0], extent[1]);\n};\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\n\n\nScale.prototype.unionExtentFromData = function (data, dim) {\n  this.unionExtent(data.getDataExtent(dim, true));\n};\n/**\n * Get extent\n * @return {Array.<number>}\n */\n\n\nScale.prototype.getExtent = function () {\n  return this._extent.slice();\n};\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\n\n\nScale.prototype.setExtent = function (start, end) {\n  var thisExtent = this._extent;\n\n  if (!isNaN(start)) {\n    thisExtent[0] = start;\n  }\n\n  if (!isNaN(end)) {\n    thisExtent[1] = end;\n  }\n};\n/**\n * @return {Array.<string>}\n */\n\n\nScale.prototype.getTicksLabels = function () {\n  var labels = [];\n  var ticks = this.getTicks();\n\n  for (var i = 0; i < ticks.length; i++) {\n    labels.push(this.getLabel(ticks[i]));\n  }\n\n  return labels;\n};\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\n\n\nScale.prototype.isBlank = function () {\n  return this._isBlank;\n},\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n  this._isBlank = isBlank;\n};\nclazzUtil.enableClassExtend(Scale);\nclazzUtil.enableClassManagement(Scale, {\n  registerWhenExtend: true\n});\nvar _default = Scale;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9TY2FsZS5qcz9jOTIyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbGF6elV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9jbGF6elwiKTtcblxuLyoqXG4gKiAvLyBTY2FsZSBjbGFzcyBtYW5hZ2VtZW50XG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvU2NhbGVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ11cbiAqL1xuZnVuY3Rpb24gU2NhbGUoc2V0dGluZykge1xuICB0aGlzLl9zZXR0aW5nID0gc2V0dGluZyB8fCB7fTtcbiAgLyoqXG4gICAqIEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAvKipcbiAgICogU3RlcCBpcyBjYWxjdWxhdGVkIGluIGFkanVzdEV4dGVudFxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cbiAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuICB0aGlzLmluaXQgJiYgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHZhbCkge1xuICAvLyBOb3RpY2U6IFRoaXMgd291bGQgYmUgYSB0cmFwIGhlcmUsIElmIHRoZSBpbXBsZW1lbnRhdGlvblxuICAvLyBvZiB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIGV4dGVudCwgYW5kIHRoaXMgbWV0aG9kIGlzIHVzZWRcbiAgLy8gYmVmb3JlIGV4dGVudCBzZXQgKGxpa2UgaW4gZGF0YVpvb20pLCBpdCB3b3VsZCBiZSB3cm9uZy5cbiAgLy8gTmV2ZXJ0aGVsZXNzLCBwYXJzZSBkb2VzIG5vdCBkZXBlbmQgb24gZXh0ZW50IGdlbmVyYWxseS5cbiAgcmV0dXJuIHZhbDtcbn07XG5cblNjYWxlLnByb3RvdHlwZS5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3NldHRpbmdbbmFtZV07XG59O1xuXG5TY2FsZS5wcm90b3R5cGUuY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZSB2YWx1ZSB0byBsaW5lYXIgWzAsIDFdLCByZXR1cm4gMC41IGlmIGV4dGVudCBzcGFuIGlzIDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG5cbiAgaWYgKGV4dGVudFsxXSA9PT0gZXh0ZW50WzBdKSB7XG4gICAgcmV0dXJuIDAuNTtcbiAgfVxuXG4gIHJldHVybiAodmFsIC0gZXh0ZW50WzBdKSAvIChleHRlbnRbMV0gLSBleHRlbnRbMF0pO1xufTtcbi8qKlxuICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICByZXR1cm4gdmFsICogKGV4dGVudFsxXSAtIGV4dGVudFswXSkgKyBleHRlbnRbMF07XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3RoZXJcbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pOyAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbn07XG4vKipcbiAqIFNldCBleHRlbnQgZnJvbSBkYXRhXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLnVuaW9uRXh0ZW50RnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSkpO1xufTtcbi8qKlxuICogR2V0IGV4dGVudFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5TY2FsZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG59O1xuLyoqXG4gKiBTZXQgZXh0ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcblxuICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgIHRoaXNFeHRlbnRbMF0gPSBzdGFydDtcbiAgfVxuXG4gIGlmICghaXNOYU4oZW5kKSkge1xuICAgIHRoaXNFeHRlbnRbMV0gPSBlbmQ7XG4gIH1cbn07XG4vKipcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICovXG5cblxuU2NhbGUucHJvdG90eXBlLmdldFRpY2tzTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGFiZWxzID0gW107XG4gIHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIGxhYmVscztcbn07XG4vKipcbiAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAqL1xuXG5cblNjYWxlLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faXNCbGFuaztcbn0sXG4vKipcbiAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAqIGF4aXMgdGlja3Mgc2hvdWxkIG5vdCBiZSBkcmF3biwgd2hpY2ggaXMgbmFtZWQgJ2JsYW5rJy5cbiAqL1xuU2NhbGUucHJvdG90eXBlLnNldEJsYW5rID0gZnVuY3Rpb24gKGlzQmxhbmspIHtcbiAgdGhpcy5faXNCbGFuayA9IGlzQmxhbms7XG59O1xuY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKFNjYWxlKTtcbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoU2NhbGUsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbnZhciBfZGVmYXVsdCA9IFNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvc2NhbGUvU2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///257\n");

/***/ }),
/* 258 */
/***/ (function(module, exports) {

eval("var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config默认配置项\n * @exports zrender/config\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n/**\n * debug日志选项：catchBrushException为true下有效\n * 0 : 不生成debug数据，发布用\n * 1 : 异常抛出，调试用\n * 2 : 控制台输出，调试用\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb25maWcuanM/Mjg2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZHByID0gMTsgLy8gSWYgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG59XG4vKipcbiAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICogQGV4cG9ydHMgenJlbmRlci9jb25maWdcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogZGVidWfml6Xlv5fpgInpobnvvJpjYXRjaEJydXNoRXhjZXB0aW9u5Li6dHJ1ZeS4i+acieaViFxuICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gKiAyIDog5o6n5Yi25Y+w6L6T5Ye677yM6LCD6K+V55SoXG4gKi9cblxuXG52YXIgZGVidWdNb2RlID0gMDsgLy8gcmV0aW5hIOWxj+W5leS8mOWMllxuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbmV4cG9ydHMuZGVidWdNb2RlID0gZGVidWdNb2RlO1xuZXhwb3J0cy5kZXZpY2VQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///258\n");

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Element = __webpack_require__(281);\n\nvar BoundingRect = __webpack_require__(244);\n\n/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * 所有子孙元素是否响应鼠标事件\n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   * 获取指定 index 的儿子节点\n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * 获取指定名字的儿子节点\n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * 添加子节点到最后\n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加子节点在 nextSibling 之前\n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * 移除子节点\n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * 移除所有子节点\n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * 遍历所有子节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * 深度优先遍历所有子孙节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanM/OGQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxuLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XG4gKiAgICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAqICAgICBnLnBvc2l0aW9uWzBdID0gMTAwO1xuICogICAgIGcucG9zaXRpb25bMV0gPSAxMDA7XG4gKiAgICAgZy5hZGQobmV3IENpcmNsZSh7XG4gKiAgICAgICAgIHN0eWxlOiB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDAsXG4gKiAgICAgICAgICAgICByOiAyMCxcbiAqICAgICAgICAgfVxuICogICAgIH0pKTtcbiAqICAgICB6ci5hZGQoZyk7XG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICovXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NoaWxkcmVuID0gW107XG4gIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcbiAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbn07XG5cbkdyb3VwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyb3VwLFxuICBpc0dyb3VwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2dyb3VwJyxcblxuICAvKipcbiAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgKi9cbiAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgKi9cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcyAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICB9XG5cbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5a2Q6IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgKi9cbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgdmFyIHJlY3QgPSBudWxsO1xuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTsgLy8gVE9ET1xuICAgICAgLy8gVGhlIGJvdW5kaW5nUmVjdCBjYWNsdWF0ZWQgYnkgdHJhbnNmb3JtaW5nIG9yaWdpbmFsXG4gICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgLy8gdGhlIGFjdHVhbCBib3VuZGluZ1JlY3Qgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoYXQgbm90IGJlXG4gICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcbnZhciBfZGVmYXVsdCA9IEdyb3VwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///259\n");

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

eval("var curve = __webpack_require__(251);\n\nvar vec2 = __webpack_require__(236);\n\nvar bbox = __webpack_require__(287);\n\nvar BoundingRect = __webpack_require__(244);\n\nvar _config = __webpack_require__(258);\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcz82OWU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGJib3ggPSByZXF1aXJlKFwiLi9iYm94XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBkcHIgPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuICB0aGlzLl9zYXZlRGF0YSA9ICEobm90U2F2ZURhdGEgfHwgZmFsc2UpO1xuXG4gIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgIC8qKlxuICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cblxuICB0aGlzLl9jdHggPSBudWxsO1xufTtcbi8qKlxuICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cblxuUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcbiAgX3hpOiAwLFxuICBfeWk6IDAsXG4gIF94MDogMCxcbiAgX3kwOiAwLFxuICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgX3V4OiAwLFxuICBfdXk6IDAsXG4gIF9sZW46IDAsXG4gIF9saW5lRGFzaDogbnVsbCxcbiAgX2Rhc2hPZmZzZXQ6IDAsXG4gIF9kYXNoSWR4OiAwLFxuICBfZGFzaFN1bTogMCxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuID0gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAqL1xuICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgIH1cblxuICAgIGlmIChoYXNUeXBlZEFycmF5ICYmIHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgKi9cbiAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgIGlmICghdGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuXG4gICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICB9LFxuICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICB9LFxuICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHZhciB4ID0geDA7XG4gICAgdmFyIHkgPSB5MDtcbiAgICB2YXIgZGFzaDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIGlkeDtcbiAgICBkeCAvPSBkaXN0O1xuICAgIGR5IC89IGRpc3Q7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgd2hpbGUgKGR4ID4gMCAmJiB4IDw9IHgxIHx8IGR4IDwgMCAmJiB4ID49IHgxIHx8IGR4ID09IDAgJiYgKGR5ID4gMCAmJiB5IDw9IHkxIHx8IGR5IDwgMCAmJiB5ID49IHkxKSkge1xuICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDsgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcblxuICAgICAgaWYgKGR4ID4gMCAmJiB4IDwgeDAgfHwgZHggPCAwICYmIHggPiB4MCB8fCBkeSA+IDAgJiYgeSA8IHkwIHx8IGR5IDwgMCAmJiB5ID4geTApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpKTtcbiAgICB9IC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cblxuXG4gICAgZHggPSB4IC0geDE7XG4gICAgZHkgPSB5IC0geTE7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgdmFyIHQ7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtOyAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuXG4gICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0gLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuXG5cbiAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcblxuICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICB3aGlsZSAodCA8PSAxKSB7XG4gICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7IC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG5cbiAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpIDogY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcbiAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgIH0gLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuXG5cbiAgICBpZHggJSAyICE9PSAwICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICBkeCA9IHgzIC0geDtcbiAgICBkeSA9IHkzIC0geTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgdmFyIHgzID0geDI7XG4gICAgdmFyIHkzID0geTI7XG4gICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgKi9cbiAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuXG4gICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciB5aSA9IDA7XG4gICAgdmFyIHgwID0gMDtcbiAgICB2YXIgeTAgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHhpLCB5aTtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICB5aSA9IGRbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHhpLCB5aSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgIHkgPSBkW2krK107IC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuXG4gICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHRoZXRhICsgZFRoZXRhO1xuXG4gICAgICAgICAgaWYgKGlzRWxsaXBzZSkge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICB5MCA9IHlpID0gZFtpICsgMV07XG4gICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUGF0aFByb3h5LkNNRCA9IENNRDtcbnZhciBfZGVmYXVsdCA9IFBhdGhQcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///260\n");

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\n// TODO Parse shadow style\n// TODO Only shallow path support\nfunction _default(properties) {\n  // Normalize\n  for (var i = 0; i < properties.length; i++) {\n    if (!properties[i][1]) {\n      properties[i][1] = properties[i][0];\n    }\n  }\n\n  return function (model, excludes, includes) {\n    var style = {};\n\n    for (var i = 0; i < properties.length; i++) {\n      var propName = properties[i][1];\n\n      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {\n        continue;\n      }\n\n      var val = model.getShallow(propName);\n\n      if (val != null) {\n        style[properties[i][0]] = val;\n      }\n    }\n\n    return style;\n  };\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanM/ZTJiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxuLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuZnVuY3Rpb24gX2RlZmF1bHQocHJvcGVydGllcykge1xuICAvLyBOb3JtYWxpemVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzW2ldWzFdKSB7XG4gICAgICBwcm9wZXJ0aWVzW2ldWzFdID0gcHJvcGVydGllc1tpXVswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsLCBleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydGllc1tpXVsxXTtcblxuICAgICAgaWYgKGV4Y2x1ZGVzICYmIHpyVXRpbC5pbmRleE9mKGV4Y2x1ZGVzLCBwcm9wTmFtZSkgPj0gMCB8fCBpbmNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihpbmNsdWRlcywgcHJvcE5hbWUpIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IG1vZGVsLmdldFNoYWxsb3cocHJvcE5hbWUpO1xuXG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydGllc1tpXVswXV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9tYWtlU3R5bGVNYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///261\n");

/***/ }),
/* 262 */,
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar Model = __webpack_require__(246);\n\nvar DataDiffer = __webpack_require__(275);\n\nvar modelUtil = __webpack_require__(234);\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\nvar dataCtors = {\n  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,\n  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];\n\nfunction transferProperties(a, b) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n    if (b.hasOwnProperty(propName)) {\n      a[propName] = b[propName];\n    }\n  });\n  a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n  this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n  return this._array.length;\n};\n\nDefaultDataProvider.prototype.getItem = function (idx) {\n  return this._array[idx];\n};\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimensionName;\n    var dimensionInfo = {};\n\n    if (typeof dimensions[i] === 'string') {\n      dimensionName = dimensions[i];\n      dimensionInfo = {\n        name: dimensionName,\n        coordDim: dimensionName,\n        coordDimIndex: 0,\n        stackable: false,\n        // Type can be 'float', 'int', 'number'\n        // Default is number, Precision of float may not enough\n        type: 'number'\n      };\n    } else {\n      dimensionInfo = dimensions[i];\n      dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'number';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this.indices = [];\n  /**\n   * Data storage\n   * @type {Object.<key, TypedArray|Array>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * @param {module:echarts/data/List}\n   */\n\n  this.stackedOn = null;\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  data = data || [];\n  var isDataArray = zrUtil.isArray(data);\n\n  if (isDataArray) {\n    data = new DefaultDataProvider(data);\n  }\n\n  this._rawData = data; // Clear\n\n  var storage = this._storage = {};\n  var indices = this.indices = [];\n  var dimensions = this.dimensions;\n  var dimensionInfoMap = this._dimensionInfos;\n  var size = data.count();\n  var idList = [];\n  var nameRepeatCount = {};\n  var nameDimIdx;\n  nameList = nameList || []; // Init storage\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = dimensionInfoMap[dimensions[i]];\n    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n    var DataCtor = dataCtors[dimInfo.type];\n    storage[dimensions[i]] = new DataCtor(size);\n  }\n\n  var self = this;\n\n  if (!dimValueGetter) {\n    self.hasItemOption = false;\n  } // Default dim value getter\n\n\n  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }\n\n    if (modelUtil.isDataItemOption(dataItem)) {\n      self.hasItemOption = true;\n    }\n\n    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n    : value, dimensionInfoMap[dimName]);\n  };\n\n  for (var i = 0; i < size; i++) {\n    // NOTICE: Try not to write things into dataItem\n    var dataItem = data.getItem(i); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of cateogry\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // Store the data by dimensions\n\n    for (var k = 0; k < dimensions.length; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim]; // PENDING NULL is empty or zero\n\n      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n    }\n\n    indices.push(i);\n  } // Use the name in option and create id\n\n\n  for (var i = 0; i < size; i++) {\n    var dataItem = data.getItem(i);\n\n    if (!nameList[i] && dataItem) {\n      if (dataItem.name != null) {\n        nameList[i] = dataItem.name;\n      } else if (nameDimIdx != null) {\n        nameList[i] = storage[dimensions[nameDimIdx]][i];\n      }\n    }\n\n    var name = nameList[i] || ''; // Try using the id in option\n\n    var id = dataItem && dataItem.id;\n\n    if (!id && name) {\n      // Use name as id and add counter to avoid same name\n      nameRepeatCount[name] = nameRepeatCount[name] || 0;\n      id = name;\n\n      if (nameRepeatCount[name] > 0) {\n        id += '__ec__' + nameRepeatCount[name];\n      }\n\n      nameRepeatCount[name]++;\n    }\n\n    id && (idList[i] = id);\n  }\n\n  this._nameList = nameList;\n  this._idList = idList;\n};\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this.indices.length;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx, stack) {\n  var storage = this._storage;\n  var dataIndex = this.indices[idx]; // If value not exists\n\n  if (dataIndex == null || !storage[dim]) {\n    return NaN;\n  }\n\n  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable\n\n  if (stack) {\n    var dimensionInfo = this._dimensionInfos[dim];\n\n    if (dimensionInfo && dimensionInfo.stackable) {\n      var stackedOn = this.stackedOn;\n\n      while (stackedOn) {\n        // Get no stacked data of stacked on\n        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data\n\n        if (value >= 0 && stackedValue > 0 || // Positive stack\n        value <= 0 && stackedValue < 0 // Negative stack\n        ) {\n            value += stackedValue;\n          }\n\n        stackedOn = stackedOn.stackedOn;\n      }\n    }\n  }\n\n  return value;\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx, stack) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx, stack));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dimensions = this.dimensions;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\n\n\nlistProto.getDataExtent = function (dim, stack, filter) {\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var dimInfo = this.getDimensionInfo(dim);\n  stack = dimInfo && dimInfo.stackable && stack;\n  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n  var value;\n\n  if (dimExtent) {\n    return dimExtent;\n  } // var dimInfo = this._dimensionInfos[dim];\n\n\n  if (dimData) {\n    var min = Infinity;\n    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      value = this.get(dim, i, stack); // FIXME\n      // if (isOrdinal && typeof value === 'string') {\n      //     value = zrUtil.indexOf(dimData, value);\n      // }\n\n      if (!filter || filter(value, dim, i)) {\n        value < min && (min = value);\n        value > max && (max = value);\n      }\n    }\n\n    return this._extent[dim + !!stack] = [min, max];\n  } else {\n    return [Infinity, -Infinity];\n  }\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getSum = function (dim, stack) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i, stack);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\n\n\nlistProto.indexOf = function (dim, value) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var indices = this.indices;\n\n  if (dimData) {\n    for (var i = 0, len = indices.length; i < len; i++) {\n      var rawIndex = indices[i];\n\n      if (dimData[rawIndex] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  var indices = this.indices;\n  var nameList = this._nameList;\n\n  for (var i = 0, len = indices.length; i < len; i++) {\n    var rawIndex = indices[i];\n\n    if (nameList[rawIndex] === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  // Indices are ascending\n  var indices = this.indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = indices.length - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i, stack);\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = function (idx) {\n  var rawIdx = this.indices[idx];\n  return rawIdx == null ? -1 : rawIdx;\n};\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  return this._rawData.getItem(this.getRawIndex(idx));\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  return this._nameList[this.indices[idx]] || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n};\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, stack, context) {\n  if (typeof dims === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dims;\n    dims = [];\n  }\n\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var value = [];\n  var dimSize = dims.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i, stack), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n        break;\n\n      default:\n        for (var k = 0; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i, stack);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var newIndices = [];\n  var value = [];\n  var dimSize = dimensions.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    var keep; // Simple optimization\n\n    if (!dimSize) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this.get(dimensions[k], i, stack);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices.push(indices[i]);\n    }\n  }\n\n  this.indices = newIndices; // Reset data extent\n\n  this._extent = {};\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, stack, context);\n  return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    var dimStore = originalStorage[dim];\n\n    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n      storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n    } else {\n      // Direct reference for other dimensions\n      storage[dim] = originalStorage[dim];\n    }\n  }\n\n  return list;\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, stack, context) {\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  var indices = list.indices = this.indices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  this.each(dimensions, function () {\n    var idx = arguments[arguments.length - 1];\n    var retValue = cb && cb.apply(this, arguments);\n\n    if (retValue != null) {\n      // a number\n      if (typeof retValue === 'number') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var dimStore = storage[dim];\n        var rawIdx = indices[idx];\n\n        if (dimStore) {\n          dimStore[rawIdx] = retValue[i];\n        }\n      }\n    }\n  }, stack, context);\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var storage = this._storage;\n  var targetStorage = list._storage;\n  var originalIndices = this.indices;\n  var indices = list.indices = [];\n  var frameValues = [];\n  var frameIndices = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count(); // Copy data from original data\n\n  for (var i = 0; i < storage[dimension].length; i++) {\n    targetStorage[dimension][i] = storage[dimension][i];\n  }\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var idx = originalIndices[i + k];\n      frameValues[k] = dimStore[idx];\n      frameIndices[k] = idx;\n    }\n\n    var value = sampleValue(frameValues);\n    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data\n\n    dimStore[idx] = value;\n    indices.push(idx);\n  }\n\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  idx = this.indices[idx];\n  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var idList = this._idList;\n  var otherIdList = otherList && otherList._idList;\n  var val; // Use prefix to avoid index to be the same as otherIdList[idx],\n  // which will cause weird udpate animation.\n\n  var prefix = 'e\\0\\0';\n  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n    return (val = otherIdList[idx]) != null ? val : prefix + idx;\n  }, function (idx) {\n    return (val = idList[idx]) != null ? val : prefix + idx;\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function () {\n  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n  var list = new List(dimensionInfoList, this.hostModel); // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  list.indices = this.indices.slice();\n\n  if (this._extent) {\n    list._extent = zrUtil.extend({}, this._extent);\n  }\n\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\nvar _default = List;\nmodule.exports = _default;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9kYXRhL0xpc3QuanM/YjA5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL01vZGVsXCIpO1xuXG52YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoXCIuL0RhdGFEaWZmZXJcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxuLyoqXG4gKiBMaXN0IGZvciBkYXRhIHN0b3JhZ2VcbiAqIEBtb2R1bGUgZWNoYXJ0cy9kYXRhL0xpc3RcbiAqL1xudmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xudmFyIFVOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xudmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgPT09IFVOREVGSU5FRCA/IGdsb2JhbCA6IHdpbmRvdztcbnZhciBkYXRhQ3RvcnMgPSB7XG4gICdmbG9hdCc6IHR5cGVvZiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5ID09PSBVTkRFRklORUQgPyBBcnJheSA6IGdsb2JhbE9iai5GbG9hdDY0QXJyYXksXG4gICdpbnQnOiB0eXBlb2YgZ2xvYmFsT2JqLkludDMyQXJyYXkgPT09IFVOREVGSU5FRCA/IEFycmF5IDogZ2xvYmFsT2JqLkludDMyQXJyYXksXG4gIC8vIE9yZGluYWwgZGF0YSB0eXBlIGNhbiBiZSBzdHJpbmcgb3IgaW50XG4gICdvcmRpbmFsJzogQXJyYXksXG4gICdudW1iZXInOiBBcnJheSxcbiAgJ3RpbWUnOiBBcnJheVxufTtcbnZhciBUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUyA9IFsnc3RhY2tlZE9uJywgJ2hhc0l0ZW1PcHRpb24nLCAnX25hbWVMaXN0JywgJ19pZExpc3QnLCAnX3Jhd0RhdGEnXTtcblxuZnVuY3Rpb24gdHJhbnNmZXJQcm9wZXJ0aWVzKGEsIGIpIHtcbiAgenJVdGlsLmVhY2goVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMuY29uY2F0KGIuX193cmFwcGVkTWV0aG9kcyB8fCBbXSksIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgYVtwcm9wTmFtZV0gPSBiW3Byb3BOYW1lXTtcbiAgICB9XG4gIH0pO1xuICBhLl9fd3JhcHBlZE1ldGhvZHMgPSBiLl9fd3JhcHBlZE1ldGhvZHM7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YUFycmF5KSB7XG4gIHRoaXMuX2FycmF5ID0gZGF0YUFycmF5IHx8IFtdO1xufVxuXG5EZWZhdWx0RGF0YVByb3ZpZGVyLnByb3RvdHlwZS5wdXJlID0gZmFsc2U7XG5cbkRlZmF1bHREYXRhUHJvdmlkZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkubGVuZ3RoO1xufTtcblxuRGVmYXVsdERhdGFQcm92aWRlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5W2lkeF07XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn0gZGltZW5zaW9uc1xuICogICAgICBGb3IgZXhhbXBsZSwgWydzb21lRGltTmFtZScsIHtuYW1lOiAnc29tZURpbU5hbWUnLCB0eXBlOiAnc29tZURpbVR5cGUnfSwgLi4uXS5cbiAqICAgICAgRGltZW5zaW9ucyBzaG91bGQgYmUgY29uY3JldGUgbmFtZXMgbGlrZSB4LCB5LCB6LCBsbmcsIGxhdCwgYW5nbGUsIHJhZGl1c1xuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gaG9zdE1vZGVsXG4gKi9cblxuXG52YXIgTGlzdCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBob3N0TW9kZWwpIHtcbiAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgWyd4JywgJ3knXTtcbiAgdmFyIGRpbWVuc2lvbkluZm9zID0ge307XG4gIHZhciBkaW1lbnNpb25OYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaW1lbnNpb25OYW1lO1xuICAgIHZhciBkaW1lbnNpb25JbmZvID0ge307XG5cbiAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uc1tpXTtcbiAgICAgIGRpbWVuc2lvbkluZm8gPSB7XG4gICAgICAgIG5hbWU6IGRpbWVuc2lvbk5hbWUsXG4gICAgICAgIGNvb3JkRGltOiBkaW1lbnNpb25OYW1lLFxuICAgICAgICBjb29yZERpbUluZGV4OiAwLFxuICAgICAgICBzdGFja2FibGU6IGZhbHNlLFxuICAgICAgICAvLyBUeXBlIGNhbiBiZSAnZmxvYXQnLCAnaW50JywgJ251bWJlcidcbiAgICAgICAgLy8gRGVmYXVsdCBpcyBudW1iZXIsIFByZWNpc2lvbiBvZiBmbG9hdCBtYXkgbm90IGVub3VnaFxuICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGltZW5zaW9uSW5mbyA9IGRpbWVuc2lvbnNbaV07XG4gICAgICBkaW1lbnNpb25OYW1lID0gZGltZW5zaW9uSW5mby5uYW1lO1xuICAgICAgZGltZW5zaW9uSW5mby50eXBlID0gZGltZW5zaW9uSW5mby50eXBlIHx8ICdudW1iZXInO1xuXG4gICAgICBpZiAoIWRpbWVuc2lvbkluZm8uY29vcmREaW0pIHtcbiAgICAgICAgZGltZW5zaW9uSW5mby5jb29yZERpbSA9IGRpbWVuc2lvbk5hbWU7XG4gICAgICAgIGRpbWVuc2lvbkluZm8uY29vcmREaW1JbmRleCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGltZW5zaW9uSW5mby5vdGhlckRpbXMgPSBkaW1lbnNpb25JbmZvLm90aGVyRGltcyB8fCB7fTtcbiAgICBkaW1lbnNpb25OYW1lcy5wdXNoKGRpbWVuc2lvbk5hbWUpO1xuICAgIGRpbWVuc2lvbkluZm9zW2RpbWVuc2lvbk5hbWVdID0gZGltZW5zaW9uSW5mbztcbiAgfVxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICovXG5cblxuICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25OYW1lcztcbiAgLyoqXG4gICAqIEluZm9tYXRpb24gb2YgZWFjaCBkYXRhIGRpbWVuc2lvbiwgbGlrZSBkYXRhIHR5cGUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2RpbWVuc2lvbkluZm9zID0gZGltZW5zaW9uSW5mb3M7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAqL1xuXG4gIHRoaXMuaG9zdE1vZGVsID0gaG9zdE1vZGVsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cblxuICB0aGlzLmRhdGFUeXBlO1xuICAvKipcbiAgICogSW5kaWNlcyBzdG9yZXMgdGhlIGluZGljZXMgb2YgZGF0YSBzdWJzZXQgYWZ0ZXIgZmlsdGVyZWQuXG4gICAqIFRoaXMgZGF0YSBzdWJzZXQgd2lsbCBiZSB1c2VkIGluIGNoYXJ0LlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmluZGljZXMgPSBbXTtcbiAgLyoqXG4gICAqIERhdGEgc3RvcmFnZVxuICAgKiBAdHlwZSB7T2JqZWN0LjxrZXksIFR5cGVkQXJyYXl8QXJyYXk+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9zdG9yYWdlID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG4gIHRoaXMuX25hbWVMaXN0ID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG4gIHRoaXMuX2lkTGlzdCA9IFtdO1xuICAvKipcbiAgICogTW9kZWxzIG9mIGRhdGEgb3B0aW9uIGlzIHN0b3JlZCBzcGFyc2UgZm9yIG9wdGltaXppbmcgbWVtb3J5IGNvc3RcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX29wdGlvbk1vZGVscyA9IFtdO1xuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAqL1xuXG4gIHRoaXMuc3RhY2tlZE9uID0gbnVsbDtcbiAgLyoqXG4gICAqIEdsb2JhbCB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Zpc3VhbCA9IHt9O1xuICAvKipcbiAgICogR2xvYmVsIGxheW91dCBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9sYXlvdXQgPSB7fTtcbiAgLyoqXG4gICAqIEl0ZW0gdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2l0ZW1WaXN1YWxzID0gW107XG4gIC8qKlxuICAgKiBJdGVtIGxheW91dCBwcm9wZXJ0aWVzIGFmdGVyIGxheW91dFxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2l0ZW1MYXlvdXRzID0gW107XG4gIC8qKlxuICAgKiBHcmFwaGljIGVsZW1uZW50c1xuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9ncmFwaGljRWxzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5fE9iamVjdD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Jhd0RhdGE7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9leHRlbnQ7XG59O1xuXG52YXIgbGlzdFByb3RvID0gTGlzdC5wcm90b3R5cGU7XG5saXN0UHJvdG8udHlwZSA9ICdsaXN0Jztcbi8qKlxuICogSWYgZWFjaCBkYXRhIGl0ZW0gaGFzIGl0J3Mgb3duIG9wdGlvblxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblxubGlzdFByb3RvLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuLyoqXG4gKiBHZXQgZGltZW5zaW9uIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGltXG4gKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gKiAgICAgICAgT3IgYSBvcmRpbmFsIG51bWJlci4gRm9yIGV4YW1wbGUgZ2V0RGltZW5zaW9uSW5mbygwKSB3aWxsIHJldHVybiAneCcgb3IgJ2xuZycgb3IgJ3JhZGl1cydcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29uY3JldGUgZGltIG5hbWUuXG4gKi9cblxubGlzdFByb3RvLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgaWYgKCFpc05hTihkaW0pKSB7XG4gICAgZGltID0gdGhpcy5kaW1lbnNpb25zW2RpbV0gfHwgZGltO1xuICB9XG5cbiAgcmV0dXJuIGRpbTtcbn07XG4vKipcbiAqIEdldCB0eXBlIGFuZCBzdGFja2FibGUgaW5mbyBvZiBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAqICAgICAgICBEaW1lbnNpb24gY2FuIGJlIGNvbmNyZXRlIG5hbWVzIGxpa2UgeCwgeSwgeiwgbG5nLCBsYXQsIGFuZ2xlLCByYWRpdXNcbiAqICAgICAgICBPciBhIG9yZGluYWwgbnVtYmVyLiBGb3IgZXhhbXBsZSBnZXREaW1lbnNpb25JbmZvKDApIHdpbGwgcmV0dXJuICd4JyBvciAnbG5nJyBvciAncmFkaXVzJ1xuICovXG5cblxubGlzdFByb3RvLmdldERpbWVuc2lvbkluZm8gPSBmdW5jdGlvbiAoZGltKSB7XG4gIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fZGltZW5zaW9uSW5mb3NbdGhpcy5nZXREaW1lbnNpb24oZGltKV0pO1xufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBmcm9tIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxudW1iZXJ8QXJyYXk+fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbbmFtZUxpc3RdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGltVmFsdWVHZXR0ZXJdIChkYXRhSXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkgPT4gbnVtYmVyXG4gKi9cblxuXG5saXN0UHJvdG8uaW5pdERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgbmFtZUxpc3QsIGRpbVZhbHVlR2V0dGVyKSB7XG4gIGRhdGEgPSBkYXRhIHx8IFtdO1xuICB2YXIgaXNEYXRhQXJyYXkgPSB6clV0aWwuaXNBcnJheShkYXRhKTtcblxuICBpZiAoaXNEYXRhQXJyYXkpIHtcbiAgICBkYXRhID0gbmV3IERlZmF1bHREYXRhUHJvdmlkZXIoZGF0YSk7XG4gIH1cblxuICB0aGlzLl9yYXdEYXRhID0gZGF0YTsgLy8gQ2xlYXJcblxuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXMgPSBbXTtcbiAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gIHZhciBkaW1lbnNpb25JbmZvTWFwID0gdGhpcy5fZGltZW5zaW9uSW5mb3M7XG4gIHZhciBzaXplID0gZGF0YS5jb3VudCgpO1xuICB2YXIgaWRMaXN0ID0gW107XG4gIHZhciBuYW1lUmVwZWF0Q291bnQgPSB7fTtcbiAgdmFyIG5hbWVEaW1JZHg7XG4gIG5hbWVMaXN0ID0gbmFtZUxpc3QgfHwgW107IC8vIEluaXQgc3RvcmFnZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1lbnNpb25zW2ldXTtcbiAgICBkaW1JbmZvLm90aGVyRGltcy5pdGVtTmFtZSA9PT0gMCAmJiAobmFtZURpbUlkeCA9IGkpO1xuICAgIHZhciBEYXRhQ3RvciA9IGRhdGFDdG9yc1tkaW1JbmZvLnR5cGVdO1xuICAgIHN0b3JhZ2VbZGltZW5zaW9uc1tpXV0gPSBuZXcgRGF0YUN0b3Ioc2l6ZSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFkaW1WYWx1ZUdldHRlcikge1xuICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IGZhbHNlO1xuICB9IC8vIERlZmF1bHQgZGltIHZhbHVlIGdldHRlclxuXG5cbiAgZGltVmFsdWVHZXR0ZXIgPSBkaW1WYWx1ZUdldHRlciB8fCBmdW5jdGlvbiAoZGF0YUl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSk7IC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cblxuICAgIGlmIChtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbihkYXRhSXRlbSkpIHtcbiAgICAgIHNlbGYuaGFzSXRlbU9wdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsVXRpbC5jb252ZXJEYXRhVmFsdWUodmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlW2RpbUluZGV4XSAvLyBJZiB2YWx1ZSBpcyBhIHNpbmdsZSBudW1iZXIgb3Igc29tZXRoaW5nIGVsc2Ugbm90IGFycmF5LlxuICAgIDogdmFsdWUsIGRpbWVuc2lvbkluZm9NYXBbZGltTmFtZV0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgLy8gTk9USUNFOiBUcnkgbm90IHRvIHdyaXRlIHRoaW5ncyBpbnRvIGRhdGFJdGVtXG4gICAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRJdGVtKGkpOyAvLyBFYWNoIGRhdGEgaXRlbSBpcyB2YWx1ZVxuICAgIC8vIFsxLCAyXVxuICAgIC8vIDJcbiAgICAvLyBCYXIgY2hhcnQsIGxpbmUgY2hhcnQgd2hpY2ggdXNlcyBjYXRlZ29yeSBheGlzXG4gICAgLy8gb25seSBnaXZlcyB0aGUgJ3knIHZhbHVlLiAneCcgdmFsdWUgaXMgdGhlIGluZGljZXMgb2YgY2F0ZW9ncnlcbiAgICAvLyBVc2UgYSB0ZW1wVmFsdWUgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZSB0byBiZSBhICh4LCB5KSB2YWx1ZVxuICAgIC8vIFN0b3JlIHRoZSBkYXRhIGJ5IGRpbWVuc2lvbnNcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltZW5zaW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNba107XG4gICAgICB2YXIgZGltU3RvcmFnZSA9IHN0b3JhZ2VbZGltXTsgLy8gUEVORElORyBOVUxMIGlzIGVtcHR5IG9yIHplcm9cblxuICAgICAgZGltU3RvcmFnZVtpXSA9IGRpbVZhbHVlR2V0dGVyKGRhdGFJdGVtLCBkaW0sIGksIGspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpKTtcbiAgfSAvLyBVc2UgdGhlIG5hbWUgaW4gb3B0aW9uIGFuZCBjcmVhdGUgaWRcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRJdGVtKGkpO1xuXG4gICAgaWYgKCFuYW1lTGlzdFtpXSAmJiBkYXRhSXRlbSkge1xuICAgICAgaWYgKGRhdGFJdGVtLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lTGlzdFtpXSA9IGRhdGFJdGVtLm5hbWU7XG4gICAgICB9IGVsc2UgaWYgKG5hbWVEaW1JZHggIT0gbnVsbCkge1xuICAgICAgICBuYW1lTGlzdFtpXSA9IHN0b3JhZ2VbZGltZW5zaW9uc1tuYW1lRGltSWR4XV1baV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBuYW1lTGlzdFtpXSB8fCAnJzsgLy8gVHJ5IHVzaW5nIHRoZSBpZCBpbiBvcHRpb25cblxuICAgIHZhciBpZCA9IGRhdGFJdGVtICYmIGRhdGFJdGVtLmlkO1xuXG4gICAgaWYgKCFpZCAmJiBuYW1lKSB7XG4gICAgICAvLyBVc2UgbmFtZSBhcyBpZCBhbmQgYWRkIGNvdW50ZXIgdG8gYXZvaWQgc2FtZSBuYW1lXG4gICAgICBuYW1lUmVwZWF0Q291bnRbbmFtZV0gPSBuYW1lUmVwZWF0Q291bnRbbmFtZV0gfHwgMDtcbiAgICAgIGlkID0gbmFtZTtcblxuICAgICAgaWYgKG5hbWVSZXBlYXRDb3VudFtuYW1lXSA+IDApIHtcbiAgICAgICAgaWQgKz0gJ19fZWNfXycgKyBuYW1lUmVwZWF0Q291bnRbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSsrO1xuICAgIH1cblxuICAgIGlkICYmIChpZExpc3RbaV0gPSBpZCk7XG4gIH1cblxuICB0aGlzLl9uYW1lTGlzdCA9IG5hbWVMaXN0O1xuICB0aGlzLl9pZExpc3QgPSBpZExpc3Q7XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmluZGljZXMubGVuZ3RoO1xufTtcbi8qKlxuICogR2V0IHZhbHVlLiBSZXR1cm4gTmFOIGlmIGlkeCBpcyBvdXQgb2YgcmFuZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltIERpbSBtdXN0IGJlIGNvbmNyZXRlIG5hbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGRpbSwgaWR4LCBzdGFjaykge1xuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHZhciBkYXRhSW5kZXggPSB0aGlzLmluZGljZXNbaWR4XTsgLy8gSWYgdmFsdWUgbm90IGV4aXN0c1xuXG4gIGlmIChkYXRhSW5kZXggPT0gbnVsbCB8fCAhc3RvcmFnZVtkaW1dKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHN0b3JhZ2VbZGltXVtkYXRhSW5kZXhdOyAvLyBGSVhNRSBvcmRpbmFsIGRhdGEgdHlwZSBpcyBub3Qgc3RhY2thYmxlXG5cbiAgaWYgKHN0YWNrKSB7XG4gICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuXG4gICAgaWYgKGRpbWVuc2lvbkluZm8gJiYgZGltZW5zaW9uSW5mby5zdGFja2FibGUpIHtcbiAgICAgIHZhciBzdGFja2VkT24gPSB0aGlzLnN0YWNrZWRPbjtcblxuICAgICAgd2hpbGUgKHN0YWNrZWRPbikge1xuICAgICAgICAvLyBHZXQgbm8gc3RhY2tlZCBkYXRhIG9mIHN0YWNrZWQgb25cbiAgICAgICAgdmFyIHN0YWNrZWRWYWx1ZSA9IHN0YWNrZWRPbi5nZXQoZGltLCBpZHgpOyAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGFcblxuICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiBzdGFja2VkVmFsdWUgPiAwIHx8IC8vIFBvc2l0aXZlIHN0YWNrXG4gICAgICAgIHZhbHVlIDw9IDAgJiYgc3RhY2tlZFZhbHVlIDwgMCAvLyBOZWdhdGl2ZSBzdGFja1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHN0YWNrZWRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBHZXQgdmFsdWUgZm9yIG11bHRpIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbZGltZW5zaW9uc10gSWYgaWdub3JlZCwgdXNpbmcgYWxsIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0VmFsdWVzID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGlkeCwgc3RhY2spIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGlmICghenJVdGlsLmlzQXJyYXkoZGltZW5zaW9ucykpIHtcbiAgICBzdGFjayA9IGlkeDtcbiAgICBpZHggPSBkaW1lbnNpb25zO1xuICAgIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGltZW5zaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhbHVlcy5wdXNoKHRoaXMuZ2V0KGRpbWVuc2lvbnNbaV0sIGlkeCwgc3RhY2spKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59O1xuLyoqXG4gKiBJZiB2YWx1ZSBpcyBOYU4uIElubGN1ZGluZyAnLSdcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5oYXNWYWx1ZSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gIHZhciBkaW1lbnNpb25JbmZvcyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCAvLyBPcmRpbmFsIHR5cGUgY2FuIGJlIHN0cmluZyBvciBudW1iZXJcbiAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25zW2ldXS50eXBlICE9PSAnb3JkaW5hbCcgJiYgaXNOYU4odGhpcy5nZXQoZGltZW5zaW9uc1tpXSwgaWR4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIEdldCBleHRlbnQgb2YgZGF0YSBpbiBvbmUgZGltZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJcbiAqL1xuXG5cbmxpc3RQcm90by5nZXREYXRhRXh0ZW50ID0gZnVuY3Rpb24gKGRpbSwgc3RhY2ssIGZpbHRlcikge1xuICBkaW0gPSB0aGlzLmdldERpbWVuc2lvbihkaW0pO1xuICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgdmFyIGRpbUluZm8gPSB0aGlzLmdldERpbWVuc2lvbkluZm8oZGltKTtcbiAgc3RhY2sgPSBkaW1JbmZvICYmIGRpbUluZm8uc3RhY2thYmxlICYmIHN0YWNrO1xuICB2YXIgZGltRXh0ZW50ID0gKHRoaXMuX2V4dGVudCB8fCAodGhpcy5fZXh0ZW50ID0ge30pKVtkaW0gKyAhIXN0YWNrXTtcbiAgdmFyIHZhbHVlO1xuXG4gIGlmIChkaW1FeHRlbnQpIHtcbiAgICByZXR1cm4gZGltRXh0ZW50O1xuICB9IC8vIHZhciBkaW1JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcblxuXG4gIGlmIChkaW1EYXRhKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7IC8vIHZhciBpc09yZGluYWwgPSBkaW1JbmZvLnR5cGUgPT09ICdvcmRpbmFsJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTsgLy8gRklYTUVcbiAgICAgIC8vIGlmIChpc09yZGluYWwgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gICAgIHZhbHVlID0genJVdGlsLmluZGV4T2YoZGltRGF0YSwgdmFsdWUpO1xuICAgICAgLy8gfVxuXG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIodmFsdWUsIGRpbSwgaSkpIHtcbiAgICAgICAgdmFsdWUgPCBtaW4gJiYgKG1pbiA9IHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPiBtYXggJiYgKG1heCA9IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZXh0ZW50W2RpbSArICEhc3RhY2tdID0gW21pbiwgbWF4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICB9XG59O1xuLyoqXG4gKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICovXG5cblxubGlzdFByb3RvLmdldFN1bSA9IGZ1bmN0aW9uIChkaW0sIHN0YWNrKSB7XG4gIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICB2YXIgc3VtID0gMDtcblxuICBpZiAoZGltRGF0YSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoZGltLCBpLCBzdGFjayk7XG5cbiAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG4vLyBGSVhNRSBQcmVjaXNpb24gb2YgZmxvYXQgdmFsdWVcblxuXG5saXN0UHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlKSB7XG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gIGlmIChkaW1EYXRhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciByYXdJbmRleCA9IGluZGljZXNbaV07XG5cbiAgICAgIGlmIChkaW1EYXRhW3Jhd0luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5pbmRleE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciByYXdJbmRleCA9IGluZGljZXNbaV07XG5cbiAgICBpZiAobmFtZUxpc3RbcmF3SW5kZXhdID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuLyoqXG4gKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiByYXcgZGF0YSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5pbmRleE9mUmF3SW5kZXggPSBmdW5jdGlvbiAocmF3SW5kZXgpIHtcbiAgLy8gSW5kaWNlcyBhcmUgYXNjZW5kaW5nXG4gIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzOyAvLyBJZiByYXdJbmRleCA9PT0gZGF0YUluZGV4XG5cbiAgdmFyIHJhd0RhdGFJbmRleCA9IGluZGljZXNbcmF3SW5kZXhdO1xuXG4gIGlmIChyYXdEYXRhSW5kZXggIT0gbnVsbCAmJiByYXdEYXRhSW5kZXggPT09IHJhd0luZGV4KSB7XG4gICAgcmV0dXJuIHJhd0luZGV4O1xuICB9XG5cbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBpbmRpY2VzLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICB2YXIgbWlkID0gKGxlZnQgKyByaWdodCkgLyAyIHwgMDtcblxuICAgIGlmIChpbmRpY2VzW21pZF0gPCByYXdJbmRleCkge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIGlmIChpbmRpY2VzW21pZF0gPiByYXdJbmRleCkge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG4vKipcbiAqIFJldHJlaXZlIHRoZSBpbmRleCBvZiBuZWFyZXN0IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2sgSWYgZ2l2ZW4gdmFsdWUgaXMgYWZ0ZXIgc3RhY2tlZFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhEaXN0YW5jZT1JbmZpbml0eV1cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBDb25zaWRlcmUgbXVsdGlwbGUgcG9pbnRzIGhhcyB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuXG5cbmxpc3RQcm90by5pbmRpY2VzT2ZOZWFyZXN0ID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUsIHN0YWNrLCBtYXhEaXN0YW5jZSkge1xuICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gIHZhciBkaW1EYXRhID0gc3RvcmFnZVtkaW1dO1xuICB2YXIgbmVhcmVzdEluZGljZXMgPSBbXTtcblxuICBpZiAoIWRpbURhdGEpIHtcbiAgICByZXR1cm4gbmVhcmVzdEluZGljZXM7XG4gIH1cblxuICBpZiAobWF4RGlzdGFuY2UgPT0gbnVsbCkge1xuICAgIG1heERpc3RhbmNlID0gSW5maW5pdHk7XG4gIH1cblxuICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gIHZhciBtaW5EaWZmID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG5cbiAgICBpZiAoZGlmZiA8PSBtYXhEaXN0YW5jZSAmJiBkaXN0IDw9IG1pbkRpc3QpIHtcbiAgICAgIC8vIEZvciB0aGUgY2FzZSBvZiB0d28gZGF0YSBhcmUgc2FtZSBvbiB4QXhpcywgd2hpY2ggaGFzIHNlcXVlbmNlIGRhdGEuXG4gICAgICAvLyBTaG93IHRoZSBuZWFyZXN0IGluZGV4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL2VjaGFydHMvaXNzdWVzLzI4NjlcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdCB8fCBkaWZmID49IDAgJiYgbWluRGlmZiA8IDApIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIG1pbkRpZmYgPSBkaWZmO1xuICAgICAgICBuZWFyZXN0SW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBuZWFyZXN0SW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbn07XG4vKipcbiAqIEdldCByYXcgZGF0YSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlzdFByb3RvLmdldFJhd0luZGV4ID0gZnVuY3Rpb24gKGlkeCkge1xuICB2YXIgcmF3SWR4ID0gdGhpcy5pbmRpY2VzW2lkeF07XG4gIHJldHVybiByYXdJZHggPT0gbnVsbCA/IC0xIDogcmF3SWR4O1xufTtcbi8qKlxuICogR2V0IHJhdyBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRSYXdEYXRhSXRlbSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jhd0RhdGEuZ2V0SXRlbSh0aGlzLmdldFJhd0luZGV4KGlkeCkpO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtib29sZWFufSBbbm90RGVmYXVsdElkeD1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmxpc3RQcm90by5nZXROYW1lID0gZnVuY3Rpb24gKGlkeCkge1xuICByZXR1cm4gdGhpcy5fbmFtZUxpc3RbdGhpcy5pbmRpY2VzW2lkeF1dIHx8ICcnO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtib29sZWFufSBbbm90RGVmYXVsdElkeD1mYWxzZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmxpc3RQcm90by5nZXRJZCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX2lkTGlzdFt0aGlzLmluZGljZXNbaWR4XV0gfHwgdGhpcy5nZXRSYXdJbmRleChpZHgpICsgJyc7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgIGRpbWVuc2lvbnMgPSBbZGltZW5zaW9uc107XG4gIH1cblxuICByZXR1cm4gZGltZW5zaW9ucztcbn1cbi8qKlxuICogRGF0YSBpdGVyYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0YWNrPWZhbHNlXVxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pO1xuICogIGxpc3QuZWFjaChbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7fSk7XG4gKiAgbGlzdC5lYWNoKGZ1bmN0aW9uIChpZHgpIHt9KVxuICovXG5cblxubGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgZGltcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICBzdGFjayA9IGNiO1xuICAgIGNiID0gZGltcztcbiAgICBkaW1zID0gW107XG4gIH1cblxuICBkaW1zID0genJVdGlsLm1hcChub3JtYWxpemVEaW1lbnNpb25zKGRpbXMpLCB0aGlzLmdldERpbWVuc2lvbiwgdGhpcyk7XG4gIHZhciB2YWx1ZSA9IFtdO1xuICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgc3dpdGNoIChkaW1TaXplKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgaSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltc1swXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpLCBzdGFjayksIHRoaXMuZ2V0KGRpbXNbMV0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykge1xuICAgICAgICAgIHZhbHVlW2tdID0gdGhpcy5nZXQoZGltc1trXSwgaSwgc3RhY2spO1xuICAgICAgICB9IC8vIEluZGV4XG5cblxuICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIERhdGEgZmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAqL1xuXG5cbmxpc3RQcm90by5maWx0ZXJTZWxmID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgc3RhY2sgPSBjYjtcbiAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgZGltZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgZGltZW5zaW9ucyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuICB2YXIgbmV3SW5kaWNlcyA9IFtdO1xuICB2YXIgdmFsdWUgPSBbXTtcbiAgdmFyIGRpbVNpemUgPSBkaW1lbnNpb25zLmxlbmd0aDtcbiAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtlZXA7IC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cblxuICAgIGlmICghZGltU2l6ZSkge1xuICAgICAga2VlcCA9IGNiLmNhbGwoY29udGV4dCwgaSk7XG4gICAgfSBlbHNlIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICBrZWVwID0gY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1lbnNpb25zWzBdLCBpLCBzdGFjayksIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykge1xuICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNba10sIGksIHN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVba10gPSBpO1xuICAgICAga2VlcCA9IGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoa2VlcCkge1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGljZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuaW5kaWNlcyA9IG5ld0luZGljZXM7IC8vIFJlc2V0IGRhdGEgZXh0ZW50XG5cbiAgdGhpcy5fZXh0ZW50ID0ge307XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogRGF0YSBtYXBwaW5nIHRvIGEgcGxhaW4gYXJyYXlcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZGltZW5zaW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxubGlzdFByb3RvLm1hcEFycmF5ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgc3RhY2sgPSBjYjtcbiAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgZGltZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgIHJlc3VsdC5wdXNoKGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9LCBzdGFjaywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUob3JpZ2luYWwsIGV4Y2x1ZGVEaW1lbnNpb25zKSB7XG4gIHZhciBhbGxEaW1lbnNpb25zID0gb3JpZ2luYWwuZGltZW5zaW9ucztcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdCh6clV0aWwubWFwKGFsbERpbWVuc2lvbnMsIG9yaWdpbmFsLmdldERpbWVuc2lvbkluZm8sIG9yaWdpbmFsKSwgb3JpZ2luYWwuaG9zdE1vZGVsKTsgLy8gRklYTUUgSWYgbmVlZHMgc3RhY2tlZE9uLCB2YWx1ZSBtYXkgYWxyZWFkeSBiZWVuIHN0YWNrZWRcblxuICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpO1xuICB2YXIgc3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2UgPSB7fTtcbiAgdmFyIG9yaWdpbmFsU3RvcmFnZSA9IG9yaWdpbmFsLl9zdG9yYWdlOyAvLyBJbml0IHN0b3JhZ2VcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGltID0gYWxsRGltZW5zaW9uc1tpXTtcbiAgICB2YXIgZGltU3RvcmUgPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcblxuICAgIGlmICh6clV0aWwuaW5kZXhPZihleGNsdWRlRGltZW5zaW9ucywgZGltKSA+PSAwKSB7XG4gICAgICBzdG9yYWdlW2RpbV0gPSBuZXcgZGltU3RvcmUuY29uc3RydWN0b3Iob3JpZ2luYWxTdG9yYWdlW2RpbV0ubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGlyZWN0IHJlZmVyZW5jZSBmb3Igb3RoZXIgZGltZW5zaW9uc1xuICAgICAgc3RvcmFnZVtkaW1dID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIERhdGEgbWFwcGluZyB0byBhIG5ldyBMaXN0IHdpdGggZ2l2ZW4gZGltZW5zaW9uc1xuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc11cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxubGlzdFByb3RvLm1hcCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgZGltZW5zaW9ucyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTsgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuXG4gIC8vIFNvIHdlIGNhbiByZWZlcmVuY2UgdG8gdGhlIHNhbWUgdmFsdWVcblxuICB2YXIgaW5kaWNlcyA9IGxpc3QuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuICB2YXIgdG1wUmV0VmFsdWUgPSBbXTtcbiAgdGhpcy5lYWNoKGRpbWVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmV0VmFsdWUgPSBjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHJldFZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIGEgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIHJldFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0bXBSZXRWYWx1ZVswXSA9IHJldFZhbHVlO1xuICAgICAgICByZXRWYWx1ZSA9IHRtcFJldFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICB2YXIgZGltU3RvcmUgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgIHZhciByYXdJZHggPSBpbmRpY2VzW2lkeF07XG5cbiAgICAgICAgaWYgKGRpbVN0b3JlKSB7XG4gICAgICAgICAgZGltU3RvcmVbcmF3SWR4XSA9IHJldFZhbHVlW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBzdGFjaywgY29udGV4dCk7XG4gIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IGRpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZVZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYW1wbGVJbmRleCBTYW1wbGUgaW5kZXggZm9yIG5hbWUgYW5kIGlkXG4gKi9cblxuXG5saXN0UHJvdG8uZG93blNhbXBsZSA9IGZ1bmN0aW9uIChkaW1lbnNpb24sIHJhdGUsIHNhbXBsZVZhbHVlLCBzYW1wbGVJbmRleCkge1xuICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBbZGltZW5zaW9uXSk7XG4gIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgdmFyIHRhcmdldFN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICB2YXIgaW5kaWNlcyA9IGxpc3QuaW5kaWNlcyA9IFtdO1xuICB2YXIgZnJhbWVWYWx1ZXMgPSBbXTtcbiAgdmFyIGZyYW1lSW5kaWNlcyA9IFtdO1xuICB2YXIgZnJhbWVTaXplID0gTWF0aC5mbG9vcigxIC8gcmF0ZSk7XG4gIHZhciBkaW1TdG9yZSA9IHRhcmdldFN0b3JhZ2VbZGltZW5zaW9uXTtcbiAgdmFyIGxlbiA9IHRoaXMuY291bnQoKTsgLy8gQ29weSBkYXRhIGZyb20gb3JpZ2luYWwgZGF0YVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmFnZVtkaW1lbnNpb25dLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dW2ldID0gc3RvcmFnZVtkaW1lbnNpb25dW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gZnJhbWVTaXplKSB7XG4gICAgLy8gTGFzdCBmcmFtZVxuICAgIGlmIChmcmFtZVNpemUgPiBsZW4gLSBpKSB7XG4gICAgICBmcmFtZVNpemUgPSBsZW4gLSBpO1xuICAgICAgZnJhbWVWYWx1ZXMubGVuZ3RoID0gZnJhbWVTaXplO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZnJhbWVTaXplOyBrKyspIHtcbiAgICAgIHZhciBpZHggPSBvcmlnaW5hbEluZGljZXNbaSArIGtdO1xuICAgICAgZnJhbWVWYWx1ZXNba10gPSBkaW1TdG9yZVtpZHhdO1xuICAgICAgZnJhbWVJbmRpY2VzW2tdID0gaWR4O1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHNhbXBsZVZhbHVlKGZyYW1lVmFsdWVzKTtcbiAgICB2YXIgaWR4ID0gZnJhbWVJbmRpY2VzW3NhbXBsZUluZGV4KGZyYW1lVmFsdWVzLCB2YWx1ZSkgfHwgMF07IC8vIE9ubHkgd3JpdGUgdmFsdWUgb24gdGhlIGZpbHRlcmVkIGRhdGFcblxuICAgIGRpbVN0b3JlW2lkeF0gPSB2YWx1ZTtcbiAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogR2V0IG1vZGVsIG9mIG9uZSBkYXRhIGl0ZW0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICovXG4vLyBGSVhNRSBNb2RlbCBwcm94eSA/XG5cblxubGlzdFByb3RvLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuICBpZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgcmV0dXJuIG5ldyBNb2RlbCh0aGlzLl9yYXdEYXRhLmdldEl0ZW0oaWR4KSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgZGF0YSBkaWZmZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBvdGhlckxpc3RcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvRGF0YURpZmZlcn1cbiAqL1xuXG5cbmxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICB2YXIgb3RoZXJJZExpc3QgPSBvdGhlckxpc3QgJiYgb3RoZXJMaXN0Ll9pZExpc3Q7XG4gIHZhciB2YWw7IC8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgb3RoZXJJZExpc3RbaWR4XSxcbiAgLy8gd2hpY2ggd2lsbCBjYXVzZSB3ZWlyZCB1ZHBhdGUgYW5pbWF0aW9uLlxuXG4gIHZhciBwcmVmaXggPSAnZVxcMFxcMCc7XG4gIHJldHVybiBuZXcgRGF0YURpZmZlcihvdGhlckxpc3QgPyBvdGhlckxpc3QuaW5kaWNlcyA6IFtdLCB0aGlzLmluZGljZXMsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gKHZhbCA9IG90aGVySWRMaXN0W2lkeF0pICE9IG51bGwgPyB2YWwgOiBwcmVmaXggKyBpZHg7XG4gIH0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gKHZhbCA9IGlkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICB9KTtcbn07XG4vKipcbiAqIEdldCB2aXN1YWwgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdmlzdWFsID0gdGhpcy5fdmlzdWFsO1xuICByZXR1cm4gdmlzdWFsICYmIHZpc3VhbFtrZXldO1xufTtcbi8qKlxuICogU2V0IHZpc3VhbCBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICpcbiAqIEBleGFtcGxlXG4gKiAgc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTtcbiAqICBzZXRWaXN1YWwoe1xuICogICAgICAnY29sb3InOiBjb2xvclxuICogIH0pO1xuICovXG5cblxubGlzdFByb3RvLnNldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuc2V0VmlzdWFsKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fdmlzdWFsID0gdGhpcy5fdmlzdWFsIHx8IHt9O1xuICB0aGlzLl92aXN1YWxba2V5XSA9IHZhbDtcbn07XG4vKipcbiAqIFNldCBsYXlvdXQgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICogQHBhcmFtIHsqfSBbdmFsXVxuICovXG5cblxubGlzdFByb3RvLnNldExheW91dCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuc2V0TGF5b3V0KG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbGF5b3V0W2tleV0gPSB2YWw7XG59O1xuLyoqXG4gKiBHZXQgbGF5b3V0IHByb3BlcnR5LlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXkuXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxubGlzdFByb3RvLmdldExheW91dCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2xheW91dFtrZXldO1xufTtcbi8qKlxuICogR2V0IGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF07XG59O1xuLyoqXG4gKiBTZXQgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFttZXJnZT1mYWxzZV1cbiAqL1xuXG5cbmxpc3RQcm90by5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkge1xuICB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdID0gbWVyZ2UgPyB6clV0aWwuZXh0ZW5kKHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF0gfHwge30sIGxheW91dCkgOiBsYXlvdXQ7XG59O1xuLyoqXG4gKiBDbGVhciBhbGwgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqL1xuXG5cbmxpc3RQcm90by5jbGVhckl0ZW1MYXlvdXRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9pdGVtTGF5b3V0cy5sZW5ndGggPSAwO1xufTtcbi8qKlxuICogR2V0IHZpc3VhbCBwcm9wZXJ0eSBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gKi9cblxuXG5saXN0UHJvdG8uZ2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgaWdub3JlUGFyZW50KSB7XG4gIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XTtcbiAgdmFyIHZhbCA9IGl0ZW1WaXN1YWwgJiYgaXRlbVZpc3VhbFtrZXldO1xuXG4gIGlmICh2YWwgPT0gbnVsbCAmJiAhaWdub3JlUGFyZW50KSB7XG4gICAgLy8gVXNlIGdsb2JhbCB2aXN1YWwgcHJvcGVydHlcbiAgICByZXR1cm4gdGhpcy5nZXRWaXN1YWwoa2V5KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBTZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gKlxuICogQGV4YW1wbGVcbiAqICBzZXRJdGVtVmlzdWFsKDAsICdjb2xvcicsIGNvbG9yKTtcbiAqICBzZXRJdGVtVmlzdWFsKDAsIHtcbiAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAqICB9KTtcbiAqL1xuXG5cbmxpc3RQcm90by5zZXRJdGVtVmlzdWFsID0gZnVuY3Rpb24gKGlkeCwga2V5LCB2YWx1ZSkge1xuICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gfHwge307XG4gIHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF0gPSBpdGVtVmlzdWFsO1xuXG4gIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaXRlbVZpc3VhbFtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpdGVtVmlzdWFsW2tleV0gPSB2YWx1ZTtcbn07XG4vKipcbiAqIENsZWFyIGl0ZW1WaXN1YWxzIGFuZCBsaXN0IHZpc3VhbC5cbiAqL1xuXG5cbmxpc3RQcm90by5jbGVhckFsbFZpc3VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fdmlzdWFsID0ge307XG4gIHRoaXMuX2l0ZW1WaXN1YWxzID0gW107XG59O1xuXG52YXIgc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICBjaGlsZC5zZXJpZXNJbmRleCA9IHRoaXMuc2VyaWVzSW5kZXg7XG4gIGNoaWxkLmRhdGFJbmRleCA9IHRoaXMuZGF0YUluZGV4O1xuICBjaGlsZC5kYXRhVHlwZSA9IHRoaXMuZGF0YVR5cGU7XG59O1xuLyoqXG4gKiBTZXQgZ3JhcGhpYyBlbGVtZW50IHJlbGF0aXZlIHRvIGRhdGEuIEl0IGNhbiBiZSBzZXQgYXMgbnVsbFxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbZWxdXG4gKi9cblxuXG5saXN0UHJvdG8uc2V0SXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChpZHgsIGVsKSB7XG4gIHZhciBob3N0TW9kZWwgPSB0aGlzLmhvc3RNb2RlbDtcblxuICBpZiAoZWwpIHtcbiAgICAvLyBBZGQgZGF0YSBpbmRleCBhbmQgc2VyaWVzIGluZGV4IGZvciBpbmRleGluZyB0aGUgZGF0YSBieSBlbGVtZW50XG4gICAgLy8gVXNlZnVsIGluIHRvb2x0aXBcbiAgICBlbC5kYXRhSW5kZXggPSBpZHg7XG4gICAgZWwuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xuICAgIGVsLnNlcmllc0luZGV4ID0gaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5zZXJpZXNJbmRleDtcblxuICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICBlbC50cmF2ZXJzZShzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdID0gZWw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICovXG5cblxubGlzdFByb3RvLmdldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHJldHVybiB0aGlzLl9ncmFwaGljRWxzW2lkeF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKi9cblxuXG5saXN0UHJvdG8uZWFjaEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgenJVdGlsLmVhY2godGhpcy5fZ3JhcGhpY0VscywgZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGNiICYmIGNiLmNhbGwoY29udGV4dCwgZWwsIGlkeCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIFNoYWxsb3cgY2xvbmUgYSBuZXcgbGlzdCBleGNlcHQgdmlzdWFsIGFuZCBsYXlvdXQgcHJvcGVydGllcywgYW5kIGdyYXBoIGVsZW1lbnRzLlxuICogTmV3IGxpc3Qgb25seSBjaGFuZ2UgdGhlIGluZGljZXMuXG4gKi9cblxuXG5saXN0UHJvdG8uY2xvbmVTaGFsbG93ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGltZW5zaW9uSW5mb0xpc3QgPSB6clV0aWwubWFwKHRoaXMuZGltZW5zaW9ucywgdGhpcy5nZXREaW1lbnNpb25JbmZvLCB0aGlzKTtcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25JbmZvTGlzdCwgdGhpcy5ob3N0TW9kZWwpOyAvLyBGSVhNRVxuXG4gIGxpc3QuX3N0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgdGhpcyk7IC8vIENsb25lIHdpbGwgbm90IGNoYW5nZSB0aGUgZGF0YSBleHRlbnQgYW5kIGluZGljZXNcblxuICBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXMuc2xpY2UoKTtcblxuICBpZiAodGhpcy5fZXh0ZW50KSB7XG4gICAgbGlzdC5fZXh0ZW50ID0genJVdGlsLmV4dGVuZCh7fSwgdGhpcy5fZXh0ZW50KTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufTtcbi8qKlxuICogV3JhcCBzb21lIG1ldGhvZCB0byBhZGQgbW9yZSBmZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0RnVuY3Rpb25cbiAqL1xuXG5cbmxpc3RQcm90by53cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluamVjdEZ1bmN0aW9uKSB7XG4gIHZhciBvcmlnaW5hbE1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZV07XG5cbiAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX193cmFwcGVkTWV0aG9kcyA9IHRoaXMuX193cmFwcGVkTWV0aG9kcyB8fCBbXTtcblxuICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcblxuICB0aGlzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBpbmplY3RGdW5jdGlvbi5hcHBseSh0aGlzLCBbcmVzXS5jb25jYXQoenJVdGlsLnNsaWNlKGFyZ3VtZW50cykpKTtcbiAgfTtcbn07IC8vIE1ldGhvZHMgdGhhdCBjcmVhdGUgYSBuZXcgbGlzdCBiYXNlZCBvbiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuLy8gTm90aWNlIHRoYXQgdGhvc2UgbWV0aG9kIHNob3VsZCBgUkVUVVJOYCB0aGUgbmV3IGxpc3QuXG5cblxubGlzdFByb3RvLlRSQU5TRkVSQUJMRV9NRVRIT0RTID0gWydjbG9uZVNoYWxsb3cnLCAnZG93blNhbXBsZScsICdtYXAnXTsgLy8gTWV0aG9kcyB0aGF0IGNoYW5nZSBpbmRpY2VzIG9mIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG5cbmxpc3RQcm90by5DSEFOR0FCTEVfTUVUSE9EUyA9IFsnZmlsdGVyU2VsZiddO1xudmFyIF9kZWZhdWx0ID0gTGlzdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2RhdGEvTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///263\n");

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

eval("var numberUtil = __webpack_require__(235);\n\nvar formatUtil = __webpack_require__(245);\n\nvar Scale = __webpack_require__(257);\n\nvar helper = __webpack_require__(279);\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getTicksLabels: function () {\n    var labels = [];\n    var ticks = this.getTicks();\n\n    for (var i = 0; i < ticks.length; i++) {\n      labels.push(this.getLabel(ticks[i]));\n    }\n\n    return labels;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9JbnRlcnZhbC5qcz8wOGU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIFNjYWxlID0gcmVxdWlyZShcIi4vU2NhbGVcIik7XG5cbnZhciBoZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5cbi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9JbnRlcnZhbFxuICovXG52YXIgcm91bmROdW1iZXIgPSBudW1iZXJVdGlsLnJvdW5kO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvSW50ZXJ2YWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBJbnRlcnZhbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ2ludGVydmFsJyxcbiAgX2ludGVydmFsOiAwLFxuICBfaW50ZXJ2YWxQcmVjaXNpb246IDIsXG4gIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDsgLy9zdGFydCxlbmQgbWF5IGJlIGEgTnVtYmVyIGxpa2UgJzI1Jyxzby4uLlxuXG4gICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgIHRoaXNFeHRlbnRbMF0gPSBwYXJzZUZsb2F0KHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgIHRoaXNFeHRlbnRbMV0gPSBwYXJzZUZsb2F0KGVuZCk7XG4gICAgfVxuICB9LFxuICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgIG90aGVyWzFdID4gZXh0ZW50WzFdICYmIChleHRlbnRbMV0gPSBvdGhlclsxXSk7IC8vIHVuaW9uRXh0ZW50IG1heSBjYWxsZWQgYnkgaXQncyBzdWIgY2xhc3Nlc1xuXG4gICAgSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGUuc2V0RXh0ZW50LmNhbGwodGhpcywgZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaW50ZXJ2YWxcbiAgICovXG4gIGdldEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVydmFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgaW50ZXJ2YWxcbiAgICovXG4gIHNldEludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsOyAvLyBEcm9wcGVkIGF1dG8gY2FsY3VsYXRlZCBuaWNlRXh0ZW50IGFuZCB1c2UgdXNlciBzZXR0ZWQgZXh0ZW50XG4gICAgLy8gV2UgYXNzdW1lIHVzZXIgd2FuJ3QgdG8gc2V0IGJvdGggaW50ZXJ2YWwsIG1pbiwgbWF4IHRvIGdldCBhIGJldHRlciByZXN1bHRcblxuICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbiA9IGhlbHBlci5nZXRJbnRlcnZhbFByZWNpc2lvbihpbnRlcnZhbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGVscGVyLmludGVydmFsU2NhbGVHZXRUaWNrcyh0aGlzLl9pbnRlcnZhbCwgdGhpcy5fZXh0ZW50LCB0aGlzLl9uaWNlRXh0ZW50LCB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKi9cbiAgZ2V0VGlja3NMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHQucHJlY2lzaW9uXSBJZiAnYXV0bycsIHVzZSBuaWNlIHByZXNpc2lvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LnBhZF0gcmV0dXJucyAxLjUwIGJ1dCBub3QgMS41IGlmIHByZWNpc2lvbiBpcyAyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogZnVuY3Rpb24gKGRhdGEsIG9wdCkge1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gb3B0ICYmIG9wdC5wcmVjaXNpb247XG5cbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShkYXRhKSB8fCAwO1xuICAgIH0gZWxzZSBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgIC8vIFNob3VsZCBiZSBtb3JlIHByZWNpc2UgdGhlbiB0aWNrLlxuICAgICAgcHJlY2lzaW9uID0gdGhpcy5faW50ZXJ2YWxQcmVjaXNpb247XG4gICAgfSAvLyAoMSkgSWYgYHByZWNpc2lvbmAgaXMgc2V0LCAxMi4wMDUgc2hvdWxkIGJlIGRpc3BsYXkgYXMgJzEyLjAwNTAwJy5cbiAgICAvLyAoMikgVXNlIHJvdW5kTnVtYmVyICh0b0ZpeGVkKSB0byBhdm9pZCBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgJzMuNWUtNycuXG5cblxuICAgIGRhdGEgPSByb3VuZE51bWJlcihkYXRhLCBwcmVjaXNpb24sIHRydWUpO1xuICAgIHJldHVybiBmb3JtYXRVdGlsLmFkZENvbW1hcyhkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGludGVydmFsIGFuZCBleHRlbnQgb2YgaW50ZXJ2YWxzIGZvciBuaWNlIHRpY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BsaXROdW1iZXIgPSA1XSBEZXNpcmVkIG51bWJlciBvZiB0aWNrc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbkludGVydmFsXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heEludGVydmFsXVxuICAgKi9cbiAgbmljZVRpY2tzOiBmdW5jdGlvbiAoc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCkge1xuICAgIHNwbGl0TnVtYmVyID0gc3BsaXROdW1iZXIgfHwgNTtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlciBtYXkgc2V0IGF4aXMgbWluIDAgYW5kIGRhdGEgYXJlIGFsbCBuZWdhdGl2ZVxuICAgIC8vIEZJWE1FIElmIGl0IG5lZWRzIHRvIHJldmVyc2UgP1xuXG5cbiAgICBpZiAoc3BhbiA8IDApIHtcbiAgICAgIHNwYW4gPSAtc3BhbjtcbiAgICAgIGV4dGVudC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGhlbHBlci5pbnRlcnZhbFNjYWxlTmljZVRpY2tzKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCk7XG4gICAgdGhpcy5faW50ZXJ2YWxQcmVjaXNpb24gPSByZXN1bHQuaW50ZXJ2YWxQcmVjaXNpb247XG4gICAgdGhpcy5faW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWw7XG4gICAgdGhpcy5fbmljZUV4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudDtcbiAgfSxcblxuICAvKipcbiAgICogTmljZSBleHRlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3BsaXROdW1iZXIgPSA1XSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1pbj1mYWxzZV1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZpeE1heD1mYWxzZV1cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0Lm1pbkludGVydmFsXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQubWF4SW50ZXJ2YWxdXG4gICAqL1xuICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDsgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG5cbiAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgIGlmIChleHRlbnRbMF0gIT09IDApIHtcbiAgICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgICB2YXIgZXhwYW5kU2l6ZSA9IGV4dGVudFswXTsgLy8gSW4gdGhlIGZvd2xsb3dpbmcgY2FzZVxuICAgICAgICAvLyAgICAgIEF4aXMgaGFzIGJlZW4gZml4ZWQgbWF4IDEwMFxuICAgICAgICAvLyAgICAgIFBsdXMgZGF0YSBhcmUgYWxsIDEwMCBhbmQgYXhpcyBleHRlbnQgYXJlIFsxMDAsIDEwMF0uXG4gICAgICAgIC8vIEV4dGVuZCB0byB0aGUgYm90aCBzaWRlIHdpbGwgY2F1c2UgZXhwYW5kZWQgbWF4IGlzIGxhcmdlciB0aGFuIGZpeGVkIG1heC5cbiAgICAgICAgLy8gU28gb25seSBleHBhbmQgdG8gdGhlIHNtYWxsZXIgc2lkZS5cblxuICAgICAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgICAgICBleHRlbnRbMV0gKz0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVudFswXSAtPSBleHBhbmRTaXplIC8gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTsgLy8gSWYgdGhlcmUgYXJlIG5vIGRhdGEgYW5kIGV4dGVudCBhcmUgW0luZmluaXR5LCAtSW5maW5pdHldXG5cbiAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICBleHRlbnRbMF0gPSAwO1xuICAgICAgZXh0ZW50WzFdID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLm5pY2VUaWNrcyhvcHQuc3BsaXROdW1iZXIsIG9wdC5taW5JbnRlcnZhbCwgb3B0Lm1heEludGVydmFsKTsgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcblxuICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgaWYgKCFvcHQuZml4TWluKSB7XG4gICAgICBleHRlbnRbMF0gPSByb3VuZE51bWJlcihNYXRoLmZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG59KTtcbi8qKlxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAqL1xuXG5JbnRlcnZhbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBJbnRlcnZhbFNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvc2NhbGUvSW50ZXJ2YWwuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///264\n");

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar _clazz = __webpack_require__(247);\n\nvar parseClassType = _clazz.parseClassType;\nvar base = 0;\nvar DELIMITER = '_';\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\n\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++, Math.random()].join(DELIMITER);\n}\n/**\n * @inner\n */\n\n\nfunction enableSubTypeDefaulter(entity) {\n  var subTypeDefaulters = {};\n\n  entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n    componentType = parseClassType(componentType);\n    subTypeDefaulters[componentType.main] = defaulter;\n  };\n\n  entity.determineSubType = function (componentType, option) {\n    var type = option.type;\n\n    if (!type) {\n      var componentTypeMain = parseClassType(componentType).main;\n\n      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n\n    return type;\n  };\n\n  return entity;\n}\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\n\n\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\n   * @public\n   * @param {Array.<string>} targetNameList Target Component type list.\n   *                                           Can be ['aa', 'bb', 'aa.xx']\n   * @param {Array.<string>} fullNameList By which we can build dependency graph.\n   * @param {Function} callback Params: componentType, dependencies.\n   * @param {Object} context Scope of callback.\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var stack = result.noEntryList;\n    var targetNameSet = {};\n    zrUtil.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n\n    while (stack.length) {\n      var currComponentType = stack.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n\n      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n\n    zrUtil.each(targetNameSet, function () {\n      throw new Error('Circle dependency may exists');\n    });\n\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n\n      if (graph[succComponentType].entryCount === 0) {\n        stack.push(succComponentType);\n      }\n    } // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n\n\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  /**\n   * DepndencyGraph: {Object}\n   * key: conponentType,\n   * value: {\n   *     successor: [conponentTypes...],\n   *     originalDeps: [conponentTypes...],\n   *     entryCount: {number}\n   * }\n   */\n\n\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrUtil.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n\n      zrUtil.each(availableDeps, function (dependentName) {\n        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n\n        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n\n    return graph[name];\n  }\n\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrUtil.each(originalDeps, function (dep) {\n      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\n\nexports.getUID = getUID;\nexports.enableSubTypeDefaulter = enableSubTypeDefaulter;\nexports.enableTopologicalTravel = enableTopologicalTravel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL2NvbXBvbmVudC5qcz9jYzcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgX2NsYXp6ID0gcmVxdWlyZShcIi4vY2xhenpcIik7XG5cbnZhciBwYXJzZUNsYXNzVHlwZSA9IF9jbGF6ei5wYXJzZUNsYXNzVHlwZTtcbnZhciBiYXNlID0gMDtcbnZhciBERUxJTUlURVIgPSAnXyc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VUlEKHR5cGUpIHtcbiAgLy8gQ29uc2lkZXJpbmcgdGhlIGNhc2Ugb2YgY3Jvc3NpbmcganMgY29udGV4dCxcbiAgLy8gdXNlIE1hdGgucmFuZG9tIHRvIG1ha2UgaWQgYXMgdW5pcXVlIGFzIHBvc3NpYmxlLlxuICByZXR1cm4gW3R5cGUgfHwgJycsIGJhc2UrKywgTWF0aC5yYW5kb20oKV0uam9pbihERUxJTUlURVIpO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIoZW50aXR5KSB7XG4gIHZhciBzdWJUeXBlRGVmYXVsdGVycyA9IHt9O1xuXG4gIGVudGl0eS5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVmYXVsdGVyKSB7XG4gICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgIHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGUubWFpbl0gPSBkZWZhdWx0ZXI7XG4gIH07XG5cbiAgZW50aXR5LmRldGVybWluZVN1YlR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgb3B0aW9uKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRpb24udHlwZTtcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdmFyIGNvbXBvbmVudFR5cGVNYWluID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSkubWFpbjtcblxuICAgICAgaWYgKGVudGl0eS5oYXNTdWJUeXBlcyhjb21wb25lbnRUeXBlKSAmJiBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0pIHtcbiAgICAgICAgdHlwZSA9IHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXShvcHRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIHJldHVybiBlbnRpdHk7XG59XG4vKipcbiAqIFRvcG9sb2dpY2FsIHRyYXZlbCBvbiBBY3Rpdml0eSBOZXR3b3JrIChBY3Rpdml0eSBPbiBWZXJ0aWNlcykuXG4gKiBEZXBlbmRlbmNpZXMgaXMgZGVmaW5lZCBpbiBNb2RlbC5wcm90b3R5cGUuZGVwZW5kZW5jaWVzLCBsaWtlIFsneEF4aXMnLCAneUF4aXMnXS5cbiAqXG4gKiBJZiAneEF4aXMnIG9yICd5QXhpcycgaXMgYWJzZW50IGluIGNvbXBvbmVudFR5cGVMaXN0LCBqdXN0IGlnbm9yZSBpdCBpbiB0b3BvbG9neS5cbiAqXG4gKiBJZiB0aGVyZSBpcyBjaXJjbGUgZGVwZW5kZW5jZXksIEVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKGVudGl0eSwgZGVwZW5kZW5jeUdldHRlcikge1xuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0YXJnZXROYW1lTGlzdCBUYXJnZXQgQ29tcG9uZW50IHR5cGUgbGlzdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIFsnYWEnLCAnYmInLCAnYWEueHgnXVxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmdWxsTmFtZUxpc3QgQnkgd2hpY2ggd2UgY2FuIGJ1aWxkIGRlcGVuZGVuY3kgZ3JhcGguXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFBhcmFtczogY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBTY29wZSBvZiBjYWxsYmFjay5cbiAgICovXG4gIGVudGl0eS50b3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uICh0YXJnZXROYW1lTGlzdCwgZnVsbE5hbWVMaXN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmICghdGFyZ2V0TmFtZUxpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG1ha2VEZXBuZGVuY3lHcmFwaChmdWxsTmFtZUxpc3QpO1xuICAgIHZhciBncmFwaCA9IHJlc3VsdC5ncmFwaDtcbiAgICB2YXIgc3RhY2sgPSByZXN1bHQubm9FbnRyeUxpc3Q7XG4gICAgdmFyIHRhcmdldE5hbWVTZXQgPSB7fTtcbiAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRhcmdldE5hbWVTZXRbbmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJDb21wb25lbnRUeXBlID0gc3RhY2sucG9wKCk7XG4gICAgICB2YXIgY3VyclZlcnRleCA9IGdyYXBoW2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgIHZhciBpc0luVGFyZ2V0TmFtZVNldCA9ICEhdGFyZ2V0TmFtZVNldFtjdXJyQ29tcG9uZW50VHlwZV07XG5cbiAgICAgIGlmIChpc0luVGFyZ2V0TmFtZVNldCkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGN1cnJDb21wb25lbnRUeXBlLCBjdXJyVmVydGV4Lm9yaWdpbmFsRGVwcy5zbGljZSgpKTtcbiAgICAgICAgZGVsZXRlIHRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgfVxuXG4gICAgICB6clV0aWwuZWFjaChjdXJyVmVydGV4LnN1Y2Nlc3NvciwgaXNJblRhcmdldE5hbWVTZXQgPyByZW1vdmVFZGdlQW5kQWRkIDogcmVtb3ZlRWRnZSk7XG4gICAgfVxuXG4gICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZVNldCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgZGVwZW5kZW5jeSBtYXkgZXhpc3RzJyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICBncmFwaFtzdWNjQ29tcG9uZW50VHlwZV0uZW50cnlDb3VudC0tO1xuXG4gICAgICBpZiAoZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgICB9XG4gICAgfSAvLyBDb25zaWRlciB0aGlzIGNhc2U6IGxlZ2VuZCBkZXBlbmRzIG9uIHNlcmllcywgYW5kIHdlIGNhbGxcbiAgICAvLyBjaGFydC5zZXRPcHRpb24oe3NlcmllczogWy4uLl19KSwgd2hlcmUgb25seSBzZXJpZXMgaXMgaW4gb3B0aW9uLlxuICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlICdyZW1vdmVFZGdlQW5kQWRkJywgbGVnZW5kTW9kZWwubWVyZ2VPcHRpb24gd2lsbFxuICAgIC8vIG5vdCBiZSBjYWxsZWQsIGJ1dCBvbmx5IHNlcmVpcy5tZXJnZU9wdGlvbiBpcyBjYWxsZWQuIFRodXMgbGVnZW5kXG4gICAgLy8gaGF2ZSBubyBjaGFuY2UgdG8gdXBkYXRlIGl0cyBsb2NhbCByZWNvcmQgYWJvdXQgc2VyaWVzIChsaWtlIHdoaWNoXG4gICAgLy8gbmFtZSBvZiBzZXJpZXMgaXMgYXZhaWxhYmxlIGluIGxlZ2VuZCkuXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VBbmRBZGQoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgIHRhcmdldE5hbWVTZXRbc3VjY0NvbXBvbmVudFR5cGVdID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUVkZ2Uoc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERlcG5kZW5jeUdyYXBoOiB7T2JqZWN0fVxuICAgKiBrZXk6IGNvbnBvbmVudFR5cGUsXG4gICAqIHZhbHVlOiB7XG4gICAqICAgICBzdWNjZXNzb3I6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAqICAgICBvcmlnaW5hbERlcHM6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAqICAgICBlbnRyeUNvdW50OiB7bnVtYmVyfVxuICAgKiB9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFrZURlcG5kZW5jeUdyYXBoKGZ1bGxOYW1lTGlzdCkge1xuICAgIHZhciBncmFwaCA9IHt9O1xuICAgIHZhciBub0VudHJ5TGlzdCA9IFtdO1xuICAgIHpyVXRpbC5lYWNoKGZ1bGxOYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB0aGlzSXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpO1xuICAgICAgdmFyIG9yaWdpbmFsRGVwcyA9IHRoaXNJdGVtLm9yaWdpbmFsRGVwcyA9IGRlcGVuZGVuY3lHZXR0ZXIobmFtZSk7XG4gICAgICB2YXIgYXZhaWxhYmxlRGVwcyA9IGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCk7XG4gICAgICB0aGlzSXRlbS5lbnRyeUNvdW50ID0gYXZhaWxhYmxlRGVwcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzSXRlbS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgIG5vRW50cnlMaXN0LnB1c2gobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHpyVXRpbC5lYWNoKGF2YWlsYWJsZURlcHMsIGZ1bmN0aW9uIChkZXBlbmRlbnROYW1lKSB7XG4gICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGlzSXRlbS5wcmVkZWNlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGhpc0l0ZW0ucHJlZGVjZXNzb3IucHVzaChkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0SXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIGRlcGVuZGVudE5hbWUpO1xuXG4gICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGF0SXRlbS5zdWNjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgIHRoYXRJdGVtLnN1Y2Nlc3Nvci5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JhcGg6IGdyYXBoLFxuICAgICAgbm9FbnRyeUxpc3Q6IG5vRW50cnlMaXN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpIHtcbiAgICBpZiAoIWdyYXBoW25hbWVdKSB7XG4gICAgICBncmFwaFtuYW1lXSA9IHtcbiAgICAgICAgcHJlZGVjZXNzb3I6IFtdLFxuICAgICAgICBzdWNjZXNzb3I6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBncmFwaFtuYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCkge1xuICAgIHZhciBhdmFpbGFibGVEZXBzID0gW107XG4gICAgenJVdGlsLmVhY2gob3JpZ2luYWxEZXBzLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICB6clV0aWwuaW5kZXhPZihmdWxsTmFtZUxpc3QsIGRlcCkgPj0gMCAmJiBhdmFpbGFibGVEZXBzLnB1c2goZGVwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXZhaWxhYmxlRGVwcztcbiAgfVxufVxuXG5leHBvcnRzLmdldFVJRCA9IGdldFVJRDtcbmV4cG9ydHMuZW5hYmxlU3ViVHlwZURlZmF1bHRlciA9IGVuYWJsZVN1YlR5cGVEZWZhdWx0ZXI7XG5leHBvcnRzLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsID0gZW5hYmxlVG9wb2xvZ2ljYWxUcmF2ZWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3V0aWwvY29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///265\n");

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar graphic = __webpack_require__(233);\n\nvar BoundingRect = __webpack_require__(244);\n\n// Symbol factory\n\n/**\n * Triangle shape\n * @inner\n */\nvar Triangle = graphic.extendShape({\n  type: 'triangle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy + height);\n    path.lineTo(cx - width, cy + height);\n    path.closePath();\n  }\n});\n/**\n * Diamond shape\n * @inner\n */\n\nvar Diamond = graphic.extendShape({\n  type: 'diamond',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy);\n    path.lineTo(cx, cy + height);\n    path.lineTo(cx - width, cy);\n    path.closePath();\n  }\n});\n/**\n * Pin shape\n * @inner\n */\n\nvar Pin = graphic.extendShape({\n  type: 'pin',\n  shape: {\n    // x, y on the cusp\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var w = shape.width / 5 * 3; // Height must be larger than width\n\n    var h = Math.max(w, shape.height);\n    var r = w / 2; // Dist on y with tangent point and circle center\n\n    var dy = r * r / (h - r);\n    var cy = y - h + r + dy;\n    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center\n\n    var dx = Math.cos(angle) * r;\n    var tanX = Math.sin(angle);\n    var tanY = Math.cos(angle);\n    var cpLen = r * 0.6;\n    var cpLen2 = r * 0.7;\n    path.moveTo(x - dx, cy + dy);\n    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);\n    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);\n    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);\n    path.closePath();\n  }\n});\n/**\n * Arrow shape\n * @inner\n */\n\nvar Arrow = graphic.extendShape({\n  type: 'arrow',\n  shape: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var height = shape.height;\n    var width = shape.width;\n    var x = shape.x;\n    var y = shape.y;\n    var dx = width / 3 * 2;\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + dx, y + height);\n    ctx.lineTo(x, y + height / 4 * 3);\n    ctx.lineTo(x - dx, y + height);\n    ctx.lineTo(x, y);\n    ctx.closePath();\n  }\n});\n/**\n * Map of path contructors\n * @type {Object.<string, module:zrender/graphic/Path>}\n */\n\nvar symbolCtors = {\n  line: graphic.Line,\n  rect: graphic.Rect,\n  roundRect: graphic.Rect,\n  square: graphic.Rect,\n  circle: graphic.Circle,\n  diamond: Diamond,\n  pin: Pin,\n  arrow: Arrow,\n  triangle: Triangle\n};\nvar symbolShapeMakers = {\n  line: function (x, y, w, h, shape) {\n    // FIXME\n    shape.x1 = x;\n    shape.y1 = y + h / 2;\n    shape.x2 = x + w;\n    shape.y2 = y + h / 2;\n  },\n  rect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n  },\n  roundRect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n    shape.r = Math.min(w, h) / 4;\n  },\n  square: function (x, y, w, h, shape) {\n    var size = Math.min(w, h);\n    shape.x = x;\n    shape.y = y;\n    shape.width = size;\n    shape.height = size;\n  },\n  circle: function (x, y, w, h, shape) {\n    // Put circle in the center of square\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.r = Math.min(w, h) / 2;\n  },\n  diamond: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  pin: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  arrow: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  triangle: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  }\n};\nvar symbolBuildProxies = {};\nzrUtil.each(symbolCtors, function (Ctor, name) {\n  symbolBuildProxies[name] = new Ctor();\n});\nvar SymbolClz = graphic.extendShape({\n  type: 'symbol',\n  shape: {\n    symbolType: '',\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  beforeBrush: function () {\n    var style = this.style;\n    var shape = this.shape; // FIXME\n\n    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n      style.textPosition = ['50%', '40%'];\n      style.textAlign = 'center';\n      style.textVerticalAlign = 'middle';\n    }\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    var symbolType = shape.symbolType;\n    var proxySymbol = symbolBuildProxies[symbolType];\n\n    if (shape.symbolType !== 'none') {\n      if (!proxySymbol) {\n        // Default rect\n        symbolType = 'rect';\n        proxySymbol = symbolBuildProxies[symbolType];\n      }\n\n      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);\n      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n    }\n  }\n}); // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\nfunction symbolPathSetColor(color, innerColor) {\n  if (this.type !== 'image') {\n    var symbolStyle = this.style;\n    var symbolShape = this.shape;\n\n    if (symbolShape && symbolShape.symbolType === 'line') {\n      symbolStyle.stroke = color;\n    } else if (this.__isEmptyBrush) {\n      symbolStyle.stroke = color;\n      symbolStyle.fill = innerColor || '#fff';\n    } else {\n      // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n      symbolStyle.fill && (symbolStyle.fill = color);\n      symbolStyle.stroke && (symbolStyle.stroke = color);\n    }\n\n    this.dirty(false);\n  }\n}\n/**\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n * @param {string} symbolType\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n * @param {string} color\n * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,\n *                            for path and image only.\n */\n\n\nfunction createSymbol(symbolType, x, y, w, h, color, keepAspect) {\n  // TODO Support image object, DynamicImage.\n  var isEmpty = symbolType.indexOf('empty') === 0;\n\n  if (isEmpty) {\n    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n  }\n\n  var symbolPath;\n\n  if (symbolType.indexOf('image://') === 0) {\n    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else if (symbolType.indexOf('path://') === 0) {\n    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else {\n    symbolPath = new SymbolClz({\n      shape: {\n        symbolType: symbolType,\n        x: x,\n        y: y,\n        width: w,\n        height: h\n      }\n    });\n  }\n\n  symbolPath.__isEmptyBrush = isEmpty;\n  symbolPath.setColor = symbolPathSetColor;\n  symbolPath.setColor(color);\n  return symbolPath;\n}\n\nexports.createSymbol = createSymbol;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL3N5bWJvbC5qcz9iZTJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuL2dyYXBoaWNcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8vIFN5bWJvbCBmYWN0b3J5XG5cbi8qKlxuICogVHJpYW5nbGUgc2hhcGVcbiAqIEBpbm5lclxuICovXG52YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ3RyaWFuZ2xlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kgKyBoZWlnaHQpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBEaWFtb25kIHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICB0eXBlOiAnZGlhbW9uZCcsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgdmFyIGN5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xuICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuLyoqXG4gKiBQaW4gc2hhcGVcbiAqIEBpbm5lclxuICovXG5cbnZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ3BpbicsXG4gIHNoYXBlOiB7XG4gICAgLy8geCwgeSBvbiB0aGUgY3VzcFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMzsgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcblxuICAgIHZhciBoID0gTWF0aC5tYXgodywgc2hhcGUuaGVpZ2h0KTtcbiAgICB2YXIgciA9IHcgLyAyOyAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG5cbiAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XG4gICAgdmFyIGN5ID0geSAtIGggKyByICsgZHk7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gcik7IC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcblxuICAgIHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSAqIHI7XG4gICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHRhblkgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIGNwTGVuID0gciAqIDAuNjtcbiAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcbiAgICBwYXRoLm1vdmVUbyh4IC0gZHgsIGN5ICsgZHkpO1xuICAgIHBhdGguYXJjKHgsIGN5LCByLCBNYXRoLlBJIC0gYW5nbGUsIE1hdGguUEkgKiAyICsgYW5nbGUpO1xuICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sIHgsIHkgLSBjcExlbjIsIHgsIHkpO1xuICAgIHBhdGguYmV6aWVyQ3VydmVUbyh4LCB5IC0gY3BMZW4yLCB4IC0gZHggKyB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sIHggLSBkeCwgY3kgKyBkeSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG4vKipcbiAqIEFycm93IHNoYXBlXG4gKiBAaW5uZXJcbiAqL1xuXG52YXIgQXJyb3cgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgdHlwZTogJ2Fycm93JyxcbiAgc2hhcGU6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIGR4ID0gd2lkdGggLyAzICogMjtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyBoZWlnaHQgLyA0ICogMyk7XG4gICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbi8qKlxuICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoPn1cbiAqL1xuXG52YXIgc3ltYm9sQ3RvcnMgPSB7XG4gIGxpbmU6IGdyYXBoaWMuTGluZSxcbiAgcmVjdDogZ3JhcGhpYy5SZWN0LFxuICByb3VuZFJlY3Q6IGdyYXBoaWMuUmVjdCxcbiAgc3F1YXJlOiBncmFwaGljLlJlY3QsXG4gIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXG4gIGRpYW1vbmQ6IERpYW1vbmQsXG4gIHBpbjogUGluLFxuICBhcnJvdzogQXJyb3csXG4gIHRyaWFuZ2xlOiBUcmlhbmdsZVxufTtcbnZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcbiAgbGluZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgLy8gRklYTUVcbiAgICBzaGFwZS54MSA9IHg7XG4gICAgc2hhcGUueTEgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUueDIgPSB4ICsgdztcbiAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgc2hhcGUueCA9IHg7XG4gICAgc2hhcGUueSA9IHk7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gNDtcbiAgfSxcbiAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHcsIGgpO1xuICAgIHNoYXBlLnggPSB4O1xuICAgIHNoYXBlLnkgPSB5O1xuICAgIHNoYXBlLndpZHRoID0gc2l6ZTtcbiAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xuICB9LFxuICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xuICB9LFxuICBkaWFtb25kOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfSxcbiAgcGluOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS54ID0geCArIHcgLyAyO1xuICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgc2hhcGUud2lkdGggPSB3O1xuICAgIHNoYXBlLmhlaWdodCA9IGg7XG4gIH0sXG4gIHRyaWFuZ2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgfVxufTtcbnZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcbnpyVXRpbC5lYWNoKHN5bWJvbEN0b3JzLCBmdW5jdGlvbiAoQ3RvciwgbmFtZSkge1xuICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgQ3RvcigpO1xufSk7XG52YXIgU3ltYm9sQ2x6ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBzaGFwZToge1xuICAgIHN5bWJvbFR5cGU6ICcnLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7IC8vIEZJWE1FXG5cbiAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSA9PT0gJ3BpbicgJiYgc3R5bGUudGV4dFBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgICAgc3R5bGUudGV4dFBvc2l0aW9uID0gWyc1MCUnLCAnNDAlJ107XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgfVxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIHZhciBzeW1ib2xUeXBlID0gc2hhcGUuc3ltYm9sVHlwZTtcbiAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG5cbiAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICBpZiAoIXByb3h5U3ltYm9sKSB7XG4gICAgICAgIC8vIERlZmF1bHQgcmVjdFxuICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xuICAgICAgICBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcbiAgICAgIH1cblxuICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGUpO1xuICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUsIGluQnVuZGxlKTtcbiAgICB9XG4gIH1cbn0pOyAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxuXG5mdW5jdGlvbiBzeW1ib2xQYXRoU2V0Q29sb3IoY29sb3IsIGlubmVyQ29sb3IpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgIGlmIChzeW1ib2xTaGFwZSAmJiBzeW1ib2xTaGFwZS5zeW1ib2xUeXBlID09PSAnbGluZScpIHtcbiAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XG4gICAgICBzeW1ib2xTdHlsZS5maWxsID0gaW5uZXJDb2xvciB8fCAnI2ZmZic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZJWE1FIOWIpOaWreWbvuW9oum7mOiupOaYr+Whq+WFhei/mOaYr+aPj+i+ue+8jOS9v+eUqCBvbmx5U3Ryb2tlID9cbiAgICAgIHN5bWJvbFN0eWxlLmZpbGwgJiYgKHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcik7XG4gICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gKiBAcGFyYW0ge251bWJlcn0gaFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwQXNwZWN0PWZhbHNlXSB3aGV0aGVyIHRvIGtlZXAgdGhlIHJhdGlvIG9mIHcvaCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBwYXRoIGFuZCBpbWFnZSBvbmx5LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ltYm9sKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCBrZWVwQXNwZWN0KSB7XG4gIC8vIFRPRE8gU3VwcG9ydCBpbWFnZSBvYmplY3QsIER5bmFtaWNJbWFnZS5cbiAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xuICB9XG5cbiAgdmFyIHN5bWJvbFBhdGg7XG5cbiAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VJbWFnZShzeW1ib2xUeXBlLnNsaWNlKDgpLCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xuICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpLCBrZWVwQXNwZWN0ID8gJ2NlbnRlcicgOiAnY292ZXInKTtcbiAgfSBlbHNlIHtcbiAgICBzeW1ib2xQYXRoID0gbmV3IFN5bWJvbENseih7XG4gICAgICBzaGFwZToge1xuICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgaGVpZ2h0OiBoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcbiAgc3ltYm9sUGF0aC5zZXRDb2xvciA9IHN5bWJvbFBhdGhTZXRDb2xvcjtcbiAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XG4gIHJldHVybiBzeW1ib2xQYXRoO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN5bWJvbCA9IGNyZWF0ZVN5bWJvbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdXRpbC9zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///266\n");

/***/ }),
/* 267 */
/***/ (function(module, exports) {

eval("// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanM/MGE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbnZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xudmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG5mdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICB2YXIgciA9IDA7XG5cbiAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICByIHw9IG4gJiAxO1xuICAgIG4gPj49IDE7XG4gIH1cblxuICByZXR1cm4gbiArIHI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG5cbiAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgaGktLTtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgIGFycmF5W2hpLS1dID0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIGxlZnQgPSBsbztcbiAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICB2YXIgbWlkO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgdmFyIHJ1blN0YXJ0O1xuICB2YXIgcnVuTGVuZ3RoO1xuICB2YXIgc3RhY2tTaXplID0gMDtcbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICB9XG5cbiAgdmFyIHRtcCA9IFtdO1xuICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICBydW5TdGFydCA9IFtdO1xuICBydW5MZW5ndGggPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgIHN0YWNrU2l6ZSArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG4gICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgfVxuXG4gICAgc3RhY2tTaXplLS07XG4gICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICBzdGFydDEgKz0gaztcbiAgICBsZW5ndGgxIC09IGs7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgY291bnQxID0gMDtcbiAgICAgIGNvdW50MiA9IDA7XG4gICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgbWluR2FsbG9wID0gMTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbn1cblxuZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gIGlmICghbG8pIHtcbiAgICBsbyA9IDA7XG4gIH1cblxuICBpZiAoIWhpKSB7XG4gICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydW5MZW5ndGggPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgZG8ge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgIH1cblxuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgIH1cblxuICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICBsbyArPSBydW5MZW5ndGg7XG4gIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///267\n");

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Style = __webpack_require__(292);\n\nvar Element = __webpack_require__(281);\n\nvar RectText = __webpack_require__(375);\n\n/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * z层level，决定绘画在哪层canvas中\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * 是否可拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * 是否正在拖拽\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * 是否相应鼠标事件\n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * 图形绘制方法\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * 获取最小包围盒\n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   * 判断坐标 x, y 是否在图形上\n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   * 判断坐标 x, y 是否在图形的包围盒上\n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * 标记图形元素为脏，并且在下一帧重绘\n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * 图形是否会触发事件\n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO, 通过 bind 绑定的事件\n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzPzVjNDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi9taXhpbi9SZWN0VGV4dFwiKTtcblxuLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gKi9cbmZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTsgLy8gRXh0ZW5kIHByb3BlcnRpZXNcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgKi9cblxuXG4gIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG4gIHRoaXMuX3JlY3QgPSBudWxsOyAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG5cbiAgdGhpcy5fX2NsaXBQYXRocyA9IFtdOyAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG59XG5cbkRpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX19kaXJ0eTogdHJ1ZSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnZpc2libGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHo6IDAsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejI6IDAsXG5cbiAgLyoqXG4gICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgemxldmVsOiAwLFxuXG4gIC8qKlxuICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY3VsbGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAvKipcbiAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHByb2dyZXNzaXZlOiAtMSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAvKipcbiAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAvKipcbiAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICovXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIHJldHVybiAhKFxuICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gIC8vICAgICApO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICB9LFxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAqL1xuICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqLCB0aGlzKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTsgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbnZhciBfZGVmYXVsdCA9IERpc3BsYXlhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///268\n");

/***/ }),
/* 269 */
/***/ (function(module, exports) {

eval("/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzPzUxNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKi9cbnZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG4gIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG59O1xuXG5HcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcbiAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///269\n");

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

eval("var LRU = __webpack_require__(286);\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcz84NTM1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBMUlUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9MUlVcIik7XG5cbnZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5mdW5jdGlvbiBmaW5kRXhpc3RJbWFnZShuZXdJbWFnZU9yU3JjKSB7XG4gIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgcmV0dXJuIGNhY2hlZEltZ09iaiAmJiBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gIH1cbn1cbi8qKlxuICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAqIENvbnNpZGVyIGlmIHJlcXVpcmVkIGltYWdlcyBtb3JlIHRoYW4gTFJVIHNpemUsIHdpbGwgZGVhZCBsb29wIG9jY3VyP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZSBFeGlzdGVudCBpbWFnZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2hvc3RFbF0gRm9yIGNhbGxpbmcgYGRpcnR5YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2JQYXlsb2FkXSBQYXlsb2FkIG9uIGNiIGNhbGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlSW1hZ2UobmV3SW1hZ2VPclNyYywgaW1hZ2UsIGhvc3RFbCwgY2IsIGNiUGF5bG9hZCkge1xuICBpZiAoIW5ld0ltYWdlT3JTcmMpIHtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW1hZ2Ugc2hvdWxkIG5vdCBiZSBsb2FkZWQgcmVwZWF0bHkuXG4gICAgaWYgKGltYWdlICYmIGltYWdlLl9fenJJbWFnZVNyYyA9PT0gbmV3SW1hZ2VPclNyYyB8fCAhaG9zdEVsKSB7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSAvLyBPbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RlbnQgaW1hZ2Ugb3IgZXhpc3RlbnQgaW1hZ2Ugc3JjXG4gICAgLy8gaXMgZGlmZmVyZW50LCB0aGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgbG9hZC5cblxuXG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IHtcbiAgICAgIGhvc3RFbDogaG9zdEVsLFxuICAgICAgY2I6IGNiLFxuICAgICAgY2JQYXlsb2FkOiBjYlBheWxvYWRcbiAgICB9O1xuXG4gICAgaWYgKGNhY2hlZEltZ09iaikge1xuICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XG4gICAgICAhaXNJbWFnZVJlYWR5KGltYWdlKSAmJiBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHBlbmRpbmdXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWltYWdlICYmIChpbWFnZSA9IG5ldyBJbWFnZSgpKTtcbiAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///270\n");

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar coordinateSystemCreators = {};\n\nfunction CoordinateSystemManager() {\n  this._coordinateSystems = [];\n}\n\nCoordinateSystemManager.prototype = {\n  constructor: CoordinateSystemManager,\n  create: function (ecModel, api) {\n    var coordinateSystems = [];\n    zrUtil.each(coordinateSystemCreators, function (creater, type) {\n      var list = creater.create(ecModel, api);\n      coordinateSystems = coordinateSystems.concat(list || []);\n    });\n    this._coordinateSystems = coordinateSystems;\n  },\n  update: function (ecModel, api) {\n    zrUtil.each(this._coordinateSystems, function (coordSys) {\n      // FIXME MUST have\n      coordSys.update && coordSys.update(ecModel, api);\n    });\n  },\n  getCoordinateSystems: function () {\n    return this._coordinateSystems.slice();\n  }\n};\n\nCoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n  coordinateSystemCreators[type] = coordinateSystemCreator;\n};\n\nCoordinateSystemManager.get = function (type) {\n  return coordinateSystemCreators[type];\n};\n\nvar _default = CoordinateSystemManager;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzPzJiMzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMgPSB7fTtcblxuZnVuY3Rpb24gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIoKSB7XG4gIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gW107XG59XG5cbkNvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLFxuICBjcmVhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICB6clV0aWwuZWFjaChjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMsIGZ1bmN0aW9uIChjcmVhdGVyLCB0eXBlKSB7XG4gICAgICB2YXIgbGlzdCA9IGNyZWF0ZXIuY3JlYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICBjb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zLmNvbmNhdChsaXN0IHx8IFtdKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLl9jb29yZGluYXRlU3lzdGVtcywgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgICAvLyBGSVhNRSBNVVNUIGhhdmVcbiAgICAgIGNvb3JkU3lzLnVwZGF0ZSAmJiBjb29yZFN5cy51cGRhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0Q29vcmRpbmF0ZVN5c3RlbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMuc2xpY2UoKTtcbiAgfVxufTtcblxuQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAodHlwZSwgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3IpIHtcbiAgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdID0gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3I7XG59O1xuXG5Db29yZGluYXRlU3lzdGVtTWFuYWdlci5nZXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICByZXR1cm4gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdO1xufTtcblxudmFyIF9kZWZhdWx0ID0gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9Db29yZGluYXRlU3lzdGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///271\n");

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar _model = __webpack_require__(234);\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/**\n * Complete dimensions by data (guess dimension).\n */\nvar each = zrUtil.each;\nvar isString = zrUtil.isString;\nvar defaults = zrUtil.defaults;\nvar OTHER_DIMS = {\n  tooltip: 1,\n  label: 1,\n  itemName: 1\n};\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\n\nfunction completeDimensions(sysDims, data, opt) {\n  data = data || [];\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n  var dataDimNameMap = zrUtil.createHashMap();\n  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;\n\n  var result = [];\n  var dimCount = opt.dimCount;\n\n  if (dimCount == null) {\n    var value0 = retrieveValue(data[0]);\n    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);\n    each(sysDims, function (sysDimItem) {\n      var sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n    });\n  } // Apply user defined dims (`name` and `type`) and init result.\n\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItem = isString(dimsDef[i]) ? {\n      name: dimsDef[i]\n    } : dimsDef[i] || {};\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = {\n      otherDims: {}\n    }; // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option, tooltipName\n      // will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.tooltipName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n\n\n  encodeDef.each(function (dataDims, coordDim) {\n    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      // The input resultDimIdx can be dim name or index.\n      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        dataDims[coordDimIndex] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItem, sysDimIndex) {\n    var coordDim;\n    var sysDimItem;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n\n    if (isString(sysDimItem)) {\n      coordDim = sysDimItem;\n      sysDimItem = {};\n    } else {\n      coordDim = sysDimItem.name;\n      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n      }\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  }); // Make sure the first extra dim is 'value'.\n\n  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n    var coordDim = resultItem.coordDim;\n    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));\n    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');\n  }\n\n  return result;\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (OTHER_DIMS[coordDim]) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n\n  function genName(name, map, fromZero) {\n    if (fromZero || map.get(name) != null) {\n      var i = 0;\n\n      while (map.get(name + i) != null) {\n        i++;\n      }\n\n      name += i;\n    }\n\n    map.set(name, true);\n    return name;\n  }\n} // The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\n\n\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var value = retrieveValue(data[i]);\n\n    if (!zrUtil.isArray(value)) {\n      return false;\n    }\n\n    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (value != null && isFinite(value) && value !== '') {\n      return false;\n    } else if (isString(value) && value !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction retrieveValue(o) {\n  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n}\n\nvar _default = completeDimensions;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanM/OWM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9tb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgbm9ybWFsaXplVG9BcnJheSA9IF9tb2RlbC5ub3JtYWxpemVUb0FycmF5O1xuXG4vKipcbiAqIENvbXBsZXRlIGRpbWVuc2lvbnMgYnkgZGF0YSAoZ3Vlc3MgZGltZW5zaW9uKS5cbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc1N0cmluZyA9IHpyVXRpbC5pc1N0cmluZztcbnZhciBkZWZhdWx0cyA9IHpyVXRpbC5kZWZhdWx0cztcbnZhciBPVEhFUl9ESU1TID0ge1xuICB0b29sdGlwOiAxLFxuICBsYWJlbDogMSxcbiAgaXRlbU5hbWU6IDFcbn07XG4vKipcbiAqIENvbXBsZXRlIHRoZSBkaW1lbnNpb25zIGFycmF5LCBieSB1c2VyIGRlZmluZWQgYGRpbWVuc2lvbmAgYW5kIGBlbmNvZGVgLFxuICogYW5kIGd1ZXNzaW5nIGZyb20gdGhlIGRhdGEgc3RydWN0dXJlLlxuICogSWYgbm8gJ3ZhbHVlJyBkaW1lbnNpb24gc3BlY2lmaWVkLCB0aGUgZmlyc3Qgbm8tbmFtZWQgZGltZW5zaW9uIHdpbGwgYmVcbiAqIG5hbWVkIGFzICd2YWx1ZScuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3lzRGltcyBOZWNlc3NhcnkgZGltZW5zaW9ucywgbGlrZSBbJ3gnLCAneSddLCB3aGljaFxuICogICAgICBwcm92aWRlcyBub3Qgb25seSBkaW0gdGVtcGxhdGUsIGJ1dCBhbHNvIGRlZmF1bHQgb3JkZXIuXG4gKiAgICAgIGBuYW1lYCBvZiBlYWNoIGl0ZW0gcHJvdmlkZXMgZGVmYXVsdCBjb29yZCBuYW1lLlxuICogICAgICBbe2RpbXNEZWY6IFtdfSwgLi4uXSBjYW4gYmUgc3BlY2lmaWVkIHRvIGdpdmUgbmFtZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIERhdGEgbGlzdC4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdXS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0fHN0cmluZz59IFtvcHQuZGltc0RlZl0gb3B0aW9uLnNlcmllcy5kaW1lbnNpb25zIFVzZXIgZGVmaW5lZCBkaW1lbnNpb25zXG4gKiAgICAgIEZvciBleGFtcGxlOiBbJ2FzZGYnLCB7bmFtZSwgdHlwZX0sIC4uLl0uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdC5lbmNvZGVEZWZdIG9wdGlvbi5zZXJpZXMuZW5jb2RlIHt4OiAyLCB5OiBbMywgMV0sIHRvb2x0aXA6IFsxLCAyXSwgbGFiZWw6IDN9XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5leHRyYVByZWZpeF0gUHJlZml4IG9mIG5hbWUgd2hlbiBmaWxsaW5nIHRoZSBsZWZ0IGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdC5leHRyYUZyb21aZXJvXSBJZiBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXggKyAwLCBleHRyYVByZWZpeCArIGV4dHJhQmFzZUluZGV4ICsgMSAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBzcGVjaWZpZWQsIGV4dHJhIGRpbSBuYW1lcyB3aWxsIGJlOlxuICogICAgICAgICAgICAgICAgICAgICAgZXh0cmFQcmVmaXgsIGV4dHJhUHJlZml4ICsgMCwgZXh0cmFQcmVmaXggKyAxIC4uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZGltQ291bnRdIElmIG5vdCBzcGVjaWZpZWQsIGd1ZXNzIGJ5IHRoZSBmaXJzdCBkYXRhIGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gW3tcbiAqICAgICAgbmFtZTogc3RyaW5nIG1hbmRhdG9yeSxcbiAqICAgICAgY29vcmREaW06IHN0cmluZyBtYW5kYXRvcnksXG4gKiAgICAgIGNvb3JkRGltSW5kZXg6IG51bWJlciBtYW5kYXRvcnksXG4gKiAgICAgIHR5cGU6IHN0cmluZyBvcHRpb25hbCxcbiAqICAgICAgdG9vbHRpcE5hbWU6IHN0cmluZyBvcHRpb25hbCxcbiAqICAgICAgb3RoZXJEaW1zOiB7XG4gKiAgICAgICAgICB0b29sdGlwOiBudW1iZXIgb3B0aW9uYWwsXG4gKiAgICAgICAgICBsYWJlbDogbnVtYmVyIG9wdGlvbmFsXG4gKiAgICAgIH0sXG4gKiAgICAgIGlzRXh0cmFDb29yZDogYm9vbGVhbiB0cnVlIG9yIHVuZGVmaW5lZC5cbiAqICAgICAgb3RoZXIgcHJvcHMgLi4uXG4gKiB9XVxuICovXG5cbmZ1bmN0aW9uIGNvbXBsZXRlRGltZW5zaW9ucyhzeXNEaW1zLCBkYXRhLCBvcHQpIHtcbiAgZGF0YSA9IGRhdGEgfHwgW107XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgc3lzRGltcyA9IChzeXNEaW1zIHx8IFtdKS5zbGljZSgpO1xuICB2YXIgZGltc0RlZiA9IChvcHQuZGltc0RlZiB8fCBbXSkuc2xpY2UoKTtcbiAgdmFyIGVuY29kZURlZiA9IHpyVXRpbC5jcmVhdGVIYXNoTWFwKG9wdC5lbmNvZGVEZWYpO1xuICB2YXIgZGF0YURpbU5hbWVNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICB2YXIgY29vcmREaW1OYW1lTWFwID0genJVdGlsLmNyZWF0ZUhhc2hNYXAoKTsgLy8gdmFyIHZhbHVlQ2FuZGlkYXRlO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGRpbUNvdW50ID0gb3B0LmRpbUNvdW50O1xuXG4gIGlmIChkaW1Db3VudCA9PSBudWxsKSB7XG4gICAgdmFyIHZhbHVlMCA9IHJldHJpZXZlVmFsdWUoZGF0YVswXSk7XG4gICAgZGltQ291bnQgPSBNYXRoLm1heCh6clV0aWwuaXNBcnJheSh2YWx1ZTApICYmIHZhbHVlMC5sZW5ndGggfHwgMSwgc3lzRGltcy5sZW5ndGgsIGRpbXNEZWYubGVuZ3RoKTtcbiAgICBlYWNoKHN5c0RpbXMsIGZ1bmN0aW9uIChzeXNEaW1JdGVtKSB7XG4gICAgICB2YXIgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICBzeXNEaW1JdGVtRGltc0RlZiAmJiAoZGltQ291bnQgPSBNYXRoLm1heChkaW1Db3VudCwgc3lzRGltSXRlbURpbXNEZWYubGVuZ3RoKSk7XG4gICAgfSk7XG4gIH0gLy8gQXBwbHkgdXNlciBkZWZpbmVkIGRpbXMgKGBuYW1lYCBhbmQgYHR5cGVgKSBhbmQgaW5pdCByZXN1bHQuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUNvdW50OyBpKyspIHtcbiAgICB2YXIgZGltRGVmSXRlbSA9IGlzU3RyaW5nKGRpbXNEZWZbaV0pID8ge1xuICAgICAgbmFtZTogZGltc0RlZltpXVxuICAgIH0gOiBkaW1zRGVmW2ldIHx8IHt9O1xuICAgIHZhciB1c2VyRGltTmFtZSA9IGRpbURlZkl0ZW0ubmFtZTtcbiAgICB2YXIgcmVzdWx0SXRlbSA9IHJlc3VsdFtpXSA9IHtcbiAgICAgIG90aGVyRGltczoge31cbiAgICB9OyAvLyBOYW1lIHdpbGwgYmUgYXBwbGllZCBsYXRlciBmb3IgYXZvaWRpbmcgZHVwbGljYXRpb24uXG5cbiAgICBpZiAodXNlckRpbU5hbWUgIT0gbnVsbCAmJiBkYXRhRGltTmFtZU1hcC5nZXQodXNlckRpbU5hbWUpID09IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgaWYgYHNlcmllcy5kaW1lbnNpb25zYCBpcyBkZWZpbmVkIGluIG9wdGlvbiwgdG9vbHRpcE5hbWVcbiAgICAgIC8vIHdpbGwgYmUgc2V0LCBhbmQgZGltZW5zaW9uIHdpbGwgYmUgZGlwbGF5ZWQgdmVydGljYWxseSBpblxuICAgICAgLy8gdG9vbHRpcCBieSBkZWZhdWx0LlxuICAgICAgcmVzdWx0SXRlbS5uYW1lID0gcmVzdWx0SXRlbS50b29sdGlwTmFtZSA9IHVzZXJEaW1OYW1lO1xuICAgICAgZGF0YURpbU5hbWVNYXAuc2V0KHVzZXJEaW1OYW1lLCBpKTtcbiAgICB9XG5cbiAgICBkaW1EZWZJdGVtLnR5cGUgIT0gbnVsbCAmJiAocmVzdWx0SXRlbS50eXBlID0gZGltRGVmSXRlbS50eXBlKTtcbiAgfSAvLyBTZXQgYGNvb3JkRGltYCBhbmQgYGNvb3JkRGltSW5kZXhgIGJ5IGBlbmNvZGVEZWZgIGFuZCBub3JtYWxpemUgYGVuY29kZURlZmAuXG5cblxuICBlbmNvZGVEZWYuZWFjaChmdW5jdGlvbiAoZGF0YURpbXMsIGNvb3JkRGltKSB7XG4gICAgZGF0YURpbXMgPSBlbmNvZGVEZWYuc2V0KGNvb3JkRGltLCBub3JtYWxpemVUb0FycmF5KGRhdGFEaW1zKS5zbGljZSgpKTtcbiAgICBlYWNoKGRhdGFEaW1zLCBmdW5jdGlvbiAocmVzdWx0RGltSWR4LCBjb29yZERpbUluZGV4KSB7XG4gICAgICAvLyBUaGUgaW5wdXQgcmVzdWx0RGltSWR4IGNhbiBiZSBkaW0gbmFtZSBvciBpbmRleC5cbiAgICAgIGlzU3RyaW5nKHJlc3VsdERpbUlkeCkgJiYgKHJlc3VsdERpbUlkeCA9IGRhdGFEaW1OYW1lTWFwLmdldChyZXN1bHREaW1JZHgpKTtcblxuICAgICAgaWYgKHJlc3VsdERpbUlkeCAhPSBudWxsICYmIHJlc3VsdERpbUlkeCA8IGRpbUNvdW50KSB7XG4gICAgICAgIGRhdGFEaW1zW2Nvb3JkRGltSW5kZXhdID0gcmVzdWx0RGltSWR4O1xuICAgICAgICBhcHBseURpbShyZXN1bHRbcmVzdWx0RGltSWR4XSwgY29vcmREaW0sIGNvb3JkRGltSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gQXBwbHkgdGVtcGxldGVzIGFuZCBkZWZhdWx0IG9yZGVyIGZyb20gYHN5c0RpbXNgLlxuXG4gIHZhciBhdmFpbERpbUlkeCA9IDA7XG4gIGVhY2goc3lzRGltcywgZnVuY3Rpb24gKHN5c0RpbUl0ZW0sIHN5c0RpbUluZGV4KSB7XG4gICAgdmFyIGNvb3JkRGltO1xuICAgIHZhciBzeXNEaW1JdGVtO1xuICAgIHZhciBzeXNEaW1JdGVtRGltc0RlZjtcbiAgICB2YXIgc3lzRGltSXRlbU90aGVyRGltcztcblxuICAgIGlmIChpc1N0cmluZyhzeXNEaW1JdGVtKSkge1xuICAgICAgY29vcmREaW0gPSBzeXNEaW1JdGVtO1xuICAgICAgc3lzRGltSXRlbSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZERpbSA9IHN5c0RpbUl0ZW0ubmFtZTtcbiAgICAgIHN5c0RpbUl0ZW0gPSB6clV0aWwuY2xvbmUoc3lzRGltSXRlbSk7IC8vIGBjb29yZERpbUluZGV4YCBzaG91bGQgbm90IGJlIHNldCBkaXJlY3RseS5cblxuICAgICAgc3lzRGltSXRlbURpbXNEZWYgPSBzeXNEaW1JdGVtLmRpbXNEZWY7XG4gICAgICBzeXNEaW1JdGVtT3RoZXJEaW1zID0gc3lzRGltSXRlbS5vdGhlckRpbXM7XG4gICAgICBzeXNEaW1JdGVtLm5hbWUgPSBzeXNEaW1JdGVtLmNvb3JkRGltID0gc3lzRGltSXRlbS5jb29yZERpbUluZGV4ID0gc3lzRGltSXRlbS5kaW1zRGVmID0gc3lzRGltSXRlbS5vdGhlckRpbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBkYXRhRGltcyA9IG5vcm1hbGl6ZVRvQXJyYXkoZW5jb2RlRGVmLmdldChjb29yZERpbSkpOyAvLyBkaW1lbnNpb25zIHByb3ZpZGVzIGRlZmF1bHQgZGltIHNlcXVlbmNlcy5cblxuICAgIGlmICghZGF0YURpbXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChzeXNEaW1JdGVtRGltc0RlZiAmJiBzeXNEaW1JdGVtRGltc0RlZi5sZW5ndGggfHwgMSk7IGkrKykge1xuICAgICAgICB3aGlsZSAoYXZhaWxEaW1JZHggPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFthdmFpbERpbUlkeF0uY29vcmREaW0gIT0gbnVsbCkge1xuICAgICAgICAgIGF2YWlsRGltSWR4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBhdmFpbERpbUlkeCA8IHJlc3VsdC5sZW5ndGggJiYgZGF0YURpbXMucHVzaChhdmFpbERpbUlkeCsrKTtcbiAgICAgIH1cbiAgICB9IC8vIEFwcGx5IHRlbXBsYXRlcy5cblxuXG4gICAgZWFjaChkYXRhRGltcywgZnVuY3Rpb24gKHJlc3VsdERpbUlkeCwgY29vcmREaW1JbmRleCkge1xuICAgICAgdmFyIHJlc3VsdEl0ZW0gPSByZXN1bHRbcmVzdWx0RGltSWR4XTtcbiAgICAgIGFwcGx5RGltKGRlZmF1bHRzKHJlc3VsdEl0ZW0sIHN5c0RpbUl0ZW0pLCBjb29yZERpbSwgY29vcmREaW1JbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiBzeXNEaW1JdGVtRGltc0RlZikge1xuICAgICAgICByZXN1bHRJdGVtLm5hbWUgPSByZXN1bHRJdGVtLnRvb2x0aXBOYW1lID0gc3lzRGltSXRlbURpbXNEZWZbY29vcmREaW1JbmRleF07XG4gICAgICB9XG5cbiAgICAgIHN5c0RpbUl0ZW1PdGhlckRpbXMgJiYgZGVmYXVsdHMocmVzdWx0SXRlbS5vdGhlckRpbXMsIHN5c0RpbUl0ZW1PdGhlckRpbXMpO1xuICAgIH0pO1xuICB9KTsgLy8gTWFrZSBzdXJlIHRoZSBmaXJzdCBleHRyYSBkaW0gaXMgJ3ZhbHVlJy5cblxuICB2YXIgZXh0cmEgPSBvcHQuZXh0cmFQcmVmaXggfHwgJ3ZhbHVlJzsgLy8gU2V0IGRpbSBgbmFtZWAgYW5kIG90aGVyIGBjb29yZERpbWAgYW5kIG90aGVyIHByb3BzLlxuXG4gIGZvciAodmFyIHJlc3VsdERpbUlkeCA9IDA7IHJlc3VsdERpbUlkeCA8IGRpbUNvdW50OyByZXN1bHREaW1JZHgrKykge1xuICAgIHZhciByZXN1bHRJdGVtID0gcmVzdWx0W3Jlc3VsdERpbUlkeF0gPSByZXN1bHRbcmVzdWx0RGltSWR4XSB8fCB7fTtcbiAgICB2YXIgY29vcmREaW0gPSByZXN1bHRJdGVtLmNvb3JkRGltO1xuICAgIGNvb3JkRGltID09IG51bGwgJiYgKHJlc3VsdEl0ZW0uY29vcmREaW0gPSBnZW5OYW1lKGV4dHJhLCBjb29yZERpbU5hbWVNYXAsIG9wdC5leHRyYUZyb21aZXJvKSwgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gMCwgcmVzdWx0SXRlbS5pc0V4dHJhQ29vcmQgPSB0cnVlKTtcbiAgICByZXN1bHRJdGVtLm5hbWUgPT0gbnVsbCAmJiAocmVzdWx0SXRlbS5uYW1lID0gZ2VuTmFtZShyZXN1bHRJdGVtLmNvb3JkRGltLCBkYXRhRGltTmFtZU1hcCkpO1xuICAgIHJlc3VsdEl0ZW0udHlwZSA9PSBudWxsICYmIGd1ZXNzT3JkaW5hbChkYXRhLCByZXN1bHREaW1JZHgpICYmIChyZXN1bHRJdGVtLnR5cGUgPSAnb3JkaW5hbCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxuICBmdW5jdGlvbiBhcHBseURpbShyZXN1bHRJdGVtLCBjb29yZERpbSwgY29vcmREaW1JbmRleCkge1xuICAgIGlmIChPVEhFUl9ESU1TW2Nvb3JkRGltXSkge1xuICAgICAgcmVzdWx0SXRlbS5vdGhlckRpbXNbY29vcmREaW1dID0gY29vcmREaW1JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbSA9IGNvb3JkRGltO1xuICAgICAgcmVzdWx0SXRlbS5jb29yZERpbUluZGV4ID0gY29vcmREaW1JbmRleDtcbiAgICAgIGNvb3JkRGltTmFtZU1hcC5zZXQoY29vcmREaW0sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk5hbWUobmFtZSwgbWFwLCBmcm9tWmVybykge1xuICAgIGlmIChmcm9tWmVybyB8fCBtYXAuZ2V0KG5hbWUpICE9IG51bGwpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKG1hcC5nZXQobmFtZSArIGkpICE9IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICBuYW1lICs9IGk7XG4gICAgfVxuXG4gICAgbWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufSAvLyBUaGUgcnVsZSBzaG91bGQgbm90IGJlIGNvbXBsZXgsIG90aGVyd2lzZSB1c2VyIG1pZ2h0IG5vdFxuLy8gYmUgYWJsZSB0byBrbm93biB3aGVyZSB0aGUgZGF0YSBpcyB3cm9uZy5cblxuXG52YXIgZ3Vlc3NPcmRpbmFsID0gY29tcGxldGVEaW1lbnNpb25zLmd1ZXNzT3JkaW5hbCA9IGZ1bmN0aW9uIChkYXRhLCBkaW1JbmRleCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlVmFsdWUoZGF0YVtpXSk7XG5cbiAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHZhbHVlW2RpbUluZGV4XTsgLy8gQ29uc2lkZXIgdXNhZ2UgY29udmVuaWVuY2UsICcxJywgJzInIHdpbGwgYmUgdHJlYXRlZCBhcyBcIm51bWJlclwiLlxuICAgIC8vIGBpc0Zpbml0KCcnKWAgZ2V0IGB0cnVlYC5cblxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVZhbHVlKG8pIHtcbiAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KG8pID8gbyA6IHpyVXRpbC5pc09iamVjdChvKSA/IG8udmFsdWUgOiBvO1xufVxuXG52YXIgX2RlZmF1bHQgPSBjb21wbGV0ZURpbWVuc2lvbnM7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///272\n");

/***/ }),
/* 273 */
/***/ (function(module, exports) {

eval("var ORIGIN_METHOD = '\\0__throttleOriginMethod';\nvar RATE = '\\0__throttleRate';\nvar THROTTLE_TYPE = '\\0__throttleType';\n/**\n * @public\n * @param {(Function)} fn\n * @param {number} [delay=0] Unit: ms.\n * @param {boolean} [debounce=false]\n *        true: If call interval less than `delay`, only the last call works.\n *        false: If call interval less than `delay, call works on fixed rate.\n * @return {(Function)} throttled fn.\n */\n\nfunction throttle(fn, delay, debounce) {\n  var currCall;\n  var lastCall = 0;\n  var lastExec = 0;\n  var timer = null;\n  var diff;\n  var scope;\n  var args;\n  var debounceNextCall;\n  delay = delay || 0;\n\n  function exec() {\n    lastExec = new Date().getTime();\n    timer = null;\n    fn.apply(scope, args || []);\n  }\n\n  var cb = function () {\n    currCall = new Date().getTime();\n    scope = this;\n    args = arguments;\n    var thisDelay = debounceNextCall || delay;\n    var thisDebounce = debounceNextCall || debounce;\n    debounceNextCall = null;\n    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n    clearTimeout(timer);\n\n    if (thisDebounce) {\n      timer = setTimeout(exec, thisDelay);\n    } else {\n      if (diff >= 0) {\n        exec();\n      } else {\n        timer = setTimeout(exec, -diff);\n      }\n    }\n\n    lastCall = currCall;\n  };\n  /**\n   * Clear throttle.\n   * @public\n   */\n\n\n  cb.clear = function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  /**\n   * Enable debounce once.\n   */\n\n\n  cb.debounceNextCall = function (debounceDelay) {\n    debounceNextCall = debounceDelay;\n  };\n\n  return cb;\n}\n/**\n * Create throttle method or update throttle rate.\n *\n * @example\n * ComponentView.prototype.render = function () {\n *     ...\n *     throttle.createOrUpdate(\n *         this,\n *         '_dispatchAction',\n *         this.model.get('throttle'),\n *         'fixRate'\n *     );\n * };\n * ComponentView.prototype.remove = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n * ComponentView.prototype.dispose = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n * @param {number} [rate]\n * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n * @return {Function} throttled function.\n */\n\n\nfunction createOrUpdate(obj, fnAttr, rate, throttleType) {\n  var fn = obj[fnAttr];\n\n  if (!fn) {\n    return;\n  }\n\n  var originFn = fn[ORIGIN_METHOD] || fn;\n  var lastThrottleType = fn[THROTTLE_TYPE];\n  var lastRate = fn[RATE];\n\n  if (lastRate !== rate || lastThrottleType !== throttleType) {\n    if (rate == null || !throttleType) {\n      return obj[fnAttr] = originFn;\n    }\n\n    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');\n    fn[ORIGIN_METHOD] = originFn;\n    fn[THROTTLE_TYPE] = throttleType;\n    fn[RATE] = rate;\n  }\n\n  return fn;\n}\n/**\n * Clear throttle. Example see throttle.createOrUpdate.\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n */\n\n\nfunction clear(obj, fnAttr) {\n  var fn = obj[fnAttr];\n\n  if (fn && fn[ORIGIN_METHOD]) {\n    obj[fnAttr] = fn[ORIGIN_METHOD];\n  }\n}\n\nexports.throttle = throttle;\nexports.createOrUpdate = createOrUpdate;\nexports.clear = clear;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi91dGlsL3Rocm90dGxlLmpzPzU2YjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG52YXIgUkFURSA9ICdcXDBfX3Rocm90dGxlUmF0ZSc7XG52YXIgVEhST1RUTEVfVFlQRSA9ICdcXDBfX3Rocm90dGxlVHlwZSc7XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7KEZ1bmN0aW9uKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVW5pdDogbXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAqICAgICAgICB0cnVlOiBJZiBjYWxsIGludGVydmFsIGxlc3MgdGhhbiBgZGVsYXlgLCBvbmx5IHRoZSBsYXN0IGNhbGwgd29ya3MuXG4gKiAgICAgICAgZmFsc2U6IElmIGNhbGwgaW50ZXJ2YWwgbGVzcyB0aGFuIGBkZWxheSwgY2FsbCB3b3JrcyBvbiBmaXhlZCByYXRlLlxuICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBkZWxheSwgZGVib3VuY2UpIHtcbiAgdmFyIGN1cnJDYWxsO1xuICB2YXIgbGFzdENhbGwgPSAwO1xuICB2YXIgbGFzdEV4ZWMgPSAwO1xuICB2YXIgdGltZXIgPSBudWxsO1xuICB2YXIgZGlmZjtcbiAgdmFyIHNjb3BlO1xuICB2YXIgYXJncztcbiAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG4gIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICBmdW5jdGlvbiBleGVjKCkge1xuICAgIGxhc3RFeGVjID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGltZXIgPSBudWxsO1xuICAgIGZuLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgfVxuXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyQ2FsbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHNjb3BlID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciB0aGlzRGVsYXkgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlbGF5O1xuICAgIHZhciB0aGlzRGVib3VuY2UgPSBkZWJvdW5jZU5leHRDYWxsIHx8IGRlYm91bmNlO1xuICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgIGRpZmYgPSBjdXJyQ2FsbCAtICh0aGlzRGVib3VuY2UgPyBsYXN0Q2FsbCA6IGxhc3RFeGVjKSAtIHRoaXNEZWxheTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgaWYgKHRoaXNEZWJvdW5jZSkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgICAgZXhlYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIC1kaWZmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXIgdGhyb3R0bGUuXG4gICAqIEBwdWJsaWNcbiAgICovXG5cblxuICBjYi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAqL1xuXG5cbiAgY2IuZGVib3VuY2VOZXh0Q2FsbCA9IGZ1bmN0aW9uIChkZWJvdW5jZURlbGF5KSB7XG4gICAgZGVib3VuY2VOZXh0Q2FsbCA9IGRlYm91bmNlRGVsYXk7XG4gIH07XG5cbiAgcmV0dXJuIGNiO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhyb3R0bGUgbWV0aG9kIG9yIHVwZGF0ZSB0aHJvdHRsZSByYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gKiAgICAgICAgIHRoaXMsXG4gKiAgICAgICAgICdfZGlzcGF0Y2hBY3Rpb24nLFxuICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAqICAgICAgICAgJ2ZpeFJhdGUnXG4gKiAgICAgKTtcbiAqIH07XG4gKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqIENvbXBvbmVudFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaEFjdGlvbicpO1xuICogfTtcbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5BdHRyXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICBpZiAoIWZuKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbkZuID0gZm5bT1JJR0lOX01FVEhPRF0gfHwgZm47XG4gIHZhciBsYXN0VGhyb3R0bGVUeXBlID0gZm5bVEhST1RUTEVfVFlQRV07XG4gIHZhciBsYXN0UmF0ZSA9IGZuW1JBVEVdO1xuXG4gIGlmIChsYXN0UmF0ZSAhPT0gcmF0ZSB8fCBsYXN0VGhyb3R0bGVUeXBlICE9PSB0aHJvdHRsZVR5cGUpIHtcbiAgICBpZiAocmF0ZSA9PSBudWxsIHx8ICF0aHJvdHRsZVR5cGUpIHtcbiAgICAgIHJldHVybiBvYmpbZm5BdHRyXSA9IG9yaWdpbkZuO1xuICAgIH1cblxuICAgIGZuID0gb2JqW2ZuQXR0cl0gPSB0aHJvdHRsZShvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnKTtcbiAgICBmbltPUklHSU5fTUVUSE9EXSA9IG9yaWdpbkZuO1xuICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgIGZuW1JBVEVdID0gcmF0ZTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cbi8qKlxuICogQ2xlYXIgdGhyb3R0bGUuIEV4YW1wbGUgc2VlIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsZWFyKG9iaiwgZm5BdHRyKSB7XG4gIHZhciBmbiA9IG9ialtmbkF0dHJdO1xuXG4gIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgIG9ialtmbkF0dHJdID0gZm5bT1JJR0lOX01FVEhPRF07XG4gIH1cbn1cblxuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZSA9IGNyZWF0ZU9yVXBkYXRlO1xuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi91dGlsL3Rocm90dGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///273\n");

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar List = __webpack_require__(263);\n\nvar completeDimensions = __webpack_require__(272);\n\nvar _model = __webpack_require__(234);\n\nvar getDataItemValue = _model.getDataItemValue;\nvar converDataValue = _model.converDataValue;\nvar isDataItemOption = _model.isDataItemOption;\n\nvar CoordinateSystem = __webpack_require__(271);\n\nfunction firstDataNotNull(data) {\n  var i = 0;\n\n  while (i < data.length && data[i] == null) {\n    i++;\n  }\n\n  return data[i];\n}\n\nfunction ifNeedCompleteOrdinalData(data) {\n  var sampleItem = firstDataNotNull(data);\n  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n}\n/**\n * Helper function to create a list from option data\n */\n\n\nfunction createListFromArray(data, seriesModel, ecModel) {\n  // If data is undefined\n  data = data || [];\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var creator = creators[coordSysName];\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var completeDimOpt = {\n    encodeDef: seriesModel.get('encode'),\n    dimsDef: seriesModel.get('dimensions')\n  }; // FIXME\n\n  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n  var dimensions = axesInfo && axesInfo.dimensions;\n\n  if (!dimensions) {\n    // Get dimensions from registered coordinate system\n    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n  }\n\n  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n  var list = new List(dimensions, seriesModel);\n  var nameList = createNameList(axesInfo, data);\n  var categories = {};\n  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // If any dataItem is like { value: 10 }\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    } // Use dataIndex as ordinal value in categoryAxis\n\n\n    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n  } : function (itemOpt, dimName, dataIndex, dimIndex) {\n    var value = getDataItemValue(itemOpt);\n    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }\n\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    }\n\n    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\n    if (categoryAxesModels && categoryAxesModels[dimName]) {\n      // If given value is a category string\n      if (typeof val === 'string') {\n        // Lazy get categories\n        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n        val = zrUtil.indexOf(categories[dimName], val);\n\n        if (val < 0 && !isNaN(val)) {\n          // In case some one write '1', '2' istead of 1, 2\n          val = +val;\n        }\n      }\n    }\n\n    return val;\n  };\n  list.hasItemOption = false;\n  list.initData(data, nameList, dimValueGetter);\n  return list;\n}\n\nfunction isStackable(axisType) {\n  return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n/**\n * Creaters for each coord system.\n */\n\n\nvar creators = {\n  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n      return ecModel.queryComponents({\n        mainType: name,\n        index: seriesModel.get(name + 'Index'),\n        id: seriesModel.get(name + 'Id')\n      })[0];\n    });\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var dimensions = [{\n      name: 'x',\n      type: getDimTypeByAxis(xAxisType),\n      stackable: isStackable(xAxisType)\n    }, {\n      name: 'y',\n      // If two category axes\n      type: getDimTypeByAxis(yAxisType),\n      stackable: isStackable(yAxisType)\n    }];\n    var isXAxisCateogry = xAxisType === 'category';\n    var isYAxisCategory = yAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isXAxisCateogry) {\n      categoryAxesModels.x = xAxisModel;\n    }\n\n    if (isYAxisCategory) {\n      categoryAxesModels.y = yAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: seriesModel.get('singleAxisIndex'),\n      id: seriesModel.get('singleAxisId')\n    })[0];\n    var singleAxisType = singleAxisModel.get('type');\n    var isCategory = singleAxisType === 'category';\n    var dimensions = [{\n      name: 'single',\n      type: getDimTypeByAxis(singleAxisType),\n      stackable: isStackable(singleAxisType)\n    }];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isCategory) {\n      categoryAxesModels.single = singleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isCategory ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  polar: function (data, seriesModel, ecModel, completeDimOpt) {\n    var polarModel = ecModel.queryComponents({\n      mainType: 'polar',\n      index: seriesModel.get('polarIndex'),\n      id: seriesModel.get('polarId')\n    })[0];\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var radiusAxisType = radiusAxisModel.get('type');\n    var angleAxisType = angleAxisModel.get('type');\n    var dimensions = [{\n      name: 'radius',\n      type: getDimTypeByAxis(radiusAxisType),\n      stackable: isStackable(radiusAxisType)\n    }, {\n      name: 'angle',\n      type: getDimTypeByAxis(angleAxisType),\n      stackable: isStackable(angleAxisType)\n    }];\n    var isAngleAxisCateogry = angleAxisType === 'category';\n    var isRadiusAxisCateogry = radiusAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isRadiusAxisCateogry) {\n      categoryAxesModels.radius = radiusAxisModel;\n    }\n\n    if (isAngleAxisCateogry) {\n      categoryAxesModels.angle = angleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  geo: function (data, seriesModel, ecModel, completeDimOpt) {\n    // TODO Region\n    // 多个散点图系列在同一个地区的时候\n    return {\n      dimensions: completeDimensions([{\n        name: 'lng'\n      }, {\n        name: 'lat'\n      }], data, completeDimOpt)\n    };\n  }\n};\n\nfunction createNameList(result, data) {\n  var nameList = [];\n  var categoryDim = result && result.dimensions[result.categoryIndex];\n  var categoryAxisModel;\n\n  if (categoryDim) {\n    categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n  }\n\n  if (categoryAxisModel) {\n    // FIXME Two category axis\n    var categories = categoryAxisModel.getCategories();\n\n    if (categories) {\n      var dataLen = data.length; // Ordered data is given explicitly like\n      // [[3, 0.2], [1, 0.3], [2, 0.15]]\n      // or given scatter data,\n      // pick the category\n\n      if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n        nameList = [];\n\n        for (var i = 0; i < dataLen; i++) {\n          nameList[i] = categories[data[i][result.categoryIndex || 0]];\n        }\n      } else {\n        nameList = categories.slice(0);\n      }\n    }\n  }\n\n  return nameList;\n}\n\nvar _default = createListFromArray;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qcz9lM2ZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9fREVWX18gPSBfY29uZmlnLl9fREVWX187XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0xpc3RcIik7XG5cbnZhciBjb21wbGV0ZURpbWVuc2lvbnMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zXCIpO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBnZXREYXRhSXRlbVZhbHVlID0gX21vZGVsLmdldERhdGFJdGVtVmFsdWU7XG52YXIgY29udmVyRGF0YVZhbHVlID0gX21vZGVsLmNvbnZlckRhdGFWYWx1ZTtcbnZhciBpc0RhdGFJdGVtT3B0aW9uID0gX21vZGVsLmlzRGF0YUl0ZW1PcHRpb247XG5cbnZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW1cIik7XG5cbmZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoZGF0YSkge1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCAmJiBkYXRhW2ldID09IG51bGwpIHtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gZGF0YVtpXTtcbn1cblxuZnVuY3Rpb24gaWZOZWVkQ29tcGxldGVPcmRpbmFsRGF0YShkYXRhKSB7XG4gIHZhciBzYW1wbGVJdGVtID0gZmlyc3REYXRhTm90TnVsbChkYXRhKTtcbiAgcmV0dXJuIHNhbXBsZUl0ZW0gIT0gbnVsbCAmJiAhenJVdGlsLmlzQXJyYXkoZ2V0RGF0YUl0ZW1WYWx1ZShzYW1wbGVJdGVtKSk7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaXN0IGZyb20gb3B0aW9uIGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgLy8gSWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgZGF0YSA9IGRhdGEgfHwgW107XG4gIHZhciBjb29yZFN5c05hbWUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgdmFyIGNyZWF0b3IgPSBjcmVhdG9yc1tjb29yZFN5c05hbWVdO1xuICB2YXIgcmVnaXN0ZXJlZENvb3JkU3lzID0gQ29vcmRpbmF0ZVN5c3RlbS5nZXQoY29vcmRTeXNOYW1lKTtcbiAgdmFyIGNvbXBsZXRlRGltT3B0ID0ge1xuICAgIGVuY29kZURlZjogc2VyaWVzTW9kZWwuZ2V0KCdlbmNvZGUnKSxcbiAgICBkaW1zRGVmOiBzZXJpZXNNb2RlbC5nZXQoJ2RpbWVuc2lvbnMnKVxuICB9OyAvLyBGSVhNRVxuXG4gIHZhciBheGVzSW5mbyA9IGNyZWF0b3IgJiYgY3JlYXRvcihkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpO1xuICB2YXIgZGltZW5zaW9ucyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmRpbWVuc2lvbnM7XG5cbiAgaWYgKCFkaW1lbnNpb25zKSB7XG4gICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZGltZW5zaW9ucyA9IHJlZ2lzdGVyZWRDb29yZFN5cyAmJiAocmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvID8gcmVnaXN0ZXJlZENvb3JkU3lzLmdldERpbWVuc2lvbnNJbmZvKCkgOiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucy5zbGljZSgpKSB8fCBbJ3gnLCAneSddO1xuICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuICB9XG5cbiAgdmFyIGNhdGVnb3J5SW5kZXggPSBheGVzSW5mbyA/IGF4ZXNJbmZvLmNhdGVnb3J5SW5kZXggOiAtMTtcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdChkaW1lbnNpb25zLCBzZXJpZXNNb2RlbCk7XG4gIHZhciBuYW1lTGlzdCA9IGNyZWF0ZU5hbWVMaXN0KGF4ZXNJbmZvLCBkYXRhKTtcbiAgdmFyIGNhdGVnb3JpZXMgPSB7fTtcbiAgdmFyIGRpbVZhbHVlR2V0dGVyID0gY2F0ZWdvcnlJbmRleCA+PSAwICYmIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICBpZiAoaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICB9IC8vIFVzZSBkYXRhSW5kZXggYXMgb3JkaW5hbCB2YWx1ZSBpbiBjYXRlZ29yeUF4aXNcblxuXG4gICAgcmV0dXJuIGRpbUluZGV4ID09PSBjYXRlZ29yeUluZGV4ID8gZGF0YUluZGV4IDogY29udmVyRGF0YVZhbHVlKGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCksIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgfSA6IGZ1bmN0aW9uIChpdGVtT3B0LCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RGF0YUl0ZW1WYWx1ZShpdGVtT3B0KTtcbiAgICB2YXIgdmFsID0gY29udmVyRGF0YVZhbHVlKHZhbHVlICYmIHZhbHVlW2RpbUluZGV4XSwgZGltZW5zaW9uc1tkaW1JbmRleF0pOyAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG5cbiAgICBpZiAoaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0gYXhlc0luZm8gJiYgYXhlc0luZm8uY2F0ZWdvcnlBeGVzTW9kZWxzO1xuXG4gICAgaWYgKGNhdGVnb3J5QXhlc01vZGVscyAmJiBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0pIHtcbiAgICAgIC8vIElmIGdpdmVuIHZhbHVlIGlzIGEgY2F0ZWdvcnkgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gTGF6eSBnZXQgY2F0ZWdvcmllc1xuICAgICAgICBjYXRlZ29yaWVzW2RpbU5hbWVdID0gY2F0ZWdvcmllc1tkaW1OYW1lXSB8fCBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0uZ2V0Q2F0ZWdvcmllcygpO1xuICAgICAgICB2YWwgPSB6clV0aWwuaW5kZXhPZihjYXRlZ29yaWVzW2RpbU5hbWVdLCB2YWwpO1xuXG4gICAgICAgIGlmICh2YWwgPCAwICYmICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgLy8gSW4gY2FzZSBzb21lIG9uZSB3cml0ZSAnMScsICcyJyBpc3RlYWQgb2YgMSwgMlxuICAgICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgbGlzdC5pbml0RGF0YShkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpO1xuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2FibGUoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlICE9PSAnY2F0ZWdvcnknICYmIGF4aXNUeXBlICE9PSAndGltZSc7XG59XG5cbmZ1bmN0aW9uIGdldERpbVR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknID8gJ29yZGluYWwnIDogYXhpc1R5cGUgPT09ICd0aW1lJyA/ICd0aW1lJyA6ICdmbG9hdCc7XG59XG4vKipcbiAqIENyZWF0ZXJzIGZvciBlYWNoIGNvb3JkIHN5c3RlbS5cbiAqL1xuXG5cbnZhciBjcmVhdG9ycyA9IHtcbiAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgY29tcGxldGVEaW1PcHQpIHtcbiAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgbWFpblR5cGU6IG5hbWUsXG4gICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJbmRleCcpLFxuICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSWQnKVxuICAgICAgfSlbMF07XG4gICAgfSk7XG4gICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcbiAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgeUF4aXNUeXBlID0geUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAneCcsXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHhBeGlzVHlwZSksXG4gICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAneScsXG4gICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh5QXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZSh5QXhpc1R5cGUpXG4gICAgfV07XG4gICAgdmFyIGlzWEF4aXNDYXRlb2dyeSA9IHhBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgY29tcGxldGVEaW1PcHQpO1xuICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSB7fTtcblxuICAgIGlmIChpc1hBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy54ID0geEF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICBpZiAoaXNZQXhpc0NhdGVnb3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueSA9IHlBeGlzTW9kZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBjYXRlZ29yeUluZGV4OiBpc1hBeGlzQ2F0ZW9ncnkgPyAwIDogaXNZQXhpc0NhdGVnb3J5ID8gMSA6IC0xLFxuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICB9O1xuICB9LFxuICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGNvbXBsZXRlRGltT3B0KSB7XG4gICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgIG1haW5UeXBlOiAnc2luZ2xlQXhpcycsXG4gICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdzaW5nbGVBeGlzSW5kZXgnKSxcbiAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJZCcpXG4gICAgfSlbMF07XG4gICAgdmFyIHNpbmdsZUF4aXNUeXBlID0gc2luZ2xlQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgIHZhciBpc0NhdGVnb3J5ID0gc2luZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSBbe1xuICAgICAgbmFtZTogJ3NpbmdsZScsXG4gICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHNpbmdsZUF4aXNUeXBlKSxcbiAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoc2luZ2xlQXhpc1R5cGUpXG4gICAgfV07XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuXG4gICAgaWYgKGlzQ2F0ZWdvcnkpIHtcbiAgICAgIGNhdGVnb3J5QXhlc01vZGVscy5zaW5nbGUgPSBzaW5nbGVBeGlzTW9kZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBjYXRlZ29yeUluZGV4OiBpc0NhdGVnb3J5ID8gMCA6IC0xLFxuICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICB9O1xuICB9LFxuICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgIHZhciBwb2xhck1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgbWFpblR5cGU6ICdwb2xhcicsXG4gICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhckluZGV4JyksXG4gICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJylcbiAgICB9KVswXTtcbiAgICB2YXIgYW5nbGVBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ2FuZ2xlQXhpcycpO1xuICAgIHZhciByYWRpdXNBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ3JhZGl1c0F4aXMnKTtcbiAgICB2YXIgcmFkaXVzQXhpc1R5cGUgPSByYWRpdXNBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGFuZ2xlQXhpc1R5cGUgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMocmFkaXVzQXhpc1R5cGUpLFxuICAgICAgc3RhY2thYmxlOiBpc1N0YWNrYWJsZShyYWRpdXNBeGlzVHlwZSlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhhbmdsZUF4aXNUeXBlKSxcbiAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoYW5nbGVBeGlzVHlwZSlcbiAgICB9XTtcbiAgICB2YXIgaXNBbmdsZUF4aXNDYXRlb2dyeSA9IGFuZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgdmFyIGlzUmFkaXVzQXhpc0NhdGVvZ3J5ID0gcmFkaXVzQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBjb21wbGV0ZURpbU9wdCk7XG4gICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuXG4gICAgaWYgKGlzUmFkaXVzQXhpc0NhdGVvZ3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMucmFkaXVzID0gcmFkaXVzQXhpc01vZGVsO1xuICAgIH1cblxuICAgIGlmIChpc0FuZ2xlQXhpc0NhdGVvZ3J5KSB7XG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMuYW5nbGUgPSBhbmdsZUF4aXNNb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIGNhdGVnb3J5SW5kZXg6IGlzQW5nbGVBeGlzQ2F0ZW9ncnkgPyAxIDogaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPyAwIDogLTEsXG4gICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgIH07XG4gIH0sXG4gIGdlbzogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsLCBjb21wbGV0ZURpbU9wdCkge1xuICAgIC8vIFRPRE8gUmVnaW9uXG4gICAgLy8g5aSa5Liq5pWj54K55Zu+57O75YiX5Zyo5ZCM5LiA5Liq5Zyw5Yy655qE5pe25YCZXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpbWVuc2lvbnM6IGNvbXBsZXRlRGltZW5zaW9ucyhbe1xuICAgICAgICBuYW1lOiAnbG5nJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnbGF0J1xuICAgICAgfV0sIGRhdGEsIGNvbXBsZXRlRGltT3B0KVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVMaXN0KHJlc3VsdCwgZGF0YSkge1xuICB2YXIgbmFtZUxpc3QgPSBbXTtcbiAgdmFyIGNhdGVnb3J5RGltID0gcmVzdWx0ICYmIHJlc3VsdC5kaW1lbnNpb25zW3Jlc3VsdC5jYXRlZ29yeUluZGV4XTtcbiAgdmFyIGNhdGVnb3J5QXhpc01vZGVsO1xuXG4gIGlmIChjYXRlZ29yeURpbSkge1xuICAgIGNhdGVnb3J5QXhpc01vZGVsID0gcmVzdWx0LmNhdGVnb3J5QXhlc01vZGVsc1tjYXRlZ29yeURpbS5uYW1lXTtcbiAgfVxuXG4gIGlmIChjYXRlZ29yeUF4aXNNb2RlbCkge1xuICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBjYXRlZ29yeUF4aXNNb2RlbC5nZXRDYXRlZ29yaWVzKCk7XG5cbiAgICBpZiAoY2F0ZWdvcmllcykge1xuICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgLy8gT3JkZXJlZCBkYXRhIGlzIGdpdmVuIGV4cGxpY2l0bHkgbGlrZVxuICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgLy8gb3IgZ2l2ZW4gc2NhdHRlciBkYXRhLFxuICAgICAgLy8gcGljayB0aGUgY2F0ZWdvcnlcblxuICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGRhdGFbMF0pICYmIGRhdGFbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgbmFtZUxpc3RbaV0gPSBjYXRlZ29yaWVzW2RhdGFbaV1bcmVzdWx0LmNhdGVnb3J5SW5kZXggfHwgMF1dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lTGlzdCA9IGNhdGVnb3JpZXMuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWVMaXN0O1xufVxuXG52YXIgX2RlZmF1bHQgPSBjcmVhdGVMaXN0RnJvbUFycmF5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///274\n");

/***/ }),
/* 275 */
/***/ (function(module, exports) {

eval("function defaultKeyGetter(item) {\n  return item;\n}\n/**\n * @param {Array} oldArr\n * @param {Array} newArr\n * @param {Function} oldKeyGetter\n * @param {Function} newKeyGetter\n * @param {Object} [context] Can be visited by this.context in callback.\n */\n\n\nfunction DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n  this._old = oldArr;\n  this._new = newArr;\n  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n  this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n  this.context = context;\n}\n\nDataDiffer.prototype = {\n  constructor: DataDiffer,\n\n  /**\n   * Callback function when add a data\n   */\n  add: function (func) {\n    this._add = func;\n    return this;\n  },\n\n  /**\n   * Callback function when update a data\n   */\n  update: function (func) {\n    this._update = func;\n    return this;\n  },\n\n  /**\n   * Callback function when remove a data\n   */\n  remove: function (func) {\n    this._remove = func;\n    return this;\n  },\n  execute: function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    var i;\n    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency\n    // when duplicate keys exists (consider newDataIndex.pop() below).\n    // For performance consideration, these code below do not look neat.\n\n    for (i = 0; i < oldArr.length; i++) {\n      var key = oldDataKeyArr[i];\n      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.\n\n      if (idx != null) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var len = idx.length;\n\n        if (len) {\n          len === 1 && (newDataIndexMap[key] = null);\n          idx = idx.unshift();\n        } else {\n          newDataIndexMap[key] = null;\n        }\n\n        this._update && this._update(idx, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var key = newDataKeyArr[i];\n\n      if (newDataIndexMap.hasOwnProperty(key)) {\n        var idx = newDataIndexMap[key];\n\n        if (idx == null) {\n          continue;\n        } // idx can never be empty array here. see 'set null' logic above.\n\n\n        if (!idx.length) {\n          this._add && this._add(idx);\n        } else {\n          for (var j = 0, len = idx.length; j < len; j++) {\n            this._add && this._add(idx[j]);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n  for (var i = 0; i < arr.length; i++) {\n    // Add prefix to avoid conflict with Object.prototype.\n    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n    var existence = map[key];\n\n    if (existence == null) {\n      keyArr.push(key);\n      map[key] = i;\n    } else {\n      if (!existence.length) {\n        map[key] = existence = [existence];\n      }\n\n      existence.push(i);\n    }\n  }\n}\n\nvar _default = DataDiffer;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9kYXRhL0RhdGFEaWZmZXIuanM/ZjMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWZhdWx0S2V5R2V0dGVyKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IG9sZEFyclxuICogQHBhcmFtIHtBcnJheX0gbmV3QXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbGRLZXlHZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0tleUdldHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDYW4gYmUgdmlzaXRlZCBieSB0aGlzLmNvbnRleHQgaW4gY2FsbGJhY2suXG4gKi9cblxuXG5mdW5jdGlvbiBEYXRhRGlmZmVyKG9sZEFyciwgbmV3QXJyLCBvbGRLZXlHZXR0ZXIsIG5ld0tleUdldHRlciwgY29udGV4dCkge1xuICB0aGlzLl9vbGQgPSBvbGRBcnI7XG4gIHRoaXMuX25ldyA9IG5ld0FycjtcbiAgdGhpcy5fb2xkS2V5R2V0dGVyID0gb2xkS2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gIHRoaXMuX25ld0tleUdldHRlciA9IG5ld0tleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG5EYXRhRGlmZmVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERhdGFEaWZmZXIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYWRkIGEgZGF0YVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX2FkZCA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdXBkYXRlIGEgZGF0YVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gcmVtb3ZlIGEgZGF0YVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgIHRoaXMuX3JlbW92ZSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGV4ZWN1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkQXJyID0gdGhpcy5fb2xkO1xuICAgIHZhciBuZXdBcnIgPSB0aGlzLl9uZXc7XG4gICAgdmFyIG9sZERhdGFJbmRleE1hcCA9IHt9O1xuICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgb2xkRGF0YUtleUFyciA9IFtdO1xuICAgIHZhciBuZXdEYXRhS2V5QXJyID0gW107XG4gICAgdmFyIGk7XG4gICAgaW5pdEluZGV4TWFwKG9sZEFyciwgb2xkRGF0YUluZGV4TWFwLCBvbGREYXRhS2V5QXJyLCAnX29sZEtleUdldHRlcicsIHRoaXMpO1xuICAgIGluaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgJ19uZXdLZXlHZXR0ZXInLCB0aGlzKTsgLy8gVHJhdmVsIGJ5IGludmVydGVkIG9yZGVyIHRvIG1ha2Ugc3VyZSBvcmRlciBjb25zaXN0ZW5jeVxuICAgIC8vIHdoZW4gZHVwbGljYXRlIGtleXMgZXhpc3RzIChjb25zaWRlciBuZXdEYXRhSW5kZXgucG9wKCkgYmVsb3cpLlxuICAgIC8vIEZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLCB0aGVzZSBjb2RlIGJlbG93IGRvIG5vdCBsb29rIG5lYXQuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gb2xkRGF0YUtleUFycltpXTtcbiAgICAgIHZhciBpZHggPSBuZXdEYXRhSW5kZXhNYXBba2V5XTsgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBiZWxvdy5cblxuICAgICAgaWYgKGlkeCAhPSBudWxsKSB7XG4gICAgICAgIC8vIENvbnNpZGVyIHRoZXJlIGlzIGR1cGxpY2F0ZSBrZXkgKGZvciBleGFtcGxlLCB1c2UgZGF0YUl0ZW0ubmFtZSBhcyBrZXkpLlxuICAgICAgICAvLyBXZSBzaG91bGQgbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gbmV3QXJyIGFuZCBvbGRBcnIgY2FuIGJlIHZpc2l0ZWQuXG4gICAgICAgIHZhciBsZW4gPSBpZHgubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPT09IDEgJiYgKG5ld0RhdGFJbmRleE1hcFtrZXldID0gbnVsbCk7XG4gICAgICAgICAgaWR4ID0gaWR4LnVuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUgJiYgdGhpcy5fdXBkYXRlKGlkeCwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmUgJiYgdGhpcy5fcmVtb3ZlKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YUtleUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IG5ld0RhdGFLZXlBcnJbaV07XG5cbiAgICAgIGlmIChuZXdEYXRhSW5kZXhNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07XG5cbiAgICAgICAgaWYgKGlkeCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBhYm92ZS5cblxuXG4gICAgICAgIGlmICghaWR4Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2FkZCAmJiB0aGlzLl9hZGQoaWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gaWR4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeFtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbml0SW5kZXhNYXAoYXJyLCBtYXAsIGtleUFyciwga2V5R2V0dGVyTmFtZSwgZGF0YURpZmZlcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIC8vIEFkZCBwcmVmaXggdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlLlxuICAgIHZhciBrZXkgPSAnX2VjXycgKyBkYXRhRGlmZmVyW2tleUdldHRlck5hbWVdKGFycltpXSwgaSk7XG4gICAgdmFyIGV4aXN0ZW5jZSA9IG1hcFtrZXldO1xuXG4gICAgaWYgKGV4aXN0ZW5jZSA9PSBudWxsKSB7XG4gICAgICBrZXlBcnIucHVzaChrZXkpO1xuICAgICAgbWFwW2tleV0gPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWV4aXN0ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgbWFwW2tleV0gPSBleGlzdGVuY2UgPSBbZXhpc3RlbmNlXTtcbiAgICAgIH1cblxuICAgICAgZXhpc3RlbmNlLnB1c2goaSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IERhdGFEaWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9kYXRhL0RhdGFEaWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///275\n");

/***/ }),
/* 276 */,
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar env = __webpack_require__(239);\n\nvar _format = __webpack_require__(245);\n\nvar formatTime = _format.formatTime;\nvar encodeHTML = _format.encodeHTML;\nvar addCommas = _format.addCommas;\nvar getTooltipMarker = _format.getTooltipMarker;\n\nvar _clazz = __webpack_require__(247);\n\nvar set = _clazz.set;\nvar get = _clazz.get;\n\nvar modelUtil = __webpack_require__(234);\n\nvar ComponentModel = __webpack_require__(248);\n\nvar colorPaletteMixin = __webpack_require__(278);\n\nvar _layout = __webpack_require__(249);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar SeriesModel = ComponentModel.extend({\n  type: 'series.__base__',\n\n  /**\n   * @readOnly\n   */\n  seriesIndex: 0,\n  // coodinateSystem will be injected in the echarts/CoordinateSystem\n  coordinateSystem: null,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * Data provided for legend\n   * @type {Function}\n   */\n  // PENDING\n  legendDataProvider: null,\n\n  /**\n   * Access path of color for visual\n   */\n  visualColorAccessPath: 'itemStyle.normal.color',\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  init: function (option, parentModel, ecModel, extraOpt) {\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.seriesIndex = this.componentIndex;\n    this.mergeDefaultAndTheme(option, ecModel);\n    var data = this.getInitialData(option, ecModel);\n\n    /**\n     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n     * @private\n     */\n    set(this, 'dataBeforeProcessed', data); // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkList\n\n    this.restoreData();\n  },\n\n  /**\n   * Util for merge default and theme to option\n   * @param  {Object} option\n   * @param  {module:echarts/model/Global} ecModel\n   */\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n\n    var themeSubType = this.subType;\n\n    if (ComponentModel.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n\n    zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option.label, ['show']);\n    this.fillDataTextStyle(option.data);\n\n    if (layoutMode) {\n      mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (newSeriesOption, ecModel) {\n    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n    }\n\n    var data = this.getInitialData(newSeriesOption, ecModel); // TODO Merge data?\n\n    if (data) {\n      set(this, 'data', data);\n      set(this, 'dataBeforeProcessed', data.cloneShallow());\n    }\n  },\n  fillDataTextStyle: function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data) {\n      var props = ['show'];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          modelUtil.defaultEmphasis(data[i].label, props);\n        }\n      }\n    }\n  },\n\n  /**\n   * Init a data structure from data related option in series\n   * Must be overwritten\n   */\n  getInitialData: function () {},\n\n  /**\n   * @param {string} [dataType]\n   * @return {module:echarts/data/List}\n   */\n  getData: function (dataType) {\n    var data = get(this, 'data');\n    return dataType == null ? data : data.getLinkedData(dataType);\n  },\n\n  /**\n   * @param {module:echarts/data/List} data\n   */\n  setData: function (data) {\n    set(this, 'data', data);\n  },\n\n  /**\n   * Get data before processed\n   * @return {module:echarts/data/List}\n   */\n  getRawData: function () {\n    return get(this, 'dataBeforeProcessed');\n  },\n\n  /**\n   * Coord dimension to data dimension.\n   *\n   * By default the result is the same as dimensions of series data.\n   * But in some series data dimensions are different from coord dimensions (i.e.\n   * candlestick and boxplot). Override this method to handle those cases.\n   *\n   * Coord dimension to data dimension can be one-to-many\n   *\n   * @param {string} coordDim\n   * @return {Array.<string>} dimensions on the axis.\n   */\n  coordDimToDataDim: function (coordDim) {\n    return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n  },\n\n  /**\n   * Convert data dimension to coord dimension.\n   *\n   * @param {string|number} dataDim\n   * @return {string}\n   */\n  dataDimToCoordDim: function (dataDim) {\n    return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n  },\n\n  /**\n   * Get base axis if has coordinate system and has axis.\n   * By default use coordSys.getBaseAxis();\n   * Can be overrided for some chart.\n   * @return {type} description\n   */\n  getBaseAxis: function () {\n    var coordSys = this.coordinateSystem;\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  },\n  // FIXME\n\n  /**\n   * Default tooltip formatter\n   *\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   */\n  formatTooltip: function (dataIndex, multipleSeries, dataType) {\n    function formatArrayValue(value) {\n      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n        var dimItem = data.getDimensionInfo(idx);\n        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n      }, 0);\n      var result = [];\n      var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n      tooltipDims.length ? zrUtil.each(tooltipDims, function (dimIdx) {\n        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n      }) // By default, all dims is used on tooltip.\n      : zrUtil.each(value, setEachItem);\n\n      function setEachItem(val, dimIdx) {\n        var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.\n\n        if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n          return;\n        }\n\n        var dimType = dimInfo.type;\n        var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));\n        valStr && result.push(encodeHTML(valStr));\n      }\n\n      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n    }\n\n    var data = get(this, 'data');\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));\n    var name = data.getName(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n\n    if (zrUtil.isObject(color) && color.colorStops) {\n      color = (color.colorStops[0] || {}).color;\n    }\n\n    color = color || 'transparent';\n    var colorEl = getTooltipMarker(color);\n    var seriesName = this.name; // FIXME\n\n    if (seriesName === '\\0-') {\n      // Not show '-'\n      seriesName = '';\n    }\n\n    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';\n    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var animationEnabled = this.getShallow('animation');\n\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n\n    return animationEnabled;\n  },\n  restoreData: function () {\n    set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n  },\n  getColorFromPalette: function (name, scope) {\n    var ecModel = this.ecModel; // PENDING\n\n    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope);\n    }\n\n    return color;\n  },\n\n  /**\n   * Get data indices for show tooltip content. See tooltip.\n   * @abstract\n   * @param {Array.<string>|string} dim\n   * @param {Array.<number>} value\n   * @param {module:echarts/coord/single/SingleAxis} baseAxis\n   * @return {Object} {dataIndices, nestestValue}.\n   */\n  getAxisTooltipData: null,\n\n  /**\n   * See tooltip.\n   * @abstract\n   * @param {number} dataIndex\n   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n   */\n  getTooltipPosition: null\n});\nzrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\nzrUtil.mixin(SeriesModel, colorPaletteMixin);\nvar _default = SeriesModel;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanM/MTg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL2VudlwiKTtcblxudmFyIF9mb3JtYXQgPSByZXF1aXJlKFwiLi4vdXRpbC9mb3JtYXRcIik7XG5cbnZhciBmb3JtYXRUaW1lID0gX2Zvcm1hdC5mb3JtYXRUaW1lO1xudmFyIGVuY29kZUhUTUwgPSBfZm9ybWF0LmVuY29kZUhUTUw7XG52YXIgYWRkQ29tbWFzID0gX2Zvcm1hdC5hZGRDb21tYXM7XG52YXIgZ2V0VG9vbHRpcE1hcmtlciA9IF9mb3JtYXQuZ2V0VG9vbHRpcE1hcmtlcjtcblxudmFyIF9jbGF6eiA9IHJlcXVpcmUoXCIuLi91dGlsL2NsYXp6XCIpO1xuXG52YXIgc2V0ID0gX2NsYXp6LnNldDtcbnZhciBnZXQgPSBfY2xhenouZ2V0O1xuXG52YXIgbW9kZWxVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoXCIuL0NvbXBvbmVudFwiKTtcblxudmFyIGNvbG9yUGFsZXR0ZU1peGluID0gcmVxdWlyZShcIi4vbWl4aW4vY29sb3JQYWxldHRlXCIpO1xuXG52YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFBhcmFtcyA9IF9sYXlvdXQuZ2V0TGF5b3V0UGFyYW1zO1xudmFyIG1lcmdlTGF5b3V0UGFyYW0gPSBfbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW07XG52YXIgU2VyaWVzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAnc2VyaWVzLl9fYmFzZV9fJyxcblxuICAvKipcbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBzZXJpZXNJbmRleDogMCxcbiAgLy8gY29vZGluYXRlU3lzdGVtIHdpbGwgYmUgaW5qZWN0ZWQgaW4gdGhlIGVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbVxuICBjb29yZGluYXRlU3lzdGVtOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkZWZhdWx0T3B0aW9uOiBudWxsLFxuXG4gIC8qKlxuICAgKiBEYXRhIHByb3ZpZGVkIGZvciBsZWdlbmRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLy8gUEVORElOR1xuICBsZWdlbmREYXRhUHJvdmlkZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFjY2VzcyBwYXRoIG9mIGNvbG9yIGZvciB2aXN1YWxcbiAgICovXG4gIHZpc3VhbENvbG9yQWNjZXNzUGF0aDogJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InLFxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBsYXlvdXRNb2RlOiBudWxsLFxuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuc2VyaWVzSW5kZXggPSB0aGlzLmNvbXBvbmVudEluZGV4O1xuICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5pdGlhbERhdGEob3B0aW9uLCBlY01vZGVsKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R8bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGh9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnLCBkYXRhKTsgLy8gSWYgd2UgcmV2ZXJzZSB0aGUgb3JkZXIgKG1ha2UgZGF0YSBmaXJzdGx5LCBhbmQgdGhlbiBtYWtlXG4gICAgLy8gZGF0YUJlZm9yZVByb2Nlc3NlZCBieSBjbG9uZVNoYWxsb3cpLCBjbG9uZVNoYWxsb3cgd2lsbFxuICAgIC8vIGNhdXNlIGRhdGEuZ3JhcGguZGF0YSAhPT0gZGF0YSB3aGVuIHVzaW5nXG4gICAgLy8gbW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaCBvciBtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWUuXG4gICAgLy8gU2VlIG1vZHVsZTplY2hhcnRzL2RhdGEvaGVscGVyL2xpbmtMaXN0XG5cbiAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFV0aWwgZm9yIG1lcmdlIGRlZmF1bHQgYW5kIHRoZW1lIHRvIG9wdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvblxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICovXG4gIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlID8gZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTsgLy8gQmFja3dhcmQgY29tcGF0OiB1c2luZyBzdWJUeXBlIG9uIHRoZW1lLlxuICAgIC8vIEJ1dCBpZiBuYW1lIGR1cGxpY2F0ZSBiZXR3ZWVuIHNlcmllcyBzdWJUeXBlXG4gICAgLy8gKGZvciBleGFtcGxlOiBwYXJhbGxlbCkgYWRkIGNvbXBvbmVudCBtYWluVHlwZSxcbiAgICAvLyBhZGQgc3VmZml4ICdTZXJpZXMnLlxuXG4gICAgdmFyIHRoZW1lU3ViVHlwZSA9IHRoaXMuc3ViVHlwZTtcblxuICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyh0aGVtZVN1YlR5cGUpKSB7XG4gICAgICB0aGVtZVN1YlR5cGUgKz0gJ1Nlcmllcyc7XG4gICAgfVxuXG4gICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgZWNNb2RlbC5nZXRUaGVtZSgpLmdldCh0aGlzLnN1YlR5cGUpKTtcbiAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7IC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHNob3dgXG5cbiAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKG9wdGlvbi5sYWJlbCwgWydzaG93J10pO1xuICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUob3B0aW9uLmRhdGEpO1xuXG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIG1lcmdlTGF5b3V0UGFyYW0ob3B0aW9uLCBpbnB1dFBvc2l0aW9uUGFyYW1zLCBsYXlvdXRNb2RlKTtcbiAgICB9XG4gIH0sXG4gIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3U2VyaWVzT3B0aW9uLCBlY01vZGVsKSB7XG4gICAgbmV3U2VyaWVzT3B0aW9uID0genJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBuZXdTZXJpZXNPcHRpb24sIHRydWUpO1xuICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUobmV3U2VyaWVzT3B0aW9uLmRhdGEpO1xuICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuXG4gICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgIG1lcmdlTGF5b3V0UGFyYW0odGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgbGF5b3V0TW9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldEluaXRpYWxEYXRhKG5ld1Nlcmllc09wdGlvbiwgZWNNb2RlbCk7IC8vIFRPRE8gTWVyZ2UgZGF0YT9cblxuICAgIGlmIChkYXRhKSB7XG4gICAgICBzZXQodGhpcywgJ2RhdGEnLCBkYXRhKTtcbiAgICAgIHNldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcsIGRhdGEuY2xvbmVTaGFsbG93KCkpO1xuICAgIH1cbiAgfSxcbiAgZmlsbERhdGFUZXh0U3R5bGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gRGVmYXVsdCBkYXRhIGxhYmVsIGVtcGhhc2lzIGBzaG93YFxuICAgIC8vIEZJWE1FIFRyZWUgc3RydWN0dXJlIGRhdGEgP1xuICAgIC8vIEZJWE1FIFBlcmZvcm1hbmNlID9cbiAgICBpZiAoZGF0YSkge1xuICAgICAgdmFyIHByb3BzID0gWydzaG93J107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLmxhYmVsKSB7XG4gICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhkYXRhW2ldLmxhYmVsLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXQgYSBkYXRhIHN0cnVjdHVyZSBmcm9tIGRhdGEgcmVsYXRlZCBvcHRpb24gaW4gc2VyaWVzXG4gICAqIE11c3QgYmUgb3ZlcndyaXR0ZW5cbiAgICovXG4gIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKGRhdGFUeXBlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXQodGhpcywgJ2RhdGEnKTtcbiAgICByZXR1cm4gZGF0YVR5cGUgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLmdldExpbmtlZERhdGEoZGF0YVR5cGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgKi9cbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZXQodGhpcywgJ2RhdGEnLCBkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAqL1xuICBnZXRSYXdEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb29yZCBkaW1lbnNpb24gdG8gZGF0YSBkaW1lbnNpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIHJlc3VsdCBpcyB0aGUgc2FtZSBhcyBkaW1lbnNpb25zIG9mIHNlcmllcyBkYXRhLlxuICAgKiBCdXQgaW4gc29tZSBzZXJpZXMgZGF0YSBkaW1lbnNpb25zIGFyZSBkaWZmZXJlbnQgZnJvbSBjb29yZCBkaW1lbnNpb25zIChpLmUuXG4gICAqIGNhbmRsZXN0aWNrIGFuZCBib3hwbG90KS4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaGFuZGxlIHRob3NlIGNhc2VzLlxuICAgKlxuICAgKiBDb29yZCBkaW1lbnNpb24gdG8gZGF0YSBkaW1lbnNpb24gY2FuIGJlIG9uZS10by1tYW55XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZERpbVxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gZGltZW5zaW9ucyBvbiB0aGUgYXhpcy5cbiAgICovXG4gIGNvb3JkRGltVG9EYXRhRGltOiBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICByZXR1cm4gbW9kZWxVdGlsLmNvb3JkRGltVG9EYXRhRGltKHRoaXMuZ2V0RGF0YSgpLCBjb29yZERpbSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSBkaW1lbnNpb24gdG8gY29vcmQgZGltZW5zaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZGF0YURpbVRvQ29vcmREaW06IGZ1bmN0aW9uIChkYXRhRGltKSB7XG4gICAgcmV0dXJuIG1vZGVsVXRpbC5kYXRhRGltVG9Db29yZERpbSh0aGlzLmdldERhdGEoKSwgZGF0YURpbSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBiYXNlIGF4aXMgaWYgaGFzIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBoYXMgYXhpcy5cbiAgICogQnkgZGVmYXVsdCB1c2UgY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICogQ2FuIGJlIG92ZXJyaWRlZCBmb3Igc29tZSBjaGFydC5cbiAgICogQHJldHVybiB7dHlwZX0gZGVzY3JpcHRpb25cbiAgICovXG4gIGdldEJhc2VBeGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICB9LFxuICAvLyBGSVhNRVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHRvb2x0aXAgZm9ybWF0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAqL1xuICBmb3JtYXRUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICBmdW5jdGlvbiBmb3JtYXRBcnJheVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgdmVydGlhbGx5ID0genJVdGlsLnJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24gKHZlcnRpYWxseSwgdmFsLCBpZHgpIHtcbiAgICAgICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgcmV0dXJuIHZlcnRpYWxseSB8PSBkaW1JdGVtICYmIGRpbUl0ZW0udG9vbHRpcCAhPT0gZmFsc2UgJiYgZGltSXRlbS50b29sdGlwTmFtZSAhPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgdG9vbHRpcERpbXMgPSBtb2RlbFV0aWwub3RoZXJEaW1Ub0RhdGFEaW0oZGF0YSwgJ3Rvb2x0aXAnKTtcbiAgICAgIHRvb2x0aXBEaW1zLmxlbmd0aCA/IHpyVXRpbC5lYWNoKHRvb2x0aXBEaW1zLCBmdW5jdGlvbiAoZGltSWR4KSB7XG4gICAgICAgIHNldEVhY2hJdGVtKGRhdGEuZ2V0KGRpbUlkeCwgZGF0YUluZGV4KSwgZGltSWR4KTtcbiAgICAgIH0pIC8vIEJ5IGRlZmF1bHQsIGFsbCBkaW1zIGlzIHVzZWQgb24gdG9vbHRpcC5cbiAgICAgIDogenJVdGlsLmVhY2godmFsdWUsIHNldEVhY2hJdGVtKTtcblxuICAgICAgZnVuY3Rpb24gc2V0RWFjaEl0ZW0odmFsLCBkaW1JZHgpIHtcbiAgICAgICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltSWR4KTsgLy8gSWYgYGRpbUluZm8udG9vbHRpcGAgaXMgbm90IHNldCwgc2hvdyB0b29sdGlwLlxuXG4gICAgICAgIGlmICghZGltSW5mbyB8fCBkaW1JbmZvLm90aGVyRGltcy50b29sdGlwID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mby50eXBlO1xuICAgICAgICB2YXIgdmFsU3RyID0gKHZlcnRpYWxseSA/ICctICcgKyAoZGltSW5mby50b29sdGlwTmFtZSB8fCBkaW1JbmZvLm5hbWUpICsgJzogJyA6ICcnKSArIChkaW1UeXBlID09PSAnb3JkaW5hbCcgPyB2YWwgKyAnJyA6IGRpbVR5cGUgPT09ICd0aW1lJyA/IG11bHRpcGxlU2VyaWVzID8gJycgOiBmb3JtYXRUaW1lKCd5eXl5L01NL2RkIGhoOm1tOnNzJywgdmFsKSA6IGFkZENvbW1hcyh2YWwpKTtcbiAgICAgICAgdmFsU3RyICYmIHJlc3VsdC5wdXNoKGVuY29kZUhUTUwodmFsU3RyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAodmVydGlhbGx5ID8gJzxici8+JyA6ICcnKSArIHJlc3VsdC5qb2luKHZlcnRpYWxseSA/ICc8YnIvPicgOiAnLCAnKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IGdldCh0aGlzLCAnZGF0YScpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB6clV0aWwuaXNBcnJheSh2YWx1ZSkgPyBmb3JtYXRBcnJheVZhbHVlKHZhbHVlKSA6IGVuY29kZUhUTUwoYWRkQ29tbWFzKHZhbHVlKSk7XG4gICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcblxuICAgIGlmICh6clV0aWwuaXNPYmplY3QoY29sb3IpICYmIGNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yLmNvbG9yU3RvcHNbMF0gfHwge30pLmNvbG9yO1xuICAgIH1cblxuICAgIGNvbG9yID0gY29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICB2YXIgY29sb3JFbCA9IGdldFRvb2x0aXBNYXJrZXIoY29sb3IpO1xuICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lOyAvLyBGSVhNRVxuXG4gICAgaWYgKHNlcmllc05hbWUgPT09ICdcXDAtJykge1xuICAgICAgLy8gTm90IHNob3cgJy0nXG4gICAgICBzZXJpZXNOYW1lID0gJyc7XG4gICAgfVxuXG4gICAgc2VyaWVzTmFtZSA9IHNlcmllc05hbWUgPyBlbmNvZGVIVE1MKHNlcmllc05hbWUpICsgKCFtdWx0aXBsZVNlcmllcyA/ICc8YnIvPicgOiAnOiAnKSA6ICcnO1xuICAgIHJldHVybiAhbXVsdGlwbGVTZXJpZXMgPyBzZXJpZXNOYW1lICsgY29sb3JFbCArIChuYW1lID8gZW5jb2RlSFRNTChuYW1lKSArICc6ICcgKyBmb3JtYXR0ZWRWYWx1ZSA6IGZvcm1hdHRlZFZhbHVlKSA6IGNvbG9yRWwgKyBzZXJpZXNOYW1lICsgZm9ybWF0dGVkVmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FuaW1hdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJyk7XG5cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgpLmNvdW50KCkgPiB0aGlzLmdldFNoYWxsb3coJ2FuaW1hdGlvblRocmVzaG9sZCcpKSB7XG4gICAgICAgIGFuaW1hdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uRW5hYmxlZDtcbiAgfSxcbiAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBzZXQodGhpcywgJ2RhdGEnLCBnZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnKS5jbG9uZVNoYWxsb3coKSk7XG4gIH0sXG4gIGdldENvbG9yRnJvbVBhbGV0dGU6IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsOyAvLyBQRU5ESU5HXG5cbiAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVNaXhpbi5nZXRDb2xvckZyb21QYWxldHRlLmNhbGwodGhpcywgbmFtZSwgc2NvcGUpO1xuXG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgY29sb3IgPSBlY01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUobmFtZSwgc2NvcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGRhdGEgaW5kaWNlcyBmb3Igc2hvdyB0b29sdGlwIGNvbnRlbnQuIFNlZSB0b29sdGlwLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IGRpbVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZVxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL3NpbmdsZS9TaW5nbGVBeGlzfSBiYXNlQXhpc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IHtkYXRhSW5kaWNlcywgbmVzdGVzdFZhbHVlfS5cbiAgICovXG4gIGdldEF4aXNUb29sdGlwRGF0YTogbnVsbCxcblxuICAvKipcbiAgICogU2VlIHRvb2x0aXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBQb2ludCBvZiB0b29sdGlwLiBudWxsL3VuZGVmaW5lZCBjYW4gYmUgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRUb29sdGlwUG9zaXRpb246IG51bGxcbn0pO1xuenJVdGlsLm1peGluKFNlcmllc01vZGVsLCBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluKTtcbnpyVXRpbC5taXhpbihTZXJpZXNNb2RlbCwgY29sb3JQYWxldHRlTWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gU2VyaWVzTW9kZWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9TZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///277\n");

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _clazz = __webpack_require__(247);\n\nvar set = _clazz.set;\nvar get = _clazz.get;\nvar _default = {\n  clearColorPalette: function () {\n    set(this, 'colorIdx', 0);\n    set(this, 'colorNameMap', {});\n  },\n  getColorFromPalette: function (name, scope) {\n    scope = scope || this;\n    var colorIdx = get(scope, 'colorIdx') || 0;\n    var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n\n    if (colorNameMap.hasOwnProperty(name)) {\n      return colorNameMap[name];\n    }\n\n    var colorPalette = this.get('color', true) || [];\n\n    if (!colorPalette.length) {\n      return;\n    }\n\n    var color = colorPalette[colorIdx];\n\n    if (name) {\n      colorNameMap[name] = color;\n    }\n\n    set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n    return color;\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9jb2xvclBhbGV0dGUuanM/YjQ1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NsYXp6ID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBzZXQgPSBfY2xhenouc2V0O1xudmFyIGdldCA9IF9jbGF6ei5nZXQ7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGNsZWFyQ29sb3JQYWxldHRlOiBmdW5jdGlvbiAoKSB7XG4gICAgc2V0KHRoaXMsICdjb2xvcklkeCcsIDApO1xuICAgIHNldCh0aGlzLCAnY29sb3JOYW1lTWFwJywge30pO1xuICB9LFxuICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgdmFyIGNvbG9ySWR4ID0gZ2V0KHNjb3BlLCAnY29sb3JJZHgnKSB8fCAwO1xuICAgIHZhciBjb2xvck5hbWVNYXAgPSBnZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnKSB8fCBzZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnLCB7fSk7IC8vIFVzZSBgaGFzT3duUHJvcGVydHlgIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuICAgIGlmIChjb2xvck5hbWVNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiBjb2xvck5hbWVNYXBbbmFtZV07XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yUGFsZXR0ZSA9IHRoaXMuZ2V0KCdjb2xvcicsIHRydWUpIHx8IFtdO1xuXG4gICAgaWYgKCFjb2xvclBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlW2NvbG9ySWR4XTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBjb2xvck5hbWVNYXBbbmFtZV0gPSBjb2xvcjtcbiAgICB9XG5cbiAgICBzZXQoc2NvcGUsICdjb2xvcklkeCcsIChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aCk7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///278\n");

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

eval("var numberUtil = __webpack_require__(235);\n\n/**\n * For testable.\n */\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n  var ticks = []; // If interval is 0, return [];\n\n  if (!interval) {\n    return ticks;\n  } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n  var safeLimit = 10000;\n\n  if (extent[0] < niceTickExtent[0]) {\n    ticks.push(extent[0]);\n  }\n\n  var tick = niceTickExtent[0];\n\n  while (tick <= niceTickExtent[1]) {\n    ticks.push(tick); // Avoid rounding error\n\n    tick = roundNumber(tick + interval, intervalPrecision);\n\n    if (tick === ticks[ticks.length - 1]) {\n      // Consider out of safe float point, e.g.,\n      // -3711126.9907707 + 2e-10 === -3711126.9907707\n      break;\n    }\n\n    if (ticks.length > safeLimit) {\n      return [];\n    }\n  } // Consider this case: the last item of ticks is smaller\n  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n    ticks.push(extent[1]);\n  }\n\n  return ticks;\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;\nexports.intervalScaleGetTicks = intervalScaleGetTicks;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9oZWxwZXIuanM/MzcwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL251bWJlclwiKTtcblxuLyoqXG4gKiBGb3IgdGVzdGFibGUuXG4gKi9cbnZhciByb3VuZE51bWJlciA9IG51bWJlclV0aWwucm91bmQ7XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBCb3RoIGV4dGVudFswXSBhbmQgZXh0ZW50WzFdIHNob3VsZCBiZSB2YWxpZCBudW1iZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2hvdWxkIGJlIGV4dGVudFswXSA8IGV4dGVudFsxXS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGxpdE51bWJlciBzcGxpdE51bWJlciBzaG91bGQgYmUgPj0gMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluSW50ZXJ2YWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEludGVydmFsXVxuICogQHJldHVybiB7T2JqZWN0fSB7aW50ZXJ2YWwsIGludGVydmFsUHJlY2lzaW9uLCBuaWNlVGlja0V4dGVudH1cbiAqL1xuXG5mdW5jdGlvbiBpbnRlcnZhbFNjYWxlTmljZVRpY2tzKGV4dGVudCwgc3BsaXROdW1iZXIsIG1pbkludGVydmFsLCBtYXhJbnRlcnZhbCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICB2YXIgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBudW1iZXJVdGlsLm5pY2Uoc3BhbiAvIHNwbGl0TnVtYmVyLCB0cnVlKTtcblxuICBpZiAobWluSW50ZXJ2YWwgIT0gbnVsbCAmJiBpbnRlcnZhbCA8IG1pbkludGVydmFsKSB7XG4gICAgaW50ZXJ2YWwgPSByZXN1bHQuaW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgfVxuXG4gIGlmIChtYXhJbnRlcnZhbCAhPSBudWxsICYmIGludGVydmFsID4gbWF4SW50ZXJ2YWwpIHtcbiAgICBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG1heEludGVydmFsO1xuICB9IC8vIFRvdyBtb3JlIGRpZ2l0YWwgZm9yIHRpY2suXG5cblxuICB2YXIgcHJlY2lzaW9uID0gcmVzdWx0LmludGVydmFsUHJlY2lzaW9uID0gZ2V0SW50ZXJ2YWxQcmVjaXNpb24oaW50ZXJ2YWwpOyAvLyBOaWNlZCBleHRlbnQgaW5zaWRlIG9yaWdpbmFsIGV4dGVudFxuXG4gIHZhciBuaWNlVGlja0V4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudCA9IFtyb3VuZE51bWJlcihNYXRoLmNlaWwoZXh0ZW50WzBdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbiksIHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbildO1xuICBmaXhFeHRlbnQobmljZVRpY2tFeHRlbnQsIGV4dGVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICogQHJldHVybiB7bnVtYmVyfSBpbnRlcnZhbCBwcmVjaXNpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEludGVydmFsUHJlY2lzaW9uKGludGVydmFsKSB7XG4gIC8vIFRvdyBtb3JlIGRpZ2l0YWwgZm9yIHRpY2suXG4gIHJldHVybiBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmUoaW50ZXJ2YWwpICsgMjtcbn1cblxuZnVuY3Rpb24gY2xhbXAobmljZVRpY2tFeHRlbnQsIGlkeCwgZXh0ZW50KSB7XG4gIG5pY2VUaWNrRXh0ZW50W2lkeF0gPSBNYXRoLm1heChNYXRoLm1pbihuaWNlVGlja0V4dGVudFtpZHhdLCBleHRlbnRbMV0pLCBleHRlbnRbMF0pO1xufSAvLyBJbiBzb21lIGNhc2VzIChlLmcuLCBzcGxpdE51bWJlciBpcyAxKSwgbmljZVRpY2tFeHRlbnQgbWF5IGJlIG91dCBvZiBleHRlbnQuXG5cblxuZnVuY3Rpb24gZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpIHtcbiAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzBdKSAmJiAobmljZVRpY2tFeHRlbnRbMF0gPSBleHRlbnRbMF0pO1xuICAhaXNGaW5pdGUobmljZVRpY2tFeHRlbnRbMV0pICYmIChuaWNlVGlja0V4dGVudFsxXSA9IGV4dGVudFsxXSk7XG4gIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCAwLCBleHRlbnQpO1xuICBjbGFtcChuaWNlVGlja0V4dGVudCwgMSwgZXh0ZW50KTtcblxuICBpZiAobmljZVRpY2tFeHRlbnRbMF0gPiBuaWNlVGlja0V4dGVudFsxXSkge1xuICAgIG5pY2VUaWNrRXh0ZW50WzBdID0gbmljZVRpY2tFeHRlbnRbMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJ2YWxTY2FsZUdldFRpY2tzKGludGVydmFsLCBleHRlbnQsIG5pY2VUaWNrRXh0ZW50LCBpbnRlcnZhbFByZWNpc2lvbikge1xuICB2YXIgdGlja3MgPSBbXTsgLy8gSWYgaW50ZXJ2YWwgaXMgMCwgcmV0dXJuIFtdO1xuXG4gIGlmICghaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gdGlja3M7XG4gIH0gLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuXG5cbiAgdmFyIHNhZmVMaW1pdCA9IDEwMDAwO1xuXG4gIGlmIChleHRlbnRbMF0gPCBuaWNlVGlja0V4dGVudFswXSkge1xuICAgIHRpY2tzLnB1c2goZXh0ZW50WzBdKTtcbiAgfVxuXG4gIHZhciB0aWNrID0gbmljZVRpY2tFeHRlbnRbMF07XG5cbiAgd2hpbGUgKHRpY2sgPD0gbmljZVRpY2tFeHRlbnRbMV0pIHtcbiAgICB0aWNrcy5wdXNoKHRpY2spOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvclxuXG4gICAgdGljayA9IHJvdW5kTnVtYmVyKHRpY2sgKyBpbnRlcnZhbCwgaW50ZXJ2YWxQcmVjaXNpb24pO1xuXG4gICAgaWYgKHRpY2sgPT09IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAvLyBDb25zaWRlciBvdXQgb2Ygc2FmZSBmbG9hdCBwb2ludCwgZS5nLixcbiAgICAgIC8vIC0zNzExMTI2Ljk5MDc3MDcgKyAyZS0xMCA9PT0gLTM3MTExMjYuOTkwNzcwN1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IHNhZmVMaW1pdCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSAvLyBDb25zaWRlciB0aGlzIGNhc2U6IHRoZSBsYXN0IGl0ZW0gb2YgdGlja3MgaXMgc21hbGxlclxuICAvLyB0aGFuIG5pY2VUaWNrRXh0ZW50WzFdIGFuZCBuaWNlVGlja0V4dGVudFsxXSA9PT0gZXh0ZW50WzFdLlxuXG5cbiAgaWYgKGV4dGVudFsxXSA+ICh0aWNrcy5sZW5ndGggPyB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSA6IG5pY2VUaWNrRXh0ZW50WzFdKSkge1xuICAgIHRpY2tzLnB1c2goZXh0ZW50WzFdKTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0cy5pbnRlcnZhbFNjYWxlTmljZVRpY2tzID0gaW50ZXJ2YWxTY2FsZU5pY2VUaWNrcztcbmV4cG9ydHMuZ2V0SW50ZXJ2YWxQcmVjaXNpb24gPSBnZXRJbnRlcnZhbFByZWNpc2lvbjtcbmV4cG9ydHMuZml4RXh0ZW50ID0gZml4RXh0ZW50O1xuZXhwb3J0cy5pbnRlcnZhbFNjYWxlR2V0VGlja3MgPSBpbnRlcnZhbFNjYWxlR2V0VGlja3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3NjYWxlL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///279\n");

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Group = __webpack_require__(259);\n\nvar componentUtil = __webpack_require__(265);\n\nvar clazzUtil = __webpack_require__(247);\n\nvar modelUtil = __webpack_require__(234);\n\nfunction Chart() {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewChart');\n}\n\nChart.prototype = {\n  type: 'chart',\n\n  /**\n   * Init the chart\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  init: function (ecModel, api) {},\n\n  /**\n   * Render the chart\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  render: function (seriesModel, ecModel, api, payload) {},\n\n  /**\n   * Highlight series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  highlight: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n  },\n\n  /**\n   * Downplay series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  downplay: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'normal');\n  },\n\n  /**\n   * Remove self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  remove: function (ecModel, api) {\n    this.group.removeAll();\n  },\n\n  /**\n   * Dispose self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  dispose: function () {}\n  /**\n   * The view contains the given point.\n   * @interface\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  // containPoint: function () {}\n\n};\nvar chartProto = Chart.prototype;\n\nchartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n  this.render(seriesModel, ecModel, api, payload);\n};\n/**\n * Set state of single element\n * @param  {module:zrender/Element} el\n * @param  {string} state\n */\n\n\nfunction elSetState(el, state) {\n  if (el) {\n    el.trigger(state);\n\n    if (el.type === 'group') {\n      for (var i = 0; i < el.childCount(); i++) {\n        elSetState(el.childAt(i), state);\n      }\n    }\n  }\n}\n/**\n * @param  {module:echarts/data/List} data\n * @param  {Object} payload\n * @param  {string} state 'normal'|'emphasis'\n * @inner\n */\n\n\nfunction toggleHighlight(data, payload, state) {\n  var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n  if (dataIndex != null) {\n    zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n      elSetState(data.getItemGraphicEl(dataIdx), state);\n    });\n  } else {\n    data.eachItemGraphicEl(function (el) {\n      elSetState(el, state);\n    });\n  }\n} // Enable Chart.extend.\n\n\nclazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Chart, {\n  registerWhenExtend: true\n});\nvar _default = Chart;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi92aWV3L0NoYXJ0LmpzPzcyZjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY29tcG9uZW50XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxuZnVuY3Rpb24gQ2hhcnQoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q2hhcnQnKTtcbn1cblxuQ2hhcnQucHJvdG90eXBlID0ge1xuICB0eXBlOiAnY2hhcnQnLFxuXG4gIC8qKlxuICAgKiBJbml0IHRoZSBjaGFydFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNoYXJ0XG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge30sXG5cbiAgLyoqXG4gICAqIEhpZ2hsaWdodCBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICovXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnZW1waGFzaXMnKTtcbiAgfSxcblxuICAvKipcbiAgICogRG93bnBsYXkgc2VyaWVzIG9yIHNwZWNpZmllZCBkYXRhIGl0ZW1cbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmXG4gICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge31cbiAgLyoqXG4gICAqIFRoZSB2aWV3IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQGludGVyZmFjZVxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgLy8gY29udGFpblBvaW50OiBmdW5jdGlvbiAoKSB7fVxuXG59O1xudmFyIGNoYXJ0UHJvdG8gPSBDaGFydC5wcm90b3R5cGU7XG5cbmNoYXJ0UHJvdG8udXBkYXRlVmlldyA9IGNoYXJ0UHJvdG8udXBkYXRlTGF5b3V0ID0gY2hhcnRQcm90by51cGRhdGVWaXN1YWwgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbn07XG4vKipcbiAqIFNldCBzdGF0ZSBvZiBzaW5nbGUgZWxlbWVudFxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGVsU2V0U3RhdGUoZWwsIHN0YXRlKSB7XG4gIGlmIChlbCkge1xuICAgIGVsLnRyaWdnZXIoc3RhdGUpO1xuXG4gICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgZWxTZXRTdGF0ZShlbC5jaGlsZEF0KGkpLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlICdub3JtYWwnfCdlbXBoYXNpcydcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgenJVdGlsLmVhY2gobW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkoZGF0YUluZGV4KSwgZnVuY3Rpb24gKGRhdGFJZHgpIHtcbiAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJZHgpLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsU2V0U3RhdGUoZWwsIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufSAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCwgWydkaXNwb3NlJ10pOyAvLyBBZGQgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnQsIHtcbiAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG59KTtcbnZhciBfZGVmYXVsdCA9IENoYXJ0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlldy9DaGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///280\n");

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

eval("var guid = __webpack_require__(288);\n\nvar Eventful = __webpack_require__(252);\n\nvar Transformable = __webpack_require__(296);\n\nvar Animatable = __webpack_require__(385);\n\nvar zrUtil = __webpack_require__(230);\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzPzMyNWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBBbmltYXRhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vQW5pbWF0YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIOeUu+W4g+WFg+e0oElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog5YWD57Sg57G75Z6LXG4gICAqIEVsZW1lbnQgdHlwZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gIC8qKlxuICAgKiDlhYPntKDlkI3lrZdcbiAgICogRWxlbWVudCBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKi9cbiAgX196cjogbnVsbCxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGNsaXBQYXRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBEcmlmdCBlbGVtZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICovXG4gIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIGR5ID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgZHggPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFtKSB7XG4gICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfVxuXG4gICAgbVs0XSArPSBkeDtcbiAgICBtWzVdICs9IGR5O1xuICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgKi9cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICovXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogVXBkYXRlIGVhY2ggZnJhbWVcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0aGlzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAqL1xuICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBlbGVtZW50XG4gICAqL1xuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgKi9cbiAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmICh6cikge1xuICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH0gLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuXG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICovXG4gIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcblxuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgIH1cblxuICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5jbGlwUGF0aCA9IG51bGw7XG4gICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0genI7IC8vIOa3u+WKoOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IG51bGw7IC8vIOenu+mZpOWKqOeUu1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuXG4gICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgenIuYW5pbWF0aW9uLnJlbW92ZUFuaW1hdG9yKGFuaW1hdG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMuY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acih6cik7XG4gICAgfVxuICB9XG59O1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEFuaW1hdGFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEVsZW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///281\n");

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Clip = __webpack_require__(359);\n\nvar color = __webpack_require__(256);\n\nvar _util = __webpack_require__(230);\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * 设置动画关键帧\n   * @param  {number} time 关键帧时间，单位是ms\n   * @param  {Object} props 关键帧的属性值，key-value表示\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加动画每一帧的回调函数\n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * 开始执行动画\n   * @param  {string|Function} [easing]\n   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * 设置动画延迟开始的时间\n   * @param  {number} time 单位ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * 添加动画结束的回调\n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanM/ZDJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ2xpcCA9IHJlcXVpcmUoXCIuL0NsaXBcIik7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoXCIuLi90b29sL2NvbG9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIHBlcmNlbnQgPiAwLjUgPyBwMSA6IHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBsZW4gJiYgcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuXG5cbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG5cbiAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG5cbiAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgYXJyMC5wdXNoKGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGluZyBOYU4gdmFsdWVcblxuXG4gIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcblxuICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sIHQsIHQyLCB0Myk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG5cbmZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcbiAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gIHZhciBsYXN0VmFsdWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICByZXR1cm4gaXNBcnJheUxpa2UobGFzdFZhbHVlICYmIGxhc3RWYWx1ZVswXSkgPyAyIDogMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhY2tDbGlwKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKSB7XG4gIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG4gIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG5cbiAgaWYgKCF0cmFja0xlbikge1xuICAgIHJldHVybjtcbiAgfSAvLyBHdWVzcyBkYXRhIHR5cGVcblxuXG4gIHZhciBmaXJzdFZhbCA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzVmFsdWVBcnJheSA9IGlzQXJyYXlMaWtlKGZpcnN0VmFsKTtcbiAgdmFyIGlzVmFsdWVDb2xvciA9IGZhbHNlO1xuICB2YXIgaXNWYWx1ZVN0cmluZyA9IGZhbHNlOyAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcblxuICB2YXIgYXJyRGltID0gaXNWYWx1ZUFycmF5ID8gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSA6IDA7XG4gIHZhciB0cmFja01heFRpbWU7IC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG5cbiAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICB9KTtcbiAgdHJhY2tNYXhUaW1lID0ga2V5ZnJhbWVzW3RyYWNrTGVuIC0gMV0udGltZTsgLy8gUGVyY2VudHMgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlBlcmNlbnRzID0gW107IC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbjsgaSsrKSB7XG4gICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTsgLy8gQXNzdW1lIHZhbHVlIGlzIGEgY29sb3Igd2hlbiBpdCBpcyBhIHN0cmluZ1xuXG4gICAgdmFyIHZhbHVlID0ga2V5ZnJhbWVzW2ldLnZhbHVlOyAvLyBDaGVjayBpZiB2YWx1ZSBpcyBlcXVhbCwgZGVlcCBjaGVjayBpZiB2YWx1ZSBpcyBhcnJheVxuXG4gICAgaWYgKCEoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkgfHwgIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkge1xuICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldlZhbHVlID0gdmFsdWU7IC8vIFRyeSBjb252ZXJ0aW5nIGEgc3RyaW5nIHRvIGEgY29sb3IgYXJyYXlcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuXG4gICAgICBpZiAoY29sb3JBcnJheSkge1xuICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgIGlzVmFsdWVDb2xvciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1ZhbHVlU3RyaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZlZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIGlmICghZm9yY2VBbmltYXRlICYmIGlzQWxsVmFsdWVFcXVhbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdOyAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbiAtIDE7IGkrKykge1xuICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmFOKGtmVmFsdWVzW2ldKSAmJiAhaXNOYU4obGFzdFZhbHVlKSAmJiAhaXNWYWx1ZVN0cmluZyAmJiAhaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTsgLy8gQ2FjaGUgdGhlIGtleSBvZiBsYXN0IGZyYW1lIHRvIHNwZWVkIHVwIHdoZW5cbiAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG5cbiAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgdztcbiAgdmFyIHAwO1xuICB2YXIgcDE7XG4gIHZhciBwMjtcbiAgdmFyIHAzO1xuXG4gIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgfVxuXG4gIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgIHZhciBmcmFtZTsgLy8gSW4gdGhlIGVhc2luZyBmdW5jdGlvbiBsaWtlIGVsYXN0aWNPdXQsIHBlcmNlbnQgbWF5IGxlc3MgdGhhbiAwXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIGZyYW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAvLyBTdGFydCBmcm9tIG5leHQga2V5XG4gICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cbiAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcblxuICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cblxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IHRyYWNrTGVuOyBmcmFtZSsrKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA+IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9XG5cbiAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcbiAgICB2YXIgcmFuZ2UgPSBrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXTtcblxuICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICB9XG5cbiAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgIHAwID0ga2ZWYWx1ZXNbZnJhbWUgPT09IDAgPyBmcmFtZSA6IGZyYW1lIC0gMV07XG4gICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuXG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZU51bWJlcihrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsaXAgPSBuZXcgQ2xpcCh7XG4gICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICBsb29wOiBhbmltYXRvci5fbG9vcCxcbiAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgb25kZXN0cm95OiBvbmVUcmFja0RvbmVcbiAgfSk7XG5cbiAgaWYgKGVhc2luZyAmJiBlYXNpbmcgIT09ICdzcGxpbmUnKSB7XG4gICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gIH1cblxuICByZXR1cm4gY2xpcDtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gKi9cblxuXG52YXIgQW5pbWF0b3IgPSBmdW5jdGlvbiAodGFyZ2V0LCBsb29wLCBnZXR0ZXIsIHNldHRlcikge1xuICB0aGlzLl90cmFja3MgPSB7fTtcbiAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcbiAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuICB0aGlzLl9jbGlwQ291bnQgPSAwO1xuICB0aGlzLl9kZWxheSA9IDA7XG4gIHRoaXMuX2RvbmVMaXN0ID0gW107XG4gIHRoaXMuX29uZnJhbWVMaXN0ID0gW107XG4gIHRoaXMuX2NsaXBMaXN0ID0gW107XG59O1xuXG5BbmltYXRvci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHdoZW46IGZ1bmN0aW9uICh0aW1lXG4gIC8qIG1zICovXG4gICwgcHJvcHMpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdOyAvLyBJbnZhbGlkIHZhbHVlXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAvLyBFbHNlXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG5cblxuICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH0sXG4gIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICB9LFxuICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgIHRoaXMuX3RyYWNrcyA9IHt9OyAvLyBDbGVhciBhbGwgY2xpcHNcblxuICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBbZWFzaW5nXVxuICAgKiAgICAgICAgIOWKqOeUu+e8k+WKqOWHveaVsO+8jOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vZWFzaW5nfVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZUFuaW1hdGVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcsIGZvcmNlQW5pbWF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2xpcENvdW50ID0gMDtcblxuICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGlwQ291bnQtLTtcblxuICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXN0Q2xpcDtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMuX3RyYWNrcykge1xuICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcCh0aGlzLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwgdGhpcy5fdHJhY2tzW3Byb3BOYW1lXSwgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG5cbiAgICAgICAgY2xpcENvdW50Kys7IC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcblxuXG4gICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG5cbiAgICAgIGxhc3RDbGlwLm9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX29uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIFRoaXMgb3B0aW1pemF0aW9uIHdpbGwgaGVscCB0aGUgY2FzZSB0aGF0IGluIHRoZSB1cHBlciBhcHBsaWNhdGlvblxuICAgIC8vIHRoZSB2aWV3IG1heSBiZSByZWZyZXNoZWQgZnJlcXVlbnRseSwgd2hlcmUgYW5pbWF0aW9uIHdpbGwgYmVcbiAgICAvLyBjYWxsZWQgcmVwZWF0bHkgYnV0IG5vdGhpbmcgY2hhbmdlZC5cblxuXG4gICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuXG4gICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICB9XG5cbiAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlu7bov5/lvIDlp4vnmoTml7bpl7RcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkb25lOiBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRoaXMuX2RvbmVMaXN0LnB1c2goY2IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXA+fVxuICAgKi9cbiAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRvcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///282\n");

/***/ }),
/* 283 */
/***/ (function(module, exports) {

eval("var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzPzZkODgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBmdW5jdGlvbiAoZnVuYykge1xuICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///283\n");

/***/ }),
/* 284 */
/***/ (function(module, exports) {

eval("var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanM/MDAzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihhbmdsZSkge1xuICBhbmdsZSAlPSBQSTI7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVSYWRpYW4gPSBub3JtYWxpemVSYWRpYW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///284\n");

/***/ }),
/* 285 */
/***/ (function(module, exports) {

eval("function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzPzYyNWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG4gIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRpbmdMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///285\n");

/***/ }),
/* 286 */
/***/ (function(module, exports) {

eval("// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcz8wMThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cbi8qKlxuICogU2ltcGxlIGRvdWJsZSBsaW5rZWQgbGlzdC4gQ29tcGFyZWQgd2l0aCBhcnJheSwgaXQgaGFzIE8oMSkgcmVtb3ZlIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG4gIHRoaXMuaGVhZCA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuXG52YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4vKipcbiAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7fSB2YWxcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICovXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcbi8qKlxuICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfVxuXG4gIHRoaXMuX2xlbisrO1xufTtcbi8qKlxuICogUmVtb3ZlIGVudHJ5LlxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBoZWFkXG4gICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyB0YWlsXG4gICAgdGhpcy50YWlsID0gcHJldjtcbiAgfVxuXG4gIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgdGhpcy5fbGVuLS07XG59O1xuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbGVuO1xufTtcbi8qKlxuICogQ2xlYXIgbGlzdFxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge30gdmFsXG4gKi9cblxuXG52YXIgRW50cnkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7fVxuICAgKi9cbiAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5uZXh0O1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnByZXY7XG59O1xuLyoqXG4gKiBMUlUgQ2FjaGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gKi9cblxuXG52YXIgTFJVID0gZnVuY3Rpb24gKG1heFNpemUpIHtcbiAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHRoaXMuX21hcCA9IHt9O1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcbiAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG59O1xuXG52YXIgTFJVUHJvdG8gPSBMUlUucHJvdG90eXBlO1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHBhcmFtICB7fSB2YWx1ZVxuICogQHJldHVybiB7fSBSZW1vdmVkIHZhbHVlXG4gKi9cblxuTFJVUHJvdG8ucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICB2YXIgcmVtb3ZlZCA9IG51bGw7XG5cbiAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbGlzdC5sZW4oKTsgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgIH1cblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgIH1cblxuICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICBtYXBba2V5XSA9IGVudHJ5O1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7fVxuICovXG5cblxuTFJVUHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuXG4gIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICBsaXN0LnJlbW92ZShlbnRyeSk7XG4gICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gIH1cbn07XG4vKipcbiAqIENsZWFyIHRoZSBjYWNoZVxuICovXG5cblxuTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2xpc3QuY2xlYXIoKTtcblxuICB0aGlzLl9tYXAgPSB7fTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IExSVTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///286\n");

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(236);\n\nvar curve = __webpack_require__(251);\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n * @module zrender/core/bbox\n * @param {Array<Object>} points 顶点数组\n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanM/MWI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4vY3VydmVcIik7XG5cbi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG4vKipcbiAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCkge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwID0gcG9pbnRzWzBdO1xuICB2YXIgbGVmdCA9IHBbMF07XG4gIHZhciByaWdodCA9IHBbMF07XG4gIHZhciB0b3AgPSBwWzFdO1xuICB2YXIgYm90dG9tID0gcFsxXTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbGVmdDtcbiAgbWluWzFdID0gdG9wO1xuICBtYXhbMF0gPSByaWdodDtcbiAgbWF4WzFdID0gYm90dG9tO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTGluZSh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xufVxuXG52YXIgeERpbSA9IFtdO1xudmFyIHlEaW0gPSBbXTtcbi8qKlxuICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21DdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4KSB7XG4gIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgdmFyIGk7XG4gIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgbWluWzBdID0gSW5maW5pdHk7XG4gIG1pblsxXSA9IEluZmluaXR5O1xuICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICB9XG5cbiAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG59XG4vKipcbiAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDsgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG5cbiAgdmFyIHR4ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMCk7XG4gIHZhciB0eSA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDApO1xuICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbn1cbi8qKlxuICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1ldGhvZFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gcnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tQXJjKHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4KSB7XG4gIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIG1pblswXSA9IHggLSByeDtcbiAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgbWF4WzBdID0geCArIHJ4O1xuICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcbiAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTsgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIFBJMjtcblxuICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSBQSTI7XG5cbiAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgfSAvLyB2YXIgbnVtYmVyID0gMDtcbiAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuXG5cbiAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG4gICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mcm9tUG9pbnRzID0gZnJvbVBvaW50cztcbmV4cG9ydHMuZnJvbUxpbmUgPSBmcm9tTGluZTtcbmV4cG9ydHMuZnJvbUN1YmljID0gZnJvbUN1YmljO1xuZXhwb3J0cy5mcm9tUXVhZHJhdGljID0gZnJvbVF1YWRyYXRpYztcbmV4cG9ydHMuZnJvbUFyYyA9IGZyb21BcmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///287\n");

/***/ }),
/* 288 */
/***/ (function(module, exports) {

eval("/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanM/ZjBlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHpyZW5kZXI6IOeUn+aIkOWUr+S4gGlkXG4gKlxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG52YXIgaWRTdGFydCA9IDB4MDkwNztcblxuZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gIHJldHVybiBpZFN0YXJ0Kys7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///288\n");

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(258);\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcz8yNmEyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIGRlYnVnTW9kZSA9IF9jb25maWcuZGVidWdNb2RlO1xuXG52YXIgbG9nID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChkZWJ1Z01vZGUgPT09IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKGRlYnVnTW9kZSA+IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gbG9nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9sb2cuanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///289\n");

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(268);\n\nvar BoundingRect = __webpack_require__(244);\n\nvar zrUtil = __webpack_require__(230);\n\nvar imageHelper = __webpack_require__(270);\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // 图片已经加载完成\n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // 设置transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzP2JmMWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpOyAvLyBEcmF3IHJlY3QgdGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///290\n");

/***/ }),
/* 291 */
/***/ (function(module, exports) {

eval("var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanM/YTk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMucmVwZWF0ID0gcmVwZWF0OyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFBhdHRlcm47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///291\n");

/***/ }),
/* 292 */
/***/ (function(module, exports) {

eval("var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzPzIyZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1dOyAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzLCBob3N0KSB7XG4gIHRoaXMuZXh0ZW5kRnJvbShvcHRzLCBmYWxzZSk7XG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHgyID0geDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgeTIgPSB5MiAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAuNSA6IG9iai54O1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwLjUgOiBvYmoueTtcbiAgdmFyIHIgPSBvYmouciA9PSBudWxsID8gMC41IDogb2JqLnI7XG5cbiAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgeCA9IHggKiB3aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICByID0gciAqIG1pbjtcbiAgfVxuXG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9XG4gICAqL1xuICBob3N0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgb3BhY2l0eTogMSxcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgbGluZURhc2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVXaWR0aDogMSxcblxuICAvKipcbiAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIElmIGBmb250U2l6ZWAgb3IgYGZvbnRGYW1pbHlgIGV4aXN0cywgYGZvbnRgIHdpbGwgYmUgcmVzZXQgYnlcbiAgICogYGZvbnRTaXplYCwgYGZvbnRTdHlsZWAsIGBmb250V2VpZ2h0YCwgYGZvbnRGYW1pbHlgLlxuICAgKiBTbyBkbyBub3QgdmlzaXQgaXQgZGlyZWN0bHkgaW4gdXBwZXIgYXBwbGljYXRpb24gKGxpa2UgZWNoYXJ0cyksXG4gICAqIGJ1dCB1c2UgYGNvbnRhaW4vdGV4dCNtYWtlRm9udGAgaW5zdGVhZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIGZvbnQuIFVzZSBmb250IHBsZWFzZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250U3R5bGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRXZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogU2hvdWxkIGJlIDEyIGJ1dCBub3QgJzEycHgnLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZm9udFNpemU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRGYW1pbHk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFJlc2VydmVkIGZvciBzcGVjaWFsIGZ1bmN0aW5hbGl0eSwgbGlrZSAnaHInLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFRhZzogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRGaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U3Ryb2tlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFdpZHRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPbmx5IGZvciB0ZXh0QmFja2dyb3VuZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIHRleHRTdHJva2UgbWF5IGJlIHNldCBhcyBzb21lIGNvbG9yIGFzIGEgZGVmYXVsdFxuICAgKiB2YWx1ZSBpbiB1cHBlciBhcHBsaWNhaW9uLCB3aGVyZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgKiBvZiB0ZXh0U3Ryb2tlV2lkdGggc2hvdWxkIGJlIDAgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICogdXNlciBjYW4gY2hvb3NlIHRvIGRvIG5vdCB1c2UgdGV4dCBzdHJva2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0TGluZUhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAqIFt4LCB5XVxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0ICdpbnNpZGUnXG4gICAqL1xuICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuXG4gIC8qKlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIGJvdW5kaW5nUmVjdCBvZiBhIGBkaXNwbGF5YWJsZWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0ZXh0UmVjdDogbnVsbCxcblxuICAvKipcbiAgICogW3gsIHldXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHREaXN0YW5jZTogNSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3hTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WTogMCxcblxuICAvKipcbiAgICogV2hldGhlciB0cmFuc2Zvcm0gdGV4dC5cbiAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRyYW5zZm9ybVRleHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0cmFuc2Zvcm1UZXh0IGlzIGZhbHNlLlxuICAgKi9cbiAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gIC8qKlxuICAgKiBUZXh0IG9yaWdpbiBvZiB0ZXh0IHJvdGF0aW9uLCBsaWtlIFsxMCwgNDBdLlxuICAgKiBCYXNlZCBvbiB4LCB5IG9mIHJlY3QuXG4gICAqIFVzZWZ1bCBpbiBsYWJlbCByb3RhdGlvbiBvZiBjaXJjdWxhciBzeW1ib2wuXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgb3JpZ2luIGlzIHRleHRQb3NpdGlvbi5cbiAgICogQ2FuIGJlICdjZW50ZXInLlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9yaWdpbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm9yZGVyQ29sb3I6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyV2lkdGg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm9yZGVyUmFkaXVzOiAwLFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgYDJgIG9yIGBbMiwgNF1gIG9yIGBbMiwgMywgNCwgNV1gXG4gICAqIEB0eXBlIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0UGFkZGluZzogbnVsbCxcblxuICAvKipcbiAgICogVGV4dCBzdHlsZXMgZm9yIHJpY2ggdGV4dC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHJpY2g6IG51bGwsXG5cbiAgLyoqXG4gICAqIHtvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgZWxsaXBzaXMsIHBsYWNlaG9sZGVyfVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdHJ1bmNhdGU6IG51bGwsXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBibGVuZDogbnVsbCxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgdmFyIHByZXZTdHlsZSA9IHByZXZFbCAmJiBwcmV2RWwuc3R5bGU7XG4gICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSB7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSA/IGVsLmdldExpbmVTY2FsZSgpIDogMSk7XG4gICAgfVxuICB9LFxuICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gIH0sXG4gIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSB0cnVlOiBvdmVyd3JpcnRlIGFueSB3YXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlOiBvdmVyd3JpdGUgb25seSB3aGVuICF0YXJnZXQuaGFzT3duUHJvcGVydHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiBvdmVyd3JpdGUgd2hlbiBwcm9wZXJ0eSBpcyBub3QgbnVsbC91bmRlZmluZWQuXG4gICAqL1xuICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAob3ZlcndyaXRlID09PSB0cnVlIHx8IChvdmVyd3JpdGUgPT09IGZhbHNlID8gIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgOiBvdGhlclN0eWxlW25hbWVdICE9IG51bGwpKSkge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVcbiAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3U3R5bGU7XG4gIH0sXG4gIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBtZXRob2QoY3R4LCBvYmosIHJlY3QpO1xuICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICB9XG59O1xudmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuXG4gIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgfVxufSAvLyBQcm92aWRlIGZvciBvdGhlcnNcblxuXG5TdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG52YXIgX2RlZmF1bHQgPSBTdHlsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///292\n");

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

eval("var smoothSpline = __webpack_require__(374);\n\nvar smoothBezier = __webpack_require__(373);\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzPzc4OGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoXCIuL3Ntb290aFNwbGluZVwiKTtcblxudmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoXCIuL3Ntb290aEJlemllclwiKTtcblxuZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuXG4gIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydHMuYnVpbGRQYXRoID0gYnVpbGRQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///293\n");

/***/ }),
/* 294 */
/***/ (function(module, exports) {

eval("function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanM/NDE4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLng7XG4gIHZhciB5ID0gc2hhcGUueTtcbiAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gIHZhciByID0gc2hhcGUucjtcbiAgdmFyIHIxO1xuICB2YXIgcjI7XG4gIHZhciByMztcbiAgdmFyIHI0OyAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcblxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgICAgcjQgPSByWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gIH1cblxuICB2YXIgdG90YWw7XG5cbiAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMyArIHI0O1xuICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMiArIHIzO1xuICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbn1cblxuZXhwb3J0cy5idWlsZFBhdGggPSBidWlsZFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///294\n");

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _util = __webpack_require__(230);\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = __webpack_require__(250);\n\nvar roundRectHelper = __webpack_require__(294);\n\nvar imageHelper = __webpack_require__(270);\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzPzA2OWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF91dGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxudmFyIHJldHJpZXZlMiA9IF91dGlsLnJldHJpZXZlMjtcbnZhciByZXRyaWV2ZTMgPSBfdXRpbC5yZXRyaWV2ZTM7XG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgbm9ybWFsaXplQ3NzQXJyYXkgPSBfdXRpbC5ub3JtYWxpemVDc3NBcnJheTtcbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGlzT2JqZWN0ID0gX3V0aWwuaXNPYmplY3Q7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi8uLi9jb250YWluL3RleHRcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi9yb3VuZFJlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuL2ltYWdlXCIpO1xuXG4vLyBUT0RPOiBIYXZlIG5vdCBzdXBwb3J0ICdzdGFydCcsICdlbmQnIHlldC5cbnZhciBWQUxJRF9URVhUX0FMSUdOID0ge1xuICBsZWZ0OiAxLFxuICByaWdodDogMSxcbiAgY2VudGVyOiAxXG59O1xudmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7XG4gIHRvcDogMSxcbiAgYm90dG9tOiAxLFxuICBtaWRkbGU6IDFcbn07XG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFRoZSBpbnB1dCBzdHlsZS5cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUpIHtcbiAgbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICBlYWNoKHN0eWxlLnJpY2gsIG5vcm1hbGl6ZVN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUpIHtcbiAgICBzdHlsZS5mb250ID0gdGV4dENvbnRhaW4ubWFrZUZvbnQoc3R5bGUpO1xuICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdGV4dEFsaWduID09PSAnbWlkZGxlJyAmJiAodGV4dEFsaWduID0gJ2NlbnRlcicpO1xuICAgIHN0eWxlLnRleHRBbGlnbiA9IHRleHRBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfQUxJR05bdGV4dEFsaWduXSA/IHRleHRBbGlnbiA6ICdsZWZ0JzsgLy8gQ29tcGF0aWJsZSB3aXRoIHRleHRCYXNlbGluZS5cblxuICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICB0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZScpO1xuICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOW3RleHRWZXJ0aWNhbEFsaWduXSA/IHRleHRWZXJ0aWNhbEFsaWduIDogJ3RvcCc7XG4gICAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHN0eWxlLnRleHRQYWRkaW5nID0gbm9ybWFsaXplQ3NzQXJyYXkoc3R5bGUudGV4dFBhZGRpbmcpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW3JlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogICAgICAgICAgICAgICAgICBJZiBzZXQgZmFsc2UsIHJlY3QgdGV4dCBpcyBub3QgdXNlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHN0eWxlLnJpY2ggPyByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGZvbnQgPSBzZXRDdHgoY3R4LCAnZm9udCcsIHN0eWxlLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgc3R5bGUudHJ1bmNhdGUpO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dExpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgbGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgdmFyIHRleHRZID0gYm94WTtcbiAgdmFyIG5lZWREcmF3QmcgPSBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpO1xuXG4gIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxsIGdldFRleHRXaWR0aCB1dGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dCwgZm9udCk7XG4gICAgdmFyIG91dGVyV2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgdGV4dFBhZGRpbmcgJiYgKG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSk7XG4gICAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICBuZWVkRHJhd0JnICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICB0ZXh0WCA9IGdldFRleHRYRm9yUGFkZGluZyhiYXNlWCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgICB0ZXh0WSArPSB0ZXh0UGFkZGluZ1swXTtcbiAgICB9XG4gIH1cblxuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduIHx8ICdsZWZ0Jyk7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpOyAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGUuXG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZIHx8IDApOyAvLyBgdGV4dEJhc2VsaW5lYCBpcyBzZXQgYXMgJ21pZGRsZScuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwoc3R5bGUudGV4dEZpbGwpO1xuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSaWNoVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jaztcblxuICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICB9XG5cbiAgZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50QmxvY2sud2lkdGg7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IGJveFBvcy5iYXNlWTtcbiAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB4TGVmdCA9IGJveFg7XG4gIHZhciBsaW5lVG9wID0gYm94WTtcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4TGVmdCArPSB0ZXh0UGFkZGluZ1szXTtcbiAgICBsaW5lVG9wICs9IHRleHRQYWRkaW5nWzBdO1xuICB9XG5cbiAgdmFyIHhSaWdodCA9IHhMZWZ0ICsgY29udGVudFdpZHRoO1xuICBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgYm94WCwgYm94WSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBjb250ZW50QmxvY2subGluZXNbaV07XG4gICAgdmFyIHRva2VucyA9IGxpbmUudG9rZW5zO1xuICAgIHZhciB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxpbmUubGluZUhlaWdodDtcbiAgICB2YXIgdXNlZFdpZHRoID0gbGluZS53aWR0aDtcbiAgICB2YXIgbGVmdEluZGV4ID0gMDtcbiAgICB2YXIgbGluZVhMZWZ0ID0geExlZnQ7XG4gICAgdmFyIGxpbmVYUmlnaHQgPSB4UmlnaHQ7XG4gICAgdmFyIHJpZ2h0SW5kZXggPSB0b2tlbkNvdW50IC0gMTtcbiAgICB2YXIgdG9rZW47XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDwgdG9rZW5Db3VudCAmJiAodG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XSwgIXRva2VuLnRleHRBbGlnbiB8fCB0b2tlbi50ZXh0QWxpZ24gPT09ICdsZWZ0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0LCAnbGVmdCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgd2hpbGUgKHJpZ2h0SW5kZXggPj0gMCAmJiAodG9rZW4gPSB0b2tlbnNbcmlnaHRJbmRleF0sIHRva2VuLnRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhSaWdodCwgJ3JpZ2h0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWFJpZ2h0IC09IHRva2VuLndpZHRoO1xuICAgICAgcmlnaHRJbmRleC0tO1xuICAgIH0gLy8gVGhlIG90aGVyIHRva2VucyBhcmUgcGxhY2VkIGFzIHRleHRBbGlnbiAnY2VudGVyJyBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG5cblxuICAgIGxpbmVYTGVmdCArPSAoY29udGVudFdpZHRoIC0gKGxpbmVYTGVmdCAtIHhMZWZ0KSAtICh4UmlnaHQgLSBsaW5lWFJpZ2h0KSAtIHVzZWRXaWR0aCkgLyAyO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8PSByaWdodEluZGV4KSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdOyAvLyBDb25zaWRlciB3aWR0aCBzcGVjaWZpZWQgYnkgdXNlciwgdXNlICdjZW50ZXInIHJhdGhlciB0aGFuICdsZWZ0Jy5cblxuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQgKyB0b2tlbi53aWR0aCAvIDIsICdjZW50ZXInKTtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCB4LCB5KSB7XG4gIC8vIHRleHRSb3RhdGlvbiBvbmx5IGFwcGx5IGluIFJlY3RUZXh0LlxuICBpZiAocmVjdCAmJiBzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICB2YXIgb3JpZ2luID0gc3R5bGUudGV4dE9yaWdpbjtcblxuICAgIGlmIChvcmlnaW4gPT09ICdjZW50ZXInKSB7XG4gICAgICB4ID0gcmVjdC53aWR0aCAvIDIgKyByZWN0Lng7XG4gICAgICB5ID0gcmVjdC5oZWlnaHQgLyAyICsgcmVjdC55O1xuICAgIH0gZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICB4ID0gb3JpZ2luWzBdICsgcmVjdC54O1xuICAgICAgeSA9IG9yaWdpblsxXSArIHJlY3QueTtcbiAgICB9XG5cbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpOyAvLyBQb3NpdGl2ZTogYW50aWNsb2Nrd2lzZVxuXG4gICAgY3R4LnJvdGF0ZSgtc3R5bGUudGV4dFJvdGF0aW9uKTtcbiAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCB4LCB0ZXh0QWxpZ24pIHtcbiAgdmFyIHRva2VuU3R5bGUgPSBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vICdjdHgudGV4dEJhc2VsaW5lJyBpcyBhbHdheXMgc2V0IGFzICdtaWRkbGUnLCBmb3Igc2FrZSBvZlxuICAvLyB0aGUgYmlhcyBvZiBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHRva2VuLnRleHRWZXJ0aWNhbEFsaWduO1xuICB2YXIgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC8gMjtcblxuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSA9IGxpbmVUb3AgKyB0b2tlbi5oZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAtIHRva2VuLmhlaWdodCAvIDI7XG4gIH1cblxuICAhdG9rZW4uaXNMaW5lSG9sZGVyICYmIG5lZWREcmF3QmFja2dyb3VuZCh0b2tlblN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgdG9rZW5TdHlsZSwgdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRva2VuLndpZHRoIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggLSB0b2tlbi53aWR0aCAvIDIgOiB4LCB5IC0gdG9rZW4uaGVpZ2h0IC8gMiwgdG9rZW4ud2lkdGgsIHRva2VuLmhlaWdodCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHggPSBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZyk7XG4gICAgeSAtPSB0b2tlbi5oZWlnaHQgLyAyIC0gdGV4dFBhZGRpbmdbMl0gLSB0b2tlbi50ZXh0SGVpZ2h0IC8gMjtcbiAgfVxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd0JsdXIsIHN0eWxlLnRleHRTaGFkb3dCbHVyLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHRva2VuU3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgc3R5bGUudGV4dFNoYWRvd09mZnNldFgsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgc3R5bGUudGV4dFNoYWRvd09mZnNldFksIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbik7IC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuICBzZXRDdHgoY3R4LCAnZm9udCcsIHRva2VuLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2UodG9rZW5TdHlsZS50ZXh0U3Ryb2tlIHx8IHN0eWxlLnRleHRTdHJva2UsIHRleHRTdHJva2VXaWR0aCk7XG4gIHZhciB0ZXh0RmlsbCA9IGdldEZpbGwodG9rZW5TdHlsZS50ZXh0RmlsbCB8fCBzdHlsZS50ZXh0RmlsbCk7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSByZXRyaWV2ZTIodG9rZW5TdHlsZS50ZXh0U3Ryb2tlV2lkdGgsIHN0eWxlLnRleHRTdHJva2VXaWR0aCk7IC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgICBjdHguc3Ryb2tlVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gICAgY3R4LmZpbGxUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkge1xuICByZXR1cm4gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yO1xufSAvLyBzdHlsZToge3RleHRCYWNrZ3JvdW5kQ29sb3IsIHRleHRCb3JkZXJXaWR0aCwgdGV4dEJvcmRlckNvbG9yLCB0ZXh0Qm9yZGVyUmFkaXVzfVxuLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuXG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHZhciBpc1BsYWluQmcgPSBpc1N0cmluZyh0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dEJveFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gIGlmIChpc1BsYWluQmcgfHwgdGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG5cbiAgICBpZiAoIXRleHRCb3JkZXJSYWRpdXMpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cblxuICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodGV4dEJhY2tncm91bmRDb2xvcikpIHtcbiAgICB2YXIgaW1hZ2UgPSB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlO1xuICAgIGltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShpbWFnZSwgbnVsbCwgaG9zdEVsLCBvbkJnSW1hZ2VMb2FkZWQsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKGltYWdlICYmIGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRCb3JkZXJXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dEJvcmRlckNvbG9yKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25CZ0ltYWdlTG9hZGVkKGltYWdlLCB0ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gIC8vIFJlcGxhY2UgaW1hZ2UsIHNvIHRoYXQgYGNvbnRhaW4vdGV4dC5qcyNwYXJzZVJpY2hUZXh0YFxuICAvLyB3aWxsIGdldCBjb3JyZWN0IHJlc3VsdCBpbiBuZXh0IHRpY2suXG4gIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2UgPSBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm94UG9zaXRpb24oYmxvY2tIZWlodCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgaWYgKHJlY3QpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuXG4gICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBQZXJjZW50XG4gICAgICBiYXNlWCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgYmFzZVkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBzdHlsZS50ZXh0RGlzdGFuY2UpO1xuICAgICAgYmFzZVggPSByZXMueDtcbiAgICAgIGJhc2VZID0gcmVzLnk7IC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuXG4gICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIH0gLy8gdGV4dE9mZnNldCBpcyBvbmx5IHN1cHBvcnQgaW4gUmVjdFRleHQsIG90aGVyd2lzZVxuICAgIC8vIHdlIGhhdmUgdG8gYWRqdXN0IGJvdW5kaW5nUmVjdCBmb3IgdGV4dE9mZnNldC5cblxuXG4gICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuXG4gICAgaWYgKHRleHRPZmZzZXQpIHtcbiAgICAgIGJhc2VYICs9IHRleHRPZmZzZXRbMF07XG4gICAgICBiYXNlWSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFzZVg6IGJhc2VYLFxuICAgIGJhc2VZOiBiYXNlWSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0Q3R4KGN0eCwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gRklYTUUgPz8/IHBlcmZvcm1hbmNlIHRyeVxuICAvLyBpZiAoY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSAhPT0gdmFsdWUpIHtcbiAgLy8gY3R4W3Byb3BdID0gY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICBjdHhbcHJvcF0gPSB2YWx1ZTsgLy8gfVxuXG4gIHJldHVybiBjdHhbcHJvcF07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3Ryb2tlXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtsaW5lV2lkdGhdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3R5bGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN0cm9rZShzdHJva2UsIGxpbmVXaWR0aCkge1xuICByZXR1cm4gc3Ryb2tlID09IG51bGwgfHwgbGluZVdpZHRoIDw9IDAgfHwgc3Ryb2tlID09PSAndHJhbnNwYXJlbnQnIHx8IHN0cm9rZSA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IHN0cm9rZS5pbWFnZSB8fCBzdHJva2UuY29sb3JTdG9wcyA/ICcjMDAwJyA6IHN0cm9rZTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsbChmaWxsKSB7XG4gIHJldHVybiBmaWxsID09IG51bGwgfHwgZmlsbCA9PT0gJ25vbmUnID8gbnVsbCAvLyBUT0RPIHBhdHRlcm4gYW5kIGdyYWRpZW50P1xuICA6IGZpbGwuaW1hZ2UgfHwgZmlsbC5jb2xvclN0b3BzID8gJyMwMDAnIDogZmlsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpIHtcbiAgcmV0dXJuIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0ZXh0UGFkZGluZ1sxXSA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4ICsgdGV4dFBhZGRpbmdbM10gLyAyIC0gdGV4dFBhZGRpbmdbMV0gLyAyIDogeCArIHRleHRQYWRkaW5nWzNdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdHlsZX0gc3R5bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBuZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpIHtcbiAgcmV0dXJuIHRleHQgIT0gbnVsbCAmJiAodGV4dCB8fCBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IgfHwgc3R5bGUudGV4dFBhZGRpbmcpO1xufVxuXG5leHBvcnRzLm5vcm1hbGl6ZVRleHRTdHlsZSA9IG5vcm1hbGl6ZVRleHRTdHlsZTtcbmV4cG9ydHMucmVuZGVyVGV4dCA9IHJlbmRlclRleHQ7XG5leHBvcnRzLmdldFN0cm9rZSA9IGdldFN0cm9rZTtcbmV4cG9ydHMuZ2V0RmlsbCA9IGdldEZpbGw7XG5leHBvcnRzLm5lZWREcmF3VGV4dCA9IG5lZWREcmF3VGV4dDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///295\n");

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

eval("var matrix = __webpack_require__(253);\n\nvar vector = __webpack_require__(236);\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzP2Y2MWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuLi9jb3JlL21hdHJpeFwiKTtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcbnZhciBFUFNJTE9OID0gNWUtNTtcblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcblxuICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiDlubPnp7tcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiDml4vovaxcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICB9XG5cbiAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgLyoqXG4gICAgICog57yp5pS+XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gIH1cbiAgLyoqXG4gICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG5cblxuICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG59O1xuXG52YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcbi8qKlxuICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICB9IGVsc2Uge1xuICAgIG1JZGVudGl0eShtKTtcbiAgfSAvLyDlupTnlKjniLboioLngrnlj5jmjaJcblxuXG4gIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG5cblxuICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xufTtcbi8qKlxuICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcblxuICBpZiAobSkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gIH1cbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbn07XG5cbnZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gIH1cblxuICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgfVxuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgfVxuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICBwb3NpdGlvblswXSA9IG1bNF07XG4gIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgc2NhbGVbMF0gPSBzeDtcbiAgc2NhbGVbMV0gPSBzeTtcbiAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbn07XG4vKipcbiAqIEdldCBnbG9iYWwgc2NhbGVcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBbMSwgMV07XG4gIH1cblxuICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcmV0dXJuIFtzeCwgc3ldO1xufTtcbi8qKlxuICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcblxuICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5cblxuVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgbSA9IG0gfHwgW107XG4gIG1JZGVudGl0eShtKTtcbiAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gIH1cblxuICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuXG4gIGlmIChyb3RhdGlvbikge1xuICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgbVs1XSArPSBvcmlnaW5bMV07XG4gIH1cblxuICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zZm9ybWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///296\n");

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

eval("var guid = __webpack_require__(288);\n\nvar env = __webpack_require__(239);\n\nvar zrUtil = __webpack_require__(230);\n\nvar Handler = __webpack_require__(354);\n\nvar Storage = __webpack_require__(357);\n\nvar Painter = __webpack_require__(356);\n\nvar Animation = __webpack_require__(358);\n\nvar HandlerProxy = __webpack_require__(368);\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRender实例map索引\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n  // FIXME 有点ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * 获取实例唯一标识\n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * 添加元素\n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * 删除元素\n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzPzVkY2QiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICczLjcuNCc7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCBvcHRzKSB7XG4gIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICByZXR1cm4genI7XG59XG4vKipcbiAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICovXG5cblxuZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICBpZiAoenIpIHtcbiAgICB6ci5kaXNwb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQYWludGVyKG5hbWUsIEN0b3IpIHtcbiAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3Rvcjtcbn1cblxuZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxudmFyIFpSZW5kZXIgPSBmdW5jdGlvbiAoaWQsIGRvbSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gaWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjsgLy8gVE9ETyBXZWJHTFxuXG4gIGlmICh1c2VWTUwpIHtcbiAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICB9XG5cbiAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgfSBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICB9XG5cbiAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgLyoqXG4gICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgKi9cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///297\n");

/***/ }),
/* 298 */,
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _layout = __webpack_require__(249);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(245);\n\nvar graphic = __webpack_require__(233);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanM/NTY2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2xheW91dCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIGdldExheW91dFJlY3QgPSBfbGF5b3V0LmdldExheW91dFJlY3Q7XG52YXIgbGF5b3V0Qm94ID0gX2xheW91dC5ib3g7XG52YXIgcG9zaXRpb25FbGVtZW50ID0gX2xheW91dC5wb3NpdGlvbkVsZW1lbnQ7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvZm9ybWF0XCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbi8qKlxuICogTGF5b3V0IGxpc3QgbGlrZSBjb21wb25lbnQuXG4gKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncm91cC9Hcm91cH0gZ3JvdXBcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gKi9cbmZ1bmN0aW9uIGxheW91dChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICB2YXIgYm94TGF5b3V0UGFyYW1zID0gY29tcG9uZW50TW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gIHZhciBwYWRkaW5nID0gY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gIHZhciB2aWV3cG9ydFNpemUgPSB7XG4gICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gIH07XG4gIHZhciByZWN0ID0gZ2V0TGF5b3V0UmVjdChib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gIGxheW91dEJveChjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLCBncm91cCwgY29tcG9uZW50TW9kZWwuZ2V0KCdpdGVtR2FwJyksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgcG9zaXRpb25FbGVtZW50KGdyb3VwLCBib3hMYXlvdXRQYXJhbXMsIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VCYWNrZ3JvdW5kKHJlY3QsIGNvbXBvbmVudE1vZGVsKSB7XG4gIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKSk7XG4gIHZhciBzdHlsZSA9IGNvbXBvbmVudE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gIHN0eWxlLmZpbGwgPSBjb21wb25lbnRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgIHNoYXBlOiB7XG4gICAgICB4OiByZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgeTogcmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl0sXG4gICAgICByOiBjb21wb25lbnRNb2RlbC5nZXQoJ2JvcmRlclJhZGl1cycpXG4gICAgfSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc2lsZW50OiB0cnVlLFxuICAgIHoyOiAtMVxuICB9KTsgLy8gRklYTUVcbiAgLy8gYHN1YlBpeGVsT3B0aW1pemVSZWN0YCBtYXkgYnJpbmcgc29tZSBnYXAgYmV0d2VlbiBlZGdlIG9mIHZpZXdwYXJ0XG4gIC8vIGFuZCBiYWNrZ3JvdW5kIHJlY3Qgd2hlbiBzZXR0aW5nIGxpa2UgYGxlZnQ6IDBgLCBgdG9wOiAwYC5cbiAgLy8gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICByZXR1cm4gcmVjdDtcbn1cblxuZXhwb3J0cy5sYXlvdXQgPSBsYXlvdXQ7XG5leHBvcnRzLm1ha2VCYWNrZ3JvdW5kID0gbWFrZUJhY2tncm91bmQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///299\n");

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar numberUtil = __webpack_require__(235);\n\nvar axisHelper = __webpack_require__(254);\n\nvar linearMap = numberUtil.linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\n\nvar Axis = function (dim, scale, extent) {\n  /**\n   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n   * @type {string}\n   */\n  this.dim = dim;\n  /**\n   * Axis scale\n   * @type {module:echarts/coord/scale/*}\n   */\n\n  this.scale = scale;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this._extent = extent || [0, 0];\n  /**\n   * @type {boolean}\n   */\n\n  this.inverse = false;\n  /**\n   * Usually true when axis has a ordinal scale\n   * @type {boolean}\n   */\n\n  this.onBand = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._labelInterval;\n};\n\nAxis.prototype = {\n  constructor: Axis,\n\n  /**\n   * If axis extent contain given coord\n   * @param {number} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  },\n\n  /**\n   * If axis extent contain given data\n   * @param {number} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.contain(this.dataToCoord(data));\n  },\n\n  /**\n   * Get coord extent.\n   * @return {Array.<number>}\n   */\n  getExtent: function () {\n    return this._extent.slice();\n  },\n\n  /**\n   * Get precision used for formatting\n   * @param {Array.<number>} [dataExtent]\n   * @return {number}\n   */\n  getPixelPrecision: function (dataExtent) {\n    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  },\n\n  /**\n   * Set coord extent\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  },\n\n  /**\n   * Convert data to coord. Data is the rank if it has a ordinal scale\n   * @param {number} data\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  dataToCoord: function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return linearMap(data, normalizedExtent, extent, clamp);\n  },\n\n  /**\n   * Convert coord to data. Data is the rank if it has a ordinal scale\n   * @param {number} coord\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  coordToData: function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = linearMap(coord, extent, normalizedExtent, clamp);\n    return this.scale.scale(t);\n  },\n\n  /**\n   * Convert pixel point to data in axis\n   * @param {Array.<number>} point\n   * @param  {boolean} clamp\n   * @return {number} data\n   */\n  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicksCoords: function (alignWithLabel) {\n    if (this.onBand && !alignWithLabel) {\n      var bands = this.getBands();\n      var coords = [];\n\n      for (var i = 0; i < bands.length; i++) {\n        coords.push(bands[i][0]);\n      }\n\n      if (bands[i - 1]) {\n        coords.push(bands[i - 1][1]);\n      }\n\n      return coords;\n    } else {\n      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n    }\n  },\n\n  /**\n   * Coords of labels are on the ticks or on the middle of bands\n   * @return {Array.<number>}\n   */\n  getLabelsCoords: function () {\n    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n  },\n\n  /**\n   * Get bands.\n   *\n   * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n   * |---1---|---2---|---3---|---4---|.\n   *\n   * @return {Array}\n   */\n  // FIXME Situation when labels is on ticks\n  getBands: function () {\n    var extent = this.getExtent();\n    var bands = [];\n    var len = this.scale.count();\n    var start = extent[0];\n    var end = extent[1];\n    var span = end - start;\n\n    for (var i = 0; i < len; i++) {\n      bands.push([span * i / len + start, span * (i + 1) / len + start]);\n    }\n\n    return bands;\n  },\n\n  /**\n   * Get width of band\n   * @return {number}\n   */\n  getBandWidth: function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  },\n\n  /**\n   * @abstract\n   * @return {boolean} Is horizontal\n   */\n  isHorizontal: null,\n\n  /**\n   * @abstract\n   * @return {number} Get axis rotate, by degree.\n   */\n  getRotate: null,\n\n  /**\n   * Get interval of the axis label.\n   * To get precise result, at least one of `getRotate` and `isHorizontal`\n   * should be implemented.\n   * @return {number}\n   */\n  getLabelInterval: function () {\n    var labelInterval = this._labelInterval;\n\n    if (!labelInterval) {\n      var axisModel = this.model;\n      var labelModel = axisModel.getModel('axisLabel');\n      labelInterval = labelModel.get('interval');\n\n      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {\n        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));\n      }\n\n      this._labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n};\nvar _default = Axis;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb29yZC9BeGlzLmpzPzczNmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuL2F4aXNIZWxwZXJcIik7XG5cbnZhciBsaW5lYXJNYXAgPSBudW1iZXJVdGlsLmxpbmVhck1hcDtcblxuZnVuY3Rpb24gZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgblRpY2spIHtcbiAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gIHZhciBsZW4gPSBuVGljaztcbiAgdmFyIG1hcmdpbiA9IHNpemUgLyBsZW4gLyAyO1xuICBleHRlbnRbMF0gKz0gbWFyZ2luO1xuICBleHRlbnRbMV0gLT0gbWFyZ2luO1xufVxuXG52YXIgbm9ybWFsaXplZEV4dGVudCA9IFswLCAxXTtcbi8qKlxuICogQG5hbWUgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuQXhpc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEF4aXMgPSBmdW5jdGlvbiAoZGltLCBzY2FsZSwgZXh0ZW50KSB7XG4gIC8qKlxuICAgKiBBeGlzIGRpbWVuc2lvbi4gU3VjaCBhcyAneCcsICd5JywgJ3onLCAnYW5nbGUnLCAncmFkaXVzJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5kaW0gPSBkaW07XG4gIC8qKlxuICAgKiBBeGlzIHNjYWxlXG4gICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS8qfVxuICAgKi9cblxuICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgMF07XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG4gIC8qKlxuICAgKiBVc3VhbGx5IHRydWUgd2hlbiBheGlzIGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMub25CYW5kID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYWJlbEludGVydmFsO1xufTtcblxuQXhpcy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBeGlzLFxuXG4gIC8qKlxuICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGNvb3JkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgbWluID0gTWF0aC5taW4oZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgcmV0dXJuIGNvb3JkID49IG1pbiAmJiBjb29yZCA8PSBtYXg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGF4aXMgZXh0ZW50IGNvbnRhaW4gZ2l2ZW4gZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbkRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbih0aGlzLmRhdGFUb0Nvb3JkKGRhdGEpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvb3JkIGV4dGVudC5cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwcmVjaXNpb24gdXNlZCBmb3IgZm9ybWF0dGluZ1xuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbZGF0YUV4dGVudF1cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxQcmVjaXNpb246IGZ1bmN0aW9uIChkYXRhRXh0ZW50KSB7XG4gICAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UGl4ZWxQcmVjaXNpb24oZGF0YUV4dGVudCB8fCB0aGlzLnNjYWxlLmdldEV4dGVudCgpLCB0aGlzLl9leHRlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgY29vcmQgZXh0ZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqL1xuICBzZXRFeHRlbnQ6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICBleHRlbnRbMF0gPSBzdGFydDtcbiAgICBleHRlbnRbMV0gPSBlbmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgZGF0YSB0byBjb29yZC4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgZGF0YSA9IHNjYWxlLm5vcm1hbGl6ZShkYXRhKTtcblxuICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgc2NhbGUuY291bnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVhck1hcChkYXRhLCBub3JtYWxpemVkRXh0ZW50LCBleHRlbnQsIGNsYW1wKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBjb29yZCB0byBkYXRhLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAoY29vcmQsIGNsYW1wKSB7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGxpbmVhck1hcChjb29yZCwgZXh0ZW50LCBub3JtYWxpemVkRXh0ZW50LCBjbGFtcCk7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuc2NhbGUodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgcGl4ZWwgcG9pbnQgdG8gZGF0YSBpbiBheGlzXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAqIEByZXR1cm4ge251bWJlcn0gZGF0YVxuICAgKi9cbiAgcG9pbnRUb0RhdGE6IGZ1bmN0aW9uIChwb2ludCwgY2xhbXApIHsvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZlZCBjbGFzcyBpZiBuZWNlc3NhcnkuXG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0VGlja3NDb29yZHM6IGZ1bmN0aW9uIChhbGlnbldpdGhMYWJlbCkge1xuICAgIGlmICh0aGlzLm9uQmFuZCAmJiAhYWxpZ25XaXRoTGFiZWwpIHtcbiAgICAgIHZhciBiYW5kcyA9IHRoaXMuZ2V0QmFuZHMoKTtcbiAgICAgIHZhciBjb29yZHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb29yZHMucHVzaChiYW5kc1tpXVswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYW5kc1tpIC0gMV0pIHtcbiAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaSAtIDFdWzFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvb3JkcyBvZiBsYWJlbHMgYXJlIG9uIHRoZSB0aWNrcyBvciBvbiB0aGUgbWlkZGxlIG9mIGJhbmRzXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0TGFiZWxzQ29vcmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGJhbmRzLlxuICAgKlxuICAgKiBJZiBheGlzIGhhcyBsYWJlbHMgWzEsIDIsIDMsIDRdLiBCYW5kcyBvbiB0aGUgYXhpcyBhcmVcbiAgICogfC0tLTEtLS18LS0tMi0tLXwtLS0zLS0tfC0tLTQtLS18LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIC8vIEZJWE1FIFNpdHVhdGlvbiB3aGVuIGxhYmVscyBpcyBvbiB0aWNrc1xuICBnZXRCYW5kczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIHZhciBiYW5kcyA9IFtdO1xuICAgIHZhciBsZW4gPSB0aGlzLnNjYWxlLmNvdW50KCk7XG4gICAgdmFyIHN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgIHZhciBlbmQgPSBleHRlbnRbMV07XG4gICAgdmFyIHNwYW4gPSBlbmQgLSBzdGFydDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGJhbmRzLnB1c2goW3NwYW4gKiBpIC8gbGVuICsgc3RhcnQsIHNwYW4gKiAoaSArIDEpIC8gbGVuICsgc3RhcnRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFuZHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB3aWR0aCBvZiBiYW5kXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhbmRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBheGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5zY2FsZS5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbGVuID0gZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0gKyAodGhpcy5vbkJhbmQgPyAxIDogMCk7IC8vIEZpeCAjMjcyOCwgYXZvaWQgTmFOIHdoZW4gb25seSBvbmUgZGF0YS5cblxuICAgIGxlbiA9PT0gMCAmJiAobGVuID0gMSk7XG4gICAgdmFyIHNpemUgPSBNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpIC8gbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgaG9yaXpvbnRhbFxuICAgKi9cbiAgaXNIb3Jpem9udGFsOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7bnVtYmVyfSBHZXQgYXhpcyByb3RhdGUsIGJ5IGRlZ3JlZS5cbiAgICovXG4gIGdldFJvdGF0ZTogbnVsbCxcblxuICAvKipcbiAgICogR2V0IGludGVydmFsIG9mIHRoZSBheGlzIGxhYmVsLlxuICAgKiBUbyBnZXQgcHJlY2lzZSByZXN1bHQsIGF0IGxlYXN0IG9uZSBvZiBgZ2V0Um90YXRlYCBhbmQgYGlzSG9yaXpvbnRhbGBcbiAgICogc2hvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSB0aGlzLl9sYWJlbEludGVydmFsO1xuXG4gICAgaWYgKCFsYWJlbEludGVydmFsKSB7XG4gICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgIGxhYmVsSW50ZXJ2YWwgPSBsYWJlbE1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAobGFiZWxJbnRlcnZhbCA9PSBudWxsIHx8IGxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJykpIHtcbiAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwoenJVdGlsLm1hcCh0aGlzLnNjYWxlLmdldFRpY2tzKCksIHRoaXMuZGF0YVRvQ29vcmQsIHRoaXMpLCBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCksIGxhYmVsTW9kZWwuZ2V0Rm9udCgpLCB0aGlzLmdldFJvdGF0ZSA/IHRoaXMuZ2V0Um90YXRlKCkgOiB0aGlzLmlzSG9yaXpvbnRhbCAmJiAhdGhpcy5pc0hvcml6b250YWwoKSA/IDkwIDogMCwgbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFiZWxJbnRlcnZhbCA9IGxhYmVsSW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBeGlzO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvQXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///300\n");

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar axisHelper = __webpack_require__(254);\n\nfunction getName(obj) {\n  if (zrUtil.isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nvar _default = {\n  /**\n   * Format labels\n   * @return {Array.<string>}\n   */\n  getFormattedLabels: function () {\n    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n  },\n\n  /**\n   * Get categories\n   */\n  getCategories: function () {\n    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n   */\n  getMin: function (origin) {\n    var option = this.option;\n    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;\n\n    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {\n      min = this.axis.scale.parse(min);\n    }\n\n    return min;\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n   */\n  getMax: function (origin) {\n    var option = this.option;\n    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;\n\n    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {\n      max = this.axis.scale.parse(max);\n    }\n\n    return max;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  getNeedCrossZero: function () {\n    var option = this.option;\n    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n  },\n\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return {module:echarts/model/Component} coordinate system model\n   */\n  getCoordSysModel: zrUtil.noop,\n\n  /**\n   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n   */\n  setRange: function (rangeStart, rangeEnd) {\n    this.option.rangeStart = rangeStart;\n    this.option.rangeEnd = rangeEnd;\n  },\n\n  /**\n   * Reset range\n   */\n  resetRange: function () {\n    // rangeStart and rangeEnd is readonly.\n    this.option.rangeStart = this.option.rangeEnd = null;\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qcz9hOGQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoXCIuL2F4aXNIZWxwZXJcIik7XG5cbmZ1bmN0aW9uIGdldE5hbWUob2JqKSB7XG4gIGlmICh6clV0aWwuaXNPYmplY3Qob2JqKSAmJiBvYmoudmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBvYmoudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iaiArICcnO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdCBsYWJlbHNcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICBnZXRGb3JtYXR0ZWRMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHModGhpcy5heGlzLCB0aGlzLmdldCgnYXhpc0xhYmVsLmZvcm1hdHRlcicpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNhdGVnb3JpZXNcbiAgICovXG4gIGdldENhdGVnb3JpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5JyAmJiB6clV0aWwubWFwKHRoaXMuZ2V0KCdkYXRhJyksIGdldE5hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9yaWdpblxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSBtaW4gdmFsdWUgb3IgJ2RhdGFNaW4nIG9yIG51bGwvdW5kZWZpbmVkIChtZWFucyBhdXRvKSBvciBOYU5cbiAgICovXG4gIGdldE1pbjogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB2YXIgbWluID0gIW9yaWdpbiAmJiBvcHRpb24ucmFuZ2VTdGFydCAhPSBudWxsID8gb3B0aW9uLnJhbmdlU3RhcnQgOiBvcHRpb24ubWluO1xuXG4gICAgaWYgKHRoaXMuYXhpcyAmJiBtaW4gIT0gbnVsbCAmJiBtaW4gIT09ICdkYXRhTWluJyAmJiB0eXBlb2YgbWluICE9PSAnZnVuY3Rpb24nICYmICF6clV0aWwuZXFOYU4obWluKSkge1xuICAgICAgbWluID0gdGhpcy5heGlzLnNjYWxlLnBhcnNlKG1pbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBvcmlnaW5cbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gbWF4IHZhbHVlIG9yICdkYXRhTWF4JyBvciBudWxsL3VuZGVmaW5lZCAobWVhbnMgYXV0bykgb3IgTmFOXG4gICAqL1xuICBnZXRNYXg6IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIG1heCA9ICFvcmlnaW4gJiYgb3B0aW9uLnJhbmdlRW5kICE9IG51bGwgPyBvcHRpb24ucmFuZ2VFbmQgOiBvcHRpb24ubWF4O1xuXG4gICAgaWYgKHRoaXMuYXhpcyAmJiBtYXggIT0gbnVsbCAmJiBtYXggIT09ICdkYXRhTWF4JyAmJiB0eXBlb2YgbWF4ICE9PSAnZnVuY3Rpb24nICYmICF6clV0aWwuZXFOYU4obWF4KSkge1xuICAgICAgbWF4ID0gdGhpcy5heGlzLnNjYWxlLnBhcnNlKG1heCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldE5lZWRDcm9zc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgcmV0dXJuIG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgfHwgb3B0aW9uLnJhbmdlRW5kICE9IG51bGwgPyBmYWxzZSA6ICFvcHRpb24uc2NhbGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIGF4aXMgbW9kZWwgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IGNvb3JkaW5hdGUgc3lzdGVtIG1vZGVsXG4gICAqL1xuICBnZXRDb29yZFN5c01vZGVsOiB6clV0aWwubm9vcCxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnQgQ2FuIG9ubHkgYmUgZmluaXRlIG51bWJlciBvciBudWxsL3VuZGVmaW5lZCBvciBOYU4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICovXG4gIHNldFJhbmdlOiBmdW5jdGlvbiAocmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICB0aGlzLm9wdGlvbi5yYW5nZVN0YXJ0ID0gcmFuZ2VTdGFydDtcbiAgICB0aGlzLm9wdGlvbi5yYW5nZUVuZCA9IHJhbmdlRW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldCByYW5nZVxuICAgKi9cbiAgcmVzZXRSYW5nZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIHJhbmdlU3RhcnQgYW5kIHJhbmdlRW5kIGlzIHJlYWRvbmx5LlxuICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSB0aGlzLm9wdGlvbi5yYW5nZUVuZCA9IG51bGw7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///301\n");

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Group = __webpack_require__(259);\n\nvar componentUtil = __webpack_require__(265);\n\nvar clazzUtil = __webpack_require__(247);\n\nvar Component = function () {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewComponent');\n};\n\nComponent.prototype = {\n  constructor: Component,\n  init: function (ecModel, api) {},\n  render: function (componentModel, ecModel, api, payload) {},\n  dispose: function () {}\n};\nvar componentProto = Component.prototype;\n\ncomponentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;\n}; // Enable Component.extend.\n\n\nclazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Component, {\n  registerWhenExtend: true\n});\nvar _default = Component;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qcz80MTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBHcm91cCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY29tcG9uZW50XCIpO1xuXG52YXIgY2xhenpVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvY2xhenpcIik7XG5cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnVpZCA9IGNvbXBvbmVudFV0aWwuZ2V0VUlEKCd2aWV3Q29tcG9uZW50Jyk7XG59O1xuXG5Db21wb25lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ29tcG9uZW50LFxuICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7fSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge30sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9XG59O1xudmFyIGNvbXBvbmVudFByb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuY29tcG9uZW50UHJvdG8udXBkYXRlVmlldyA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZUxheW91dCA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZVZpc3VhbCA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7Ly8gRG8gbm90aGluZztcbn07IC8vIEVuYWJsZSBDb21wb25lbnQuZXh0ZW5kLlxuXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDb21wb25lbnQpOyAvLyBFbmFibGUgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG5cbmNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50LCB7XG4gIHJlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZVxufSk7XG52YXIgX2RlZmF1bHQgPSBDb21wb25lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi92aWV3L0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///302\n");

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

eval("var env = __webpack_require__(239);\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qcz85MmE0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gMzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///303\n");

/***/ }),
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(52)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.allcover {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n}\\n.ctt {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n}\\n.tb {\\n  position: absolute;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n.lr {\\n  position: absolute;\\n  left: 50%;\\n  transform: translateX(-50%);\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvdmlzaXRvci52dWU/NTFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hbGxjb3ZlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG59XFxuLmN0dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cXG4udGIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcbi5sciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3tcIm1pbmltaXplXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNGNkNmQzYzFcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvcGFnZS92aXNpdG9yLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///317\n");

/***/ }),
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(52)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n.allcover {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n}\\n.ctt {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n}\\n.tb {\\n  position: absolute;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n.lr {\\n  position: absolute;\\n  left: 50%;\\n  transform: translateX(-50%);\\n}\\n.visitorpie {\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-pack: center;\\n      justify-content: center;\\n  margin-top: 20px;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlzaXRvclBpZS52dWU/OTJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hbGxjb3ZlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG59XFxuLmN0dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cXG4udGIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcbi5sciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcbi52aXNpdG9ycGllIHtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3tcIm1pbmltaXplXCI6ZmFsc2UsXCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZDkwNmNkZDhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJzb3VyY2VNYXBcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aXNpdG9yUGllLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMzI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///326\n");

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\nfunction ExtensionAPI(chartInstance) {\n  zrUtil.each(echartsAPIList, function (name) {\n    this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n  }, this);\n}\n\nvar _default = ExtensionAPI;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9FeHRlbnNpb25BUEkuanM/ZTI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGVjaGFydHNBUElMaXN0ID0gWydnZXREb20nLCAnZ2V0WnInLCAnZ2V0V2lkdGgnLCAnZ2V0SGVpZ2h0JywgJ2dldERldmljZVBpeGVsUmF0aW8nLCAnZGlzcGF0Y2hBY3Rpb24nLCAnaXNEaXNwb3NlZCcsICdvbicsICdvZmYnLCAnZ2V0RGF0YVVSTCcsICdnZXRDb25uZWN0ZWREYXRhVVJMJywgJ2dldE1vZGVsJywgJ2dldE9wdGlvbicsICdnZXRWaWV3T2ZDb21wb25lbnRNb2RlbCcsICdnZXRWaWV3T2ZTZXJpZXNNb2RlbCddOyAvLyBBbmQgYGdldENvb3JkaW5hdGVTeXN0ZW1zYCBhbmQgYGdldENvbXBvbmVudEJ5RWxlbWVudGAgd2lsbCBiZSBpbmplY3RlZCBpbiBlY2hhcnRzLmpzXG5cbmZ1bmN0aW9uIEV4dGVuc2lvbkFQSShjaGFydEluc3RhbmNlKSB7XG4gIHpyVXRpbC5lYWNoKGVjaGFydHNBUElMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChjaGFydEluc3RhbmNlW25hbWVdLCBjaGFydEluc3RhbmNlKTtcbiAgfSwgdGhpcyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IEV4dGVuc2lvbkFQSTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL0V4dGVuc2lvbkFQSS5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///327\n");

/***/ }),
/* 328 */,
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\n__webpack_require__(330);\n\n__webpack_require__(332);\n\n__webpack_require__(331);\n\nvar legendFilter = __webpack_require__(333);\n\nvar Component = __webpack_require__(248);\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kLmpzP2Q4OTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vZWNoYXJ0c1wiKTtcblxucmVxdWlyZShcIi4vbGVnZW5kL0xlZ2VuZE1vZGVsXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvbGVnZW5kQWN0aW9uXCIpO1xuXG5yZXF1aXJlKFwiLi9sZWdlbmQvTGVnZW5kVmlld1wiKTtcblxudmFyIGxlZ2VuZEZpbHRlciA9IHJlcXVpcmUoXCIuL2xlZ2VuZC9sZWdlbmRGaWx0ZXJcIik7XG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiLi4vbW9kZWwvQ29tcG9uZW50XCIpO1xuXG4vLyBEbyBub3QgY29udGFpbiBzY3JvbGxhYmxlIGxlZ2VuZCwgZm9yIHNha2Ugb2YgZmlsZSBzaXplLlxuLy8gU2VyaWVzIEZpbHRlclxuZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihsZWdlbmRGaWx0ZXIpO1xuQ29tcG9uZW50LnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcignbGVnZW5kJywgZnVuY3Rpb24gKCkge1xuICAvLyBEZWZhdWx0ICdwbGFpbicgd2hlbiBubyB0eXBlIHNwZWNpZmllZC5cbiAgcmV0dXJuICdwbGFpbic7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///329\n");

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar zrUtil = __webpack_require__(230);\n\nvar Model = __webpack_require__(246);\n\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    this._data = legendData;\n    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n      return series.name;\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        availableNames = availableNames.concat(data.mapArray(data.getName));\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 4,\n    show: true,\n    // 布局方式，默认为水平布局，可选为：\n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // 水平对齐\n    // 'auto' | 'left' | 'right'\n    // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 图例边框颜色\n    borderColor: '#ccc',\n    borderRadius: 0,\n    // 图例边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 图例内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 各个item之间的间隔，单位px，默认为10，\n    // 横向布局时为水平间隔，纵向布局时为纵向间隔\n    itemGap: 10,\n    // 图例图形宽度\n    itemWidth: 25,\n    // 图例图形高度\n    itemHeight: 14,\n    // 图例关闭时候的颜色\n    inactiveColor: '#ccc',\n    textStyle: {\n      // 图例文字颜色\n      color: '#333'\n    },\n    // formatter: '',\n    // 选择模式，默认开启图例开关\n    selectedMode: true,\n    // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n    // selected: null,\n    // 图例内容（详见legend.data，数组中每一项代表一个item\n    // data: [],\n    // Tooltip 相关配置\n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZE1vZGVsLmpzP2JiZTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi9tb2RlbC9Nb2RlbFwiKTtcblxudmFyIExlZ2VuZE1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG4gIHR5cGU6ICdsZWdlbmQucGxhaW4nLFxuICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG4gIGxheW91dE1vZGU6IHtcbiAgICB0eXBlOiAnYm94JyxcbiAgICAvLyBsZWdlbmQud2lkdGgvaGVpZ2h0IGFyZSBtYXhXaWR0aC9tYXhIZWlnaHQgYWN0dWFsbHksXG4gICAgLy8gd2hlcmVhcyByZWFseSB3aWR0aC9oZWlnaHQgaXMgY2FsY3VsYXRlZCBieSBpdHMgY29udGVudC5cbiAgICAvLyAoU2V0dGluZyB7bGVmdDogMTAsIHJpZ2h0OiAxMH0gZG9lcyBub3QgbWFrZSBzZW5zZSkuXG4gICAgLy8gU28gY29uc2lkZXIgdGhlIGNhc2U6XG4gICAgLy8gYHNldE9wdGlvbih7bGVnZW5kOiB7bGVmdDogMTB9KTtgXG4gICAgLy8gdGhlbiBgc2V0T3B0aW9uKHtsZWdlbmQ6IHtyaWdodDogMTB9KTtgXG4gICAgLy8gVGhlIHByZXZpb3VzIGBsZWZ0YCBzaG91bGQgYmUgY2xlYXJlZCBieSBzZXR0aW5nIGBpZ25vcmVTaXplYC5cbiAgICBpZ25vcmVTaXplOiB0cnVlXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi5zZWxlY3RlZCB8fCB7fTtcbiAgfSxcbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgfSxcbiAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEodGhpcy5lY01vZGVsKTtcblxuICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTsgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcblxuICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBoYXNTZWxlY3RlZCA9IGZhbHNlOyAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsZWdlbmREYXRhW2ldLmdldCgnbmFtZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAvLyBGb3JjZSB0byB1bnNlbGVjdCBvdGhlcnNcbiAgICAgICAgICB0aGlzLnNlbGVjdChuYW1lKTtcbiAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVHJ5IHNlbGVjdCB0aGUgZmlyc3QgaWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZVxuXG5cbiAgICAgICFoYXNTZWxlY3RlZCAmJiB0aGlzLnNlbGVjdChsZWdlbmREYXRhWzBdLmdldCgnbmFtZScpKTtcbiAgICB9XG4gIH0sXG4gIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBsZWdlbmREYXRhID0genJVdGlsLm1hcCh0aGlzLmdldCgnZGF0YScpIHx8IFtdLCBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICBpZiAodHlwZW9mIGRhdGFJdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0YUl0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGFJdGVtID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fZGF0YSA9IGxlZ2VuZERhdGE7XG4gICAgdmFyIGF2YWlsYWJsZU5hbWVzID0genJVdGlsLm1hcChlY01vZGVsLmdldFNlcmllcygpLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgfSk7XG4gICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcigpO1xuICAgICAgICBhdmFpbGFibGVOYW1lcyA9IGF2YWlsYWJsZU5hbWVzLmNvbmNhdChkYXRhLm1hcEFycmF5KGRhdGEuZ2V0TmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5fYXZhaWxhYmxlTmFtZXMgPSBhdmFpbGFibGVOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn1cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICB2YXIgc2VsZWN0ZWRNb2RlID0gdGhpcy5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuXG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJykgIT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkOyAvLyBEZWZhdWx0IGlzIHRydWVcblxuICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzW3NlbGVjdGVkW25hbWVdID8gJ3VuU2VsZWN0JyA6ICdzZWxlY3QnXShuYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5vcHRpb24uc2VsZWN0ZWQ7XG4gICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKSAmJiB6clV0aWwuaW5kZXhPZih0aGlzLl9hdmFpbGFibGVOYW1lcywgbmFtZSkgPj0gMDtcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA0LFxuICAgIHNob3c6IHRydWUsXG4gICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgLy8gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuICAgIG9yaWVudDogJ2hvcml6b250YWwnLFxuICAgIGxlZnQ6ICdjZW50ZXInLFxuICAgIC8vIHJpZ2h0OiAnY2VudGVyJyxcbiAgICB0b3A6IDAsXG4gICAgLy8gYm90dG9tOiBudWxsLFxuICAgIC8vIOawtOW5s+Wvuem9kFxuICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAvLyDpu5jorqTkuLogJ2F1dG8nLCDmoLnmja4geCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICBhbGlnbjogJ2F1dG8nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIC8vIOWbvuS+i+i+ueahhuminOiJslxuICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIC8vIOWbvuS+i+i+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIC8vIOWbvuS+i+WGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLy8g5ZCE5LiqaXRlbeS5i+mXtOeahOmXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICAvLyDmqKrlkJHluIPlsYDml7bkuLrmsLTlubPpl7TpmpTvvIznurXlkJHluIPlsYDml7bkuLrnurXlkJHpl7TpmpRcbiAgICBpdGVtR2FwOiAxMCxcbiAgICAvLyDlm77kvovlm77lvaLlrr3luqZcbiAgICBpdGVtV2lkdGg6IDI1LFxuICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgIGl0ZW1IZWlnaHQ6IDE0LFxuICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgIGluYWN0aXZlQ29sb3I6ICcjY2NjJyxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8vIOWbvuS+i+aWh+Wtl+minOiJslxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAvLyDpgInmi6nmqKHlvI/vvIzpu5jorqTlvIDlkK/lm77kvovlvIDlhbNcbiAgICBzZWxlY3RlZE1vZGU6IHRydWUsXG4gICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgLy8gc2VsZWN0ZWQ6IG51bGwsXG4gICAgLy8g5Zu+5L6L5YaF5a6577yI6K+m6KeBbGVnZW5kLmRhdGHvvIzmlbDnu4TkuK3mr4/kuIDpobnku6PooajkuIDkuKppdGVtXG4gICAgLy8gZGF0YTogW10sXG4gICAgLy8gVG9vbHRpcCDnm7jlhbPphY3nva5cbiAgICB0b29sdGlwOiB7XG4gICAgICBzaG93OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBMZWdlbmRNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDMzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///330\n");

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(232);\n\nvar zrUtil = __webpack_require__(230);\n\nvar _symbol = __webpack_require__(266);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(233);\n\nvar _listComponent = __webpack_require__(299);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(249);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL0xlZ2VuZFZpZXcuanM/MTI0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi8uLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9zeW1ib2xcIik7XG5cbnZhciBjcmVhdGVTeW1ib2wgPSBfc3ltYm9sLmNyZWF0ZVN5bWJvbDtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgX2xpc3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi4vaGVscGVyL2xpc3RDb21wb25lbnRcIik7XG5cbnZhciBtYWtlQmFja2dyb3VuZCA9IF9saXN0Q29tcG9uZW50Lm1ha2VCYWNrZ3JvdW5kO1xuXG52YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2xheW91dFwiKTtcblxudmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBHcm91cCA9IGdyYXBoaWMuR3JvdXA7XG5cbnZhciBfZGVmYXVsdCA9IGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG4gIHR5cGU6ICdsZWdlbmQucGxhaW4nLFxuICBuZXdsaW5lRGlzYWJsZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICovXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5fY29udGVudEdyb3VwID0gbmV3IEdyb3VwKCkpO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICovXG5cbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldENvbnRlbnRHcm91cDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50R3JvdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgIHRoaXMucmVzZXRJbm5lcigpO1xuXG4gICAgaWYgKCFsZWdlbmRNb2RlbC5nZXQoJ3Nob3cnLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtQWxpZ24gPSBsZWdlbmRNb2RlbC5nZXQoJ2FsaWduJyk7XG5cbiAgICBpZiAoIWl0ZW1BbGlnbiB8fCBpdGVtQWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgaXRlbUFsaWduID0gbGVnZW5kTW9kZWwuZ2V0KCdsZWZ0JykgPT09ICdyaWdodCcgJiYgbGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSA9PT0gJ3ZlcnRpY2FsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJJbm5lcihpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGkpOyAvLyBQZXJmb3JtIGxheW91dC5cblxuICAgIHZhciBwb3NpdGlvbkluZm8gPSBsZWdlbmRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgICB2YXIgdmlld3BvcnRTaXplID0ge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9O1xuICAgIHZhciBwYWRkaW5nID0gbGVnZW5kTW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gICAgdmFyIG1heFNpemUgPSBsYXlvdXRVdGlsLmdldExheW91dFJlY3QocG9zaXRpb25JbmZvLCB2aWV3cG9ydFNpemUsIHBhZGRpbmcpO1xuICAgIHZhciBtYWluUmVjdCA9IHRoaXMubGF5b3V0SW5uZXIobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSk7IC8vIFBsYWNlIG1haW5Hcm91cCwgYmFzZWQgb24gdGhlIGNhbGN1bGF0ZWQgYG1haW5SZWN0YC5cblxuICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0VXRpbC5nZXRMYXlvdXRSZWN0KHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICB3aWR0aDogbWFpblJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IG1haW5SZWN0LmhlaWdodFxuICAgIH0sIHBvc2l0aW9uSW5mbyksIHZpZXdwb3J0U2l6ZSwgcGFkZGluZyk7XG4gICAgdGhpcy5ncm91cC5hdHRyKCdwb3NpdGlvbicsIFtsYXlvdXRSZWN0LnggLSBtYWluUmVjdC54LCBsYXlvdXRSZWN0LnkgLSBtYWluUmVjdC55XSk7IC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dC5cblxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2JhY2tncm91bmRFbCA9IG1ha2VCYWNrZ3JvdW5kKG1haW5SZWN0LCBsZWdlbmRNb2RlbCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZXNldElubmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5nZXRDb250ZW50R3JvdXAoKS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWwgJiYgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5fYmFja2dyb3VuZEVsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVuZGVySW5uZXI6IGZ1bmN0aW9uIChpdGVtQWxpZ24sIGxlZ2VuZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB2YXIgY29udGVudEdyb3VwID0gdGhpcy5nZXRDb250ZW50R3JvdXAoKTtcbiAgICB2YXIgbGVnZW5kRHJhd25NYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCgpO1xuICAgIHZhciBzZWxlY3RNb2RlID0gbGVnZW5kTW9kZWwuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICBlYWNoKGxlZ2VuZE1vZGVsLmdldERhdGEoKSwgZnVuY3Rpb24gKGl0ZW1Nb2RlbCwgZGF0YUluZGV4KSB7XG4gICAgICB2YXIgbmFtZSA9IGl0ZW1Nb2RlbC5nZXQoJ25hbWUnKTsgLy8gVXNlIGVtcHR5IHN0cmluZyBvciBcXG4gYXMgYSBuZXdsaW5lIHN0cmluZ1xuXG4gICAgICBpZiAoIXRoaXMubmV3bGluZURpc2FibGVkICYmIChuYW1lID09PSAnJyB8fCBuYW1lID09PSAnXFxuJykpIHtcbiAgICAgICAgY29udGVudEdyb3VwLmFkZChuZXcgR3JvdXAoe1xuICAgICAgICAgIG5ld2xpbmU6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKG5hbWUpWzBdO1xuXG4gICAgICBpZiAobGVnZW5kRHJhd25NYXAuZ2V0KG5hbWUpKSB7XG4gICAgICAgIC8vIEhhdmUgYmVlbiBkcmF3ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTZXJpZXMgbGVnZW5kXG5cblxuICAgICAgaWYgKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldFZpc3VhbCgnY29sb3InKTsgLy8gSWYgY29sb3IgaXMgYSBjYWxsYmFjayBmdW5jdGlvblxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGRhdGFcbiAgICAgICAgICBjb2xvciA9IGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoMCkpO1xuICAgICAgICB9IC8vIFVzaW5nIHJlY3Qgc3ltYm9sIGRlZmF1bHRseVxuXG5cbiAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnbGVnZW5kU3ltYm9sJykgfHwgJ3JvdW5kUmVjdCc7XG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpO1xuXG4gICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKG5hbWUsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCwgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSwgaXRlbUFsaWduLCBjb2xvciwgc2VsZWN0TW9kZSk7XG5cbiAgICAgICAgaXRlbUdyb3VwLm9uKCdjbGljaycsIGN1cnJ5KGRpc3BhdGNoU2VsZWN0QWN0aW9uLCBuYW1lLCBhcGkpKS5vbignbW91c2VvdmVyJywgY3VycnkoZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKS5vbignbW91c2VvdXQnLCBjdXJyeShkaXNwYXRjaERvd25wbGF5QWN0aW9uLCBzZXJpZXNNb2RlbCwgbnVsbCwgYXBpKSk7XG4gICAgICAgIGxlZ2VuZERyYXduTWFwLnNldChuYW1lLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERhdGEgbGVnZW5kIG9mIHBpZSwgZnVubmVsXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1NlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHNlcmllcyBoYXMgc2FtZSBkYXRhIG5hbWVcbiAgICAgICAgICBpZiAobGVnZW5kRHJhd25NYXAuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5sZWdlbmREYXRhUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBkYXRhLmluZGV4T2ZOYW1lKG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHRoaXMuX2NyZWF0ZUl0ZW0obmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKTtcblxuICAgICAgICAgICAgaXRlbUdyb3VwLm9uKCdjbGljaycsIGN1cnJ5KGRpc3BhdGNoU2VsZWN0QWN0aW9uLCBuYW1lLCBhcGkpKSAvLyBGSVhNRSBTaG91bGQgbm90IHNwZWNpZnkgdGhlIHNlcmllcyBuYW1lXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSkub24oJ21vdXNlb3V0JywgY3VycnkoZGlzcGF0Y2hEb3ducGxheUFjdGlvbiwgc2VyaWVzTW9kZWwsIG5hbWUsIGFwaSkpO1xuICAgICAgICAgICAgbGVnZW5kRHJhd25NYXAuc2V0KG5hbWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9jcmVhdGVJdGVtOiBmdW5jdGlvbiAobmFtZSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLCBsZWdlbmRTeW1ib2xUeXBlLCBzeW1ib2xUeXBlLCBpdGVtQWxpZ24sIGNvbG9yLCBzZWxlY3RNb2RlKSB7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IGxlZ2VuZE1vZGVsLmdldCgnaXRlbVdpZHRoJyk7XG4gICAgdmFyIGl0ZW1IZWlnaHQgPSBsZWdlbmRNb2RlbC5nZXQoJ2l0ZW1IZWlnaHQnKTtcbiAgICB2YXIgaW5hY3RpdmVDb2xvciA9IGxlZ2VuZE1vZGVsLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuICAgIHZhciBpc1NlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChuYW1lKTtcbiAgICB2YXIgaXRlbUdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgaXRlbUljb24gPSBpdGVtTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgndG9vbHRpcCcpO1xuICAgIHZhciBsZWdlbmRHbG9iYWxUb29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWwucGFyZW50TW9kZWw7IC8vIFVzZSB1c2VyIGdpdmVuIGljb24gZmlyc3RcblxuICAgIGxlZ2VuZFN5bWJvbFR5cGUgPSBpdGVtSWNvbiB8fCBsZWdlbmRTeW1ib2xUeXBlO1xuICAgIGl0ZW1Hcm91cC5hZGQoY3JlYXRlU3ltYm9sKGxlZ2VuZFN5bWJvbFR5cGUsIDAsIDAsIGl0ZW1XaWR0aCwgaXRlbUhlaWdodCwgaXNTZWxlY3RlZCA/IGNvbG9yIDogaW5hY3RpdmVDb2xvciwgdHJ1ZSkpOyAvLyBDb21wb3NlIHN5bWJvbHNcbiAgICAvLyBQRU5ESU5HXG5cbiAgICBpZiAoIWl0ZW1JY29uICYmIHN5bWJvbFR5cGUgLy8gQXQgbGVhc3Qgc2hvdyBvbmUgc3ltYm9sLCBjYW4ndCBiZSBhbGwgbm9uZVxuICAgICYmIChzeW1ib2xUeXBlICE9PSBsZWdlbmRTeW1ib2xUeXBlIHx8IHN5bWJvbFR5cGUgPT0gJ25vbmUnKSkge1xuICAgICAgdmFyIHNpemUgPSBpdGVtSGVpZ2h0ICogMC44O1xuXG4gICAgICBpZiAoc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHN5bWJvbFR5cGUgPSAnY2lyY2xlJztcbiAgICAgIH0gLy8gUHV0IHN5bWJvbCBpbiB0aGUgY2VudGVyXG5cblxuICAgICAgaXRlbUdyb3VwLmFkZChjcmVhdGVTeW1ib2woc3ltYm9sVHlwZSwgKGl0ZW1XaWR0aCAtIHNpemUpIC8gMiwgKGl0ZW1IZWlnaHQgLSBzaXplKSAvIDIsIHNpemUsIHNpemUsIGlzU2VsZWN0ZWQgPyBjb2xvciA6IGluYWN0aXZlQ29sb3IpKTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dFggPSBpdGVtQWxpZ24gPT09ICdsZWZ0JyA/IGl0ZW1XaWR0aCArIDUgOiAtNTtcbiAgICB2YXIgdGV4dEFsaWduID0gaXRlbUFsaWduO1xuICAgIHZhciBmb3JtYXR0ZXIgPSBsZWdlbmRNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgIHZhciBjb250ZW50ID0gbmFtZTtcblxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJyAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIucmVwbGFjZSgne25hbWV9JywgbmFtZSAhPSBudWxsID8gbmFtZSA6ICcnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnQgPSBmb3JtYXR0ZXIobmFtZSk7XG4gICAgfVxuXG4gICAgaXRlbUdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBncmFwaGljLnNldFRleHRTdHlsZSh7fSwgdGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgeDogdGV4dFgsXG4gICAgICAgIHk6IGl0ZW1IZWlnaHQgLyAyLFxuICAgICAgICB0ZXh0RmlsbDogaXNTZWxlY3RlZCA/IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIDogaW5hY3RpdmVDb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgfSlcbiAgICB9KSk7IC8vIEFkZCBhIGludmlzaWJsZSByZWN0IHRvIGluY3JlYXNlIHRoZSBhcmVhIG9mIG1vdXNlIGhvdmVyXG5cbiAgICB2YXIgaGl0UmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgc2hhcGU6IGl0ZW1Hcm91cC5nZXRCb3VuZGluZ1JlY3QoKSxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIHRvb2x0aXA6IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSA/IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAvLyBEZWZhdWwgZm9ybWF0dGVyXG4gICAgICAgIGZvcm1hdHRlcjogbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJywgdHJ1ZSkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXJQYXJhbXM6IHtcbiAgICAgICAgICBjb21wb25lbnRUeXBlOiAnbGVnZW5kJyxcbiAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAkdmFyczogWyduYW1lJ11cbiAgICAgICAgfVxuICAgICAgfSwgdG9vbHRpcE1vZGVsLm9wdGlvbikgOiBudWxsXG4gICAgfSk7XG4gICAgaXRlbUdyb3VwLmFkZChoaXRSZWN0KTtcbiAgICBpdGVtR3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2hpbGQuc2lsZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBoaXRSZWN0LnNpbGVudCA9ICFzZWxlY3RNb2RlO1xuICAgIHRoaXMuZ2V0Q29udGVudEdyb3VwKCkuYWRkKGl0ZW1Hcm91cCk7XG4gICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKGl0ZW1Hcm91cCk7XG4gICAgaXRlbUdyb3VwLl9fbGVnZW5kRGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgIHJldHVybiBpdGVtR3JvdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGxheW91dElubmVyOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGl0ZW1BbGlnbiwgbWF4U2l6ZSkge1xuICAgIHZhciBjb250ZW50R3JvdXAgPSB0aGlzLmdldENvbnRlbnRHcm91cCgpOyAvLyBQbGFjZSBpdGVtcyBpbiBjb250ZW50R3JvdXAuXG5cbiAgICBsYXlvdXRVdGlsLmJveChsZWdlbmRNb2RlbC5nZXQoJ29yaWVudCcpLCBjb250ZW50R3JvdXAsIGxlZ2VuZE1vZGVsLmdldCgnaXRlbUdhcCcpLCBtYXhTaXplLndpZHRoLCBtYXhTaXplLmhlaWdodCk7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudEdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIGNvbnRlbnRHcm91cC5hdHRyKCdwb3NpdGlvbicsIFstY29udGVudFJlY3QueCwgLWNvbnRlbnRSZWN0LnldKTtcbiAgICByZXR1cm4gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRpc3BhdGNoU2VsZWN0QWN0aW9uKG5hbWUsIGFwaSkge1xuICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgIHR5cGU6ICdsZWdlbmRUb2dnbGVTZWxlY3QnLFxuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuXG4gIGlmICghKGVsICYmIGVsLnVzZUhvdmVyTGF5ZXIpKSB7XG4gICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICBzZXJpZXNOYW1lOiBzZXJpZXNNb2RlbC5uYW1lLFxuICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaERvd25wbGF5QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuXG4gIGlmICghKGVsICYmIGVsLnVzZUhvdmVyTGF5ZXIpKSB7XG4gICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICBuYW1lOiBkYXRhTmFtZVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMzMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///331\n");

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar zrUtil = __webpack_require__(230);\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEFjdGlvbi5qcz9iN2E5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uLy4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG5mdW5jdGlvbiBsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyKG1ldGhvZE5hbWUsIHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgdmFyIHNlbGVjdGVkTWFwID0ge307XG4gIHZhciBpc1RvZ2dsZVNlbGVjdCA9IG1ldGhvZE5hbWUgPT09ICd0b2dnbGVTZWxlY3RlZCc7XG4gIHZhciBpc1NlbGVjdGVkOyAvLyBVcGRhdGUgYWxsIGxlZ2VuZCBjb21wb25lbnRzXG5cbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwpIHtcbiAgICBpZiAoaXNUb2dnbGVTZWxlY3QgJiYgaXNTZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICAvLyBGb3JjZSBvdGhlciBsZWdlbmQgaGFzIHNhbWUgc2VsZWN0ZWQgc3RhdHVzXG4gICAgICAvLyBPciB0aGUgZmlyc3QgaXMgdG9nZ2xlZCB0byB0cnVlIGFuZCBvdGhlciBhcmUgdG9nZ2xlZCB0byBmYWxzZVxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb25lIGxlZ2VuZCBoYXMgc29tZSBpdGVtIHVuU2VsZWN0ZWQgaW4gb3B0aW9uLiBBbmQgaWYgb3RoZXIgbGVnZW5kXG4gICAgICAvLyBkb2Vzbid0IGhhcyB0aGUgaXRlbSwgdGhleSB3aWxsIGFzc3VtZSBpdCBpcyBzZWxlY3RlZC5cbiAgICAgIGxlZ2VuZE1vZGVsW2lzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1blNlbGVjdCddKHBheWxvYWQubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZ2VuZE1vZGVsW21ldGhvZE5hbWVdKHBheWxvYWQubmFtZSk7XG4gICAgICBpc1NlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChwYXlsb2FkLm5hbWUpO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmREYXRhID0gbGVnZW5kTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHpyVXRpbC5lYWNoKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgdmFyIG5hbWUgPSBtb2RlbC5nZXQoJ25hbWUnKTsgLy8gV3JhcCBlbGVtZW50XG5cbiAgICAgIGlmIChuYW1lID09PSAnXFxuJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0l0ZW1TZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZE1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvLyBVbnNlbGVjdGVkIGlmIGFueSBsZWdlbmQgaXMgdW5zZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHNlbGVjdGVkTWFwW25hbWVdICYmIGlzSXRlbVNlbGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIFJldHVybiB0aGUgZXZlbnQgZXhwbGljaXRseVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgIHNlbGVjdGVkOiBzZWxlY3RlZE1hcFxuICB9O1xufVxuLyoqXG4gKiBAZXZlbnQgbGVnZW5kVG9nZ2xlU2VsZWN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gKi9cblxuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRUb2dnbGVTZWxlY3QnLCAnbGVnZW5kc2VsZWN0Y2hhbmdlZCcsIHpyVXRpbC5jdXJyeShsZWdlbmRTZWxlY3RBY3Rpb25IYW5kbGVyLCAndG9nZ2xlU2VsZWN0ZWQnKSk7XG4vKipcbiAqIEBldmVudCBsZWdlbmRTZWxlY3RcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAnbGVnZW5kU2VsZWN0J1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAqL1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRTZWxlY3QnLCAnbGVnZW5kc2VsZWN0ZWQnLCB6clV0aWwuY3VycnkobGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlciwgJ3NlbGVjdCcpKTtcbi8qKlxuICogQGV2ZW50IGxlZ2VuZFVuU2VsZWN0XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgJ2xlZ2VuZFVuU2VsZWN0J1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAqL1xuXG5lY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKCdsZWdlbmRVblNlbGVjdCcsICdsZWdlbmR1bnNlbGVjdGVkJywgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd1blNlbGVjdCcpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZC9sZWdlbmRBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///332\n");

/***/ }),
/* 333 */
/***/ (function(module, exports) {

eval("function _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qcz85M2IyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZhdWx0KGVjTW9kZWwpIHtcbiAgdmFyIGxlZ2VuZE1vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICB9KTtcblxuICBpZiAobGVnZW5kTW9kZWxzICYmIGxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICBlY01vZGVsLmZpbHRlclNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAvLyBJZiBpbiBhbnkgbGVnZW5kIGNvbXBvbmVudCB0aGUgc3RhdHVzIGlzIG5vdCBzZWxlY3RlZC5cbiAgICAgIC8vIEJlY2F1c2UgaW4gbGVnZW5kIHNlcmllcyBpcyBhc3N1bWVkIHNlbGVjdGVkIHdoZW4gaXQgaXMgbm90IGluIHRoZSBsZWdlbmQgZGF0YS5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kTW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbGVnZW5kTW9kZWxzW2ldLmlzU2VsZWN0ZWQoc2VyaWVzLm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///333\n");

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar graphic = __webpack_require__(233);\n\nvar _layout = __webpack_require__(249);\n\nvar getLayoutRect = _layout.getLayoutRect;\n// Model\necharts.extendComponentModel({\n  type: 'title',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  defaultOption: {\n    // 一级层叠\n    zlevel: 0,\n    // 二级层叠\n    z: 6,\n    show: true,\n    text: '',\n    // 超链接跳转\n    // link: null,\n    // 仅支持self | blank\n    target: 'blank',\n    subtext: '',\n    // 超链接跳转\n    // sublink: null,\n    // 仅支持self | blank\n    subtarget: 'blank',\n    // 'center' ¦ 'left' ¦ 'right'\n    // ¦ {number}（x坐标，单位px）\n    left: 0,\n    // 'top' ¦ 'bottom' ¦ 'center'\n    // ¦ {number}（y坐标，单位px）\n    top: 0,\n    // 水平对齐\n    // 'auto' | 'left' | 'right' | 'center'\n    // 默认根据 left 的位置判断是左对齐还是右对齐\n    // textAlign: null\n    //\n    // 垂直对齐\n    // 'auto' | 'top' | 'bottom' | 'middle'\n    // 默认根据 top 位置判断是上对齐还是下对齐\n    // textBaseline: null\n    backgroundColor: 'rgba(0,0,0,0)',\n    // 标题边框颜色\n    borderColor: '#ccc',\n    // 标题边框线宽，单位px，默认为0（无边框）\n    borderWidth: 0,\n    // 标题内边距，单位px，默认各方向内边距为5，\n    // 接受数组分别设定上右下左边距，同css\n    padding: 5,\n    // 主副标题纵向间隔，单位px，默认为10，\n    itemGap: 10,\n    textStyle: {\n      fontSize: 18,\n      fontWeight: 'bolder',\n      color: '#333'\n    },\n    subtextStyle: {\n      color: '#aaa'\n    }\n  }\n}); // View\n\necharts.extendComponentView({\n  type: 'title',\n  render: function (titleModel, ecModel, api) {\n    this.group.removeAll();\n\n    if (!titleModel.get('show')) {\n      return;\n    }\n\n    var group = this.group;\n    var textStyleModel = titleModel.getModel('textStyle');\n    var subtextStyleModel = titleModel.getModel('subtextStyle');\n    var textAlign = titleModel.get('textAlign');\n    var textBaseline = titleModel.get('textBaseline');\n    var textEl = new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: titleModel.get('text'),\n        textFill: textStyleModel.getTextColor()\n      }, {\n        disableBox: true\n      }),\n      z2: 10\n    });\n    var textRect = textEl.getBoundingRect();\n    var subText = titleModel.get('subtext');\n    var subTextEl = new graphic.Text({\n      style: graphic.setTextStyle({}, subtextStyleModel, {\n        text: subText,\n        textFill: subtextStyleModel.getTextColor(),\n        y: textRect.height + titleModel.get('itemGap'),\n        textVerticalAlign: 'top'\n      }, {\n        disableBox: true\n      }),\n      z2: 10\n    });\n    var link = titleModel.get('link');\n    var sublink = titleModel.get('sublink');\n    textEl.silent = !link;\n    subTextEl.silent = !sublink;\n\n    if (link) {\n      textEl.on('click', function () {\n        window.open(link, '_' + titleModel.get('target'));\n      });\n    }\n\n    if (sublink) {\n      subTextEl.on('click', function () {\n        window.open(sublink, '_' + titleModel.get('subtarget'));\n      });\n    }\n\n    group.add(textEl);\n    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.\n\n    var groupRect = group.getBoundingRect();\n    var layoutOption = titleModel.getBoxLayoutParams();\n    layoutOption.width = groupRect.width;\n    layoutOption.height = groupRect.height;\n    var layoutRect = getLayoutRect(layoutOption, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }, titleModel.get('padding')); // Adjust text align based on position\n\n    if (!textAlign) {\n      // Align left if title is on the left. center and right is same\n      textAlign = titleModel.get('left') || titleModel.get('right');\n\n      if (textAlign === 'middle') {\n        textAlign = 'center';\n      } // Adjust layout by text align\n\n\n      if (textAlign === 'right') {\n        layoutRect.x += layoutRect.width;\n      } else if (textAlign === 'center') {\n        layoutRect.x += layoutRect.width / 2;\n      }\n    }\n\n    if (!textBaseline) {\n      textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\n      if (textBaseline === 'center') {\n        textBaseline = 'middle';\n      }\n\n      if (textBaseline === 'bottom') {\n        layoutRect.y += layoutRect.height;\n      } else if (textBaseline === 'middle') {\n        layoutRect.y += layoutRect.height / 2;\n      }\n\n      textBaseline = textBaseline || 'top';\n    }\n\n    group.attr('position', [layoutRect.x, layoutRect.y]);\n    var alignStyle = {\n      textAlign: textAlign,\n      textVerticalAlign: textBaseline\n    };\n    textEl.setStyle(alignStyle);\n    subTextEl.setStyle(alignStyle); // Render background\n    // Get groupRect again because textAlign has been changed\n\n    groupRect = group.getBoundingRect();\n    var padding = layoutRect.margin;\n    var style = titleModel.getItemStyle(['color', 'opacity']);\n    style.fill = titleModel.get('backgroundColor');\n    var rect = new graphic.Rect({\n      shape: {\n        x: groupRect.x - padding[3],\n        y: groupRect.y - padding[0],\n        width: groupRect.width + padding[1] + padding[3],\n        height: groupRect.height + padding[0] + padding[2],\n        r: titleModel.get('borderRadius')\n      },\n      style: style,\n      silent: true\n    });\n    graphic.subPixelOptimizeRect(rect);\n    group.add(rect);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUuanM/ZTI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBfbGF5b3V0ID0gcmVxdWlyZShcIi4uL3V0aWwvbGF5b3V0XCIpO1xuXG52YXIgZ2V0TGF5b3V0UmVjdCA9IF9sYXlvdXQuZ2V0TGF5b3V0UmVjdDtcbi8vIE1vZGVsXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcbiAgdHlwZTogJ3RpdGxlJyxcbiAgbGF5b3V0TW9kZToge1xuICAgIHR5cGU6ICdib3gnLFxuICAgIGlnbm9yZVNpemU6IHRydWVcbiAgfSxcbiAgZGVmYXVsdE9wdGlvbjoge1xuICAgIC8vIOS4gOe6p+WxguWPoFxuICAgIHpsZXZlbDogMCxcbiAgICAvLyDkuoznuqflsYLlj6BcbiAgICB6OiA2LFxuICAgIHNob3c6IHRydWUsXG4gICAgdGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gbGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgc3VidGV4dDogJycsXG4gICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgLy8gc3VibGluazogbnVsbCxcbiAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG4gICAgLy8gJ2NlbnRlcicgwqYgJ2xlZnQnIMKmICdyaWdodCdcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIGxlZnQ6IDAsXG4gICAgLy8gJ3RvcCcgwqYgJ2JvdHRvbScgwqYgJ2NlbnRlcidcbiAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgIHRvcDogMCxcbiAgICAvLyDmsLTlubPlr7npvZBcbiAgICAvLyAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcidcbiAgICAvLyDpu5jorqTmoLnmja4gbGVmdCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAvL1xuICAgIC8vIOWeguebtOWvuem9kFxuICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgIC8vIOm7mOiupOagueaNriB0b3Ag5L2N572u5Yik5pat5piv5LiK5a+56b2Q6L+Y5piv5LiL5a+56b2QXG4gICAgLy8gdGV4dEJhc2VsaW5lOiBudWxsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcbiAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICBwYWRkaW5nOiA1LFxuICAgIC8vIOS4u+WJr+agh+mimOe6teWQkemXtOmalO+8jOWNleS9jXB477yM6buY6K6k5Li6MTDvvIxcbiAgICBpdGVtR2FwOiAxMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInLFxuICAgICAgY29sb3I6ICcjMzMzJ1xuICAgIH0sXG4gICAgc3VidGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyNhYWEnXG4gICAgfVxuICB9XG59KTsgLy8gVmlld1xuXG5lY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuICB0eXBlOiAndGl0bGUnLFxuICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcbiAgICB2YXIgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRBbGlnbicpO1xuICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG4gICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGdyYXBoaWMuc2V0VGV4dFN0eWxlKHt9LCB0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0RWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN1YlRleHQgPSB0aXRsZU1vZGVsLmdldCgnc3VidGV4dCcpO1xuICAgIHZhciBzdWJUZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBncmFwaGljLnNldFRleHRTdHlsZSh7fSwgc3VidGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgdGV4dEZpbGw6IHN1YnRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICB5OiB0ZXh0UmVjdC5oZWlnaHQgKyB0aXRsZU1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ3RvcCdcbiAgICAgIH0sIHtcbiAgICAgICAgZGlzYWJsZUJveDogdHJ1ZVxuICAgICAgfSksXG4gICAgICB6MjogMTBcbiAgICB9KTtcbiAgICB2YXIgbGluayA9IHRpdGxlTW9kZWwuZ2V0KCdsaW5rJyk7XG4gICAgdmFyIHN1YmxpbmsgPSB0aXRsZU1vZGVsLmdldCgnc3VibGluaycpO1xuICAgIHRleHRFbC5zaWxlbnQgPSAhbGluaztcbiAgICBzdWJUZXh0RWwuc2lsZW50ID0gIXN1Ymxpbms7XG5cbiAgICBpZiAobGluaykge1xuICAgICAgdGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Lm9wZW4obGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3RhcmdldCcpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWJsaW5rKSB7XG4gICAgICBzdWJUZXh0RWwub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cub3BlbihzdWJsaW5rLCAnXycgKyB0aXRsZU1vZGVsLmdldCgnc3VidGFyZ2V0JykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTsgLy8gSWYgbm8gc3ViVGV4dCwgYnV0IGFkZCBzdWJUZXh0RWwsIHRoZXJlIHdpbGwgYmUgYW4gZW1wdHkgbGluZS5cblxuICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgbGF5b3V0T3B0aW9uID0gdGl0bGVNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKTtcbiAgICBsYXlvdXRPcHRpb24ud2lkdGggPSBncm91cFJlY3Qud2lkdGg7XG4gICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFJlY3QgPSBnZXRMYXlvdXRSZWN0KGxheW91dE9wdGlvbiwge1xuICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICB9LCB0aXRsZU1vZGVsLmdldCgncGFkZGluZycpKTsgLy8gQWRqdXN0IHRleHQgYWxpZ24gYmFzZWQgb24gcG9zaXRpb25cblxuICAgIGlmICghdGV4dEFsaWduKSB7XG4gICAgICAvLyBBbGlnbiBsZWZ0IGlmIHRpdGxlIGlzIG9uIHRoZSBsZWZ0LiBjZW50ZXIgYW5kIHJpZ2h0IGlzIHNhbWVcbiAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG5cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfSAvLyBBZGp1c3QgbGF5b3V0IGJ5IHRleHQgYWxpZ25cblxuXG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxheW91dFJlY3QueCArPSBsYXlvdXRSZWN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHRCYXNlbGluZSkge1xuICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcblxuICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICB0ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ3RvcCc7XG4gICAgfVxuXG4gICAgZ3JvdXAuYXR0cigncG9zaXRpb24nLCBbbGF5b3V0UmVjdC54LCBsYXlvdXRSZWN0LnldKTtcbiAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgIH07XG4gICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTsgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAvLyBHZXQgZ3JvdXBSZWN0IGFnYWluIGJlY2F1c2UgdGV4dEFsaWduIGhhcyBiZWVuIGNoYW5nZWRcblxuICAgIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgIHN0eWxlLmZpbGwgPSB0aXRsZU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHg6IGdyb3VwUmVjdC54IC0gcGFkZGluZ1szXSxcbiAgICAgICAgeTogZ3JvdXBSZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogZ3JvdXBSZWN0LndpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodCArIHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdLFxuICAgICAgICByOiB0aXRsZU1vZGVsLmdldCgnYm9yZGVyUmFkaXVzJylcbiAgICAgIH0sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0KHJlY3QpO1xuICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC90aXRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///334\n");

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

eval("var BoundingRect = __webpack_require__(244);\n\nvar bbox = __webpack_require__(287);\n\nvar vec2 = __webpack_require__(236);\n\nvar polygonContain = __webpack_require__(365);\n\n/**\n * @module echarts/coord/geo/Region\n */\n\n/**\n * @param {string} name\n * @param {Array} geometries\n * @param {Array.<number>} cp\n */\nfunction Region(name, geometries, cp) {\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  this.name = name;\n  /**\n   * @type {Array.<Array>}\n   * @readOnly\n   */\n\n  this.geometries = geometries;\n\n  if (!cp) {\n    var rect = this.getBoundingRect();\n    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  } else {\n    cp = [cp[0], cp[1]];\n  }\n  /**\n   * @type {Array.<number>}\n   */\n\n\n  this.center = cp;\n}\n\nRegion.prototype = {\n  constructor: Region,\n  properties: null,\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * @param {<Array.<number>} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  transformTo: function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n};\nvar _default = Region;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb29yZC9nZW8vUmVnaW9uLmpzP2ZjNjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIGJib3ggPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9iYm94XCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHBvbHlnb25Db250YWluID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvbnRhaW4vcG9seWdvblwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvZ2VvL1JlZ2lvblxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IGdlb21ldHJpZXNcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGNwXG4gKi9cbmZ1bmN0aW9uIFJlZ2lvbihuYW1lLCBnZW9tZXRyaWVzLCBjcCkge1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxBcnJheT59XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXG4gIGlmICghY3ApIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgY3AgPSBbcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMl07XG4gIH0gZWxzZSB7XG4gICAgY3AgPSBbY3BbMF0sIGNwWzFdXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cblxuXG4gIHRoaXMuY2VudGVyID0gY3A7XG59XG5cblJlZ2lvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWdpb24sXG4gIHByb3BlcnRpZXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuXG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHZhciBNQVhfTlVNQkVSID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbWluID0gW01BWF9OVU1CRVIsIE1BWF9OVU1CRVJdO1xuICAgIHZhciBtYXggPSBbLU1BWF9OVU1CRVIsIC1NQVhfTlVNQkVSXTtcbiAgICB2YXIgbWluMiA9IFtdO1xuICAgIHZhciBtYXgyID0gW107XG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgc3VwcG9ydCBwb2x5Z29uXG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS50eXBlICE9PSAncG9seWdvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIERvZXNuJ3QgY29uc2lkZXIgaG9sZVxuXG5cbiAgICAgIHZhciBleHRlcmlvciA9IGdlb21ldHJpZXNbaV0uZXh0ZXJpb3I7XG4gICAgICBiYm94LmZyb21Qb2ludHMoZXh0ZXJpb3IsIG1pbjIsIG1heDIpO1xuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHs8QXJyYXkuPG51bWJlcj59IGNvb3JkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXM7XG5cbiAgICBpZiAoIXJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbG9vcEdlbzogZm9yICh2YXIgaSA9IDAsIGxlbiA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgc3VwcG9ydCBwb2x5Z29uLlxuICAgICAgaWYgKGdlb21ldHJpZXNbaV0udHlwZSAhPT0gJ3BvbHlnb24nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXh0ZXJpb3IgPSBnZW9tZXRyaWVzW2ldLmV4dGVyaW9yO1xuICAgICAgdmFyIGludGVyaW9ycyA9IGdlb21ldHJpZXNbaV0uaW50ZXJpb3JzO1xuXG4gICAgICBpZiAocG9seWdvbkNvbnRhaW4uY29udGFpbihleHRlcmlvciwgY29vcmRbMF0sIGNvb3JkWzFdKSkge1xuICAgICAgICAvLyBOb3QgaW4gdGhlIHJlZ2lvbiBpZiBwb2ludCBpcyBpbiB0aGUgaG9sZS5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAoaW50ZXJpb3JzID8gaW50ZXJpb3JzLmxlbmd0aCA6IDApOyBrKyspIHtcbiAgICAgICAgICBpZiAocG9seWdvbkNvbnRhaW4uY29udGFpbihpbnRlcmlvcnNba10pKSB7XG4gICAgICAgICAgICBjb250aW51ZSBsb29wR2VvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgdHJhbnNmb3JtVG86IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBhc3BlY3QgPSByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQ7XG5cbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKCFoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSByZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybSh0YXJnZXQpO1xuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgcG9seWdvbi5cbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLnR5cGUgIT09ICdwb2x5Z29uJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4dGVyaW9yID0gZ2VvbWV0cmllc1tpXS5leHRlcmlvcjtcbiAgICAgIHZhciBpbnRlcmlvcnMgPSBnZW9tZXRyaWVzW2ldLmludGVyaW9ycztcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBleHRlcmlvci5sZW5ndGg7IHArKykge1xuICAgICAgICB2ZWMyLmFwcGx5VHJhbnNmb3JtKGV4dGVyaW9yW3BdLCBleHRlcmlvcltwXSwgdHJhbnNmb3JtKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCAoaW50ZXJpb3JzID8gaW50ZXJpb3JzLmxlbmd0aCA6IDApOyBoKyspIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBpbnRlcmlvcnNbaF0ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICB2ZWMyLmFwcGx5VHJhbnNmb3JtKGludGVyaW9yc1toXVtwXSwgaW50ZXJpb3JzW2hdW3BdLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgcmVjdC5jb3B5KHRhcmdldCk7IC8vIFVwZGF0ZSBjZW50ZXJcblxuICAgIHRoaXMuY2VudGVyID0gW3JlY3QueCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gUmVnaW9uO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvZ2VvL1JlZ2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///335\n");

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Region = __webpack_require__(335);\n\n/**\n * Parse and decode geo json\n * @module echarts/coord/geo/parseGeoJson\n */\nfunction decode(json) {\n  if (!json.UTF8Encoding) {\n    return json;\n  }\n\n  var encodeScale = json.UTF8Scale;\n\n  if (encodeScale == null) {\n    encodeScale = 1024;\n  }\n\n  var features = json.features;\n\n  for (var f = 0; f < features.length; f++) {\n    var feature = features[f];\n    var geometry = feature.geometry;\n    var coordinates = geometry.coordinates;\n    var encodeOffsets = geometry.encodeOffsets;\n\n    for (var c = 0; c < coordinates.length; c++) {\n      var coordinate = coordinates[c];\n\n      if (geometry.type === 'Polygon') {\n        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (var c2 = 0; c2 < coordinate.length; c2++) {\n          var polygon = coordinate[c2];\n          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);\n        }\n      }\n    }\n  } // Has been decoded\n\n\n  json.UTF8Encoding = false;\n  return json;\n}\n\nfunction decodePolygon(coordinate, encodeOffsets, encodeScale) {\n  var result = [];\n  var prevX = encodeOffsets[0];\n  var prevY = encodeOffsets[1];\n\n  for (var i = 0; i < coordinate.length; i += 2) {\n    var x = coordinate.charCodeAt(i) - 64;\n    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding\n\n    x = x >> 1 ^ -(x & 1);\n    y = y >> 1 ^ -(y & 1); // Delta deocding\n\n    x += prevX;\n    y += prevY;\n    prevX = x;\n    prevY = y; // Dequantize\n\n    result.push([x / encodeScale, y / encodeScale]);\n  }\n\n  return result;\n}\n/**\n * @alias module:echarts/coord/geo/parseGeoJson\n * @param {Object} geoJson\n * @return {module:zrender/container/Group}\n */\n\n\nfunction _default(geoJson) {\n  decode(geoJson);\n  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {\n    // Output of mapshaper may have geometry null\n    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\n  }), function (featureObj) {\n    var properties = featureObj.properties;\n    var geo = featureObj.geometry;\n    var coordinates = geo.coordinates;\n    var geometries = [];\n\n    if (geo.type === 'Polygon') {\n      geometries.push({\n        type: 'polygon',\n        // According to the GeoJSON specification.\n        // First must be exterior, and the rest are all interior(holes).\n        exterior: coordinates[0],\n        interiors: coordinates.slice(1)\n      });\n    }\n\n    if (geo.type === 'MultiPolygon') {\n      zrUtil.each(coordinates, function (item) {\n        if (item[0]) {\n          geometries.push({\n            type: 'polygon',\n            exterior: item[0],\n            interiors: item.slice(1)\n          });\n        }\n      });\n    }\n\n    var region = new Region(properties.name, geometries, properties.cp);\n    region.properties = properties;\n    return region;\n  });\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb29yZC9nZW8vcGFyc2VHZW9Kc29uLmpzP2VkZjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBSZWdpb24gPSByZXF1aXJlKFwiLi9SZWdpb25cIik7XG5cbi8qKlxuICogUGFyc2UgYW5kIGRlY29kZSBnZW8ganNvblxuICogQG1vZHVsZSBlY2hhcnRzL2Nvb3JkL2dlby9wYXJzZUdlb0pzb25cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGpzb24pIHtcbiAgaWYgKCFqc29uLlVURjhFbmNvZGluZykge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgdmFyIGVuY29kZVNjYWxlID0ganNvbi5VVEY4U2NhbGU7XG5cbiAgaWYgKGVuY29kZVNjYWxlID09IG51bGwpIHtcbiAgICBlbmNvZGVTY2FsZSA9IDEwMjQ7XG4gIH1cblxuICB2YXIgZmVhdHVyZXMgPSBqc29uLmZlYXR1cmVzO1xuXG4gIGZvciAodmFyIGYgPSAwOyBmIDwgZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ZdO1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgdmFyIGVuY29kZU9mZnNldHMgPSBnZW9tZXRyeS5lbmNvZGVPZmZzZXRzO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb29yZGluYXRlcy5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tjXTtcblxuICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBjb29yZGluYXRlc1tjXSA9IGRlY29kZVBvbHlnb24oY29vcmRpbmF0ZSwgZW5jb2RlT2Zmc2V0c1tjXSwgZW5jb2RlU2NhbGUpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBmb3IgKHZhciBjMiA9IDA7IGMyIDwgY29vcmRpbmF0ZS5sZW5ndGg7IGMyKyspIHtcbiAgICAgICAgICB2YXIgcG9seWdvbiA9IGNvb3JkaW5hdGVbYzJdO1xuICAgICAgICAgIGNvb3JkaW5hdGVbYzJdID0gZGVjb2RlUG9seWdvbihwb2x5Z29uLCBlbmNvZGVPZmZzZXRzW2NdW2MyXSwgZW5jb2RlU2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEhhcyBiZWVuIGRlY29kZWRcblxuXG4gIGpzb24uVVRGOEVuY29kaW5nID0gZmFsc2U7XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVQb2x5Z29uKGNvb3JkaW5hdGUsIGVuY29kZU9mZnNldHMsIGVuY29kZVNjYWxlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHByZXZYID0gZW5jb2RlT2Zmc2V0c1swXTtcbiAgdmFyIHByZXZZID0gZW5jb2RlT2Zmc2V0c1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGUuY2hhckNvZGVBdChpKSAtIDY0O1xuICAgIHZhciB5ID0gY29vcmRpbmF0ZS5jaGFyQ29kZUF0KGkgKyAxKSAtIDY0OyAvLyBaaWdaYWcgZGVjb2RpbmdcblxuICAgIHggPSB4ID4+IDEgXiAtKHggJiAxKTtcbiAgICB5ID0geSA+PiAxIF4gLSh5ICYgMSk7IC8vIERlbHRhIGRlb2NkaW5nXG5cbiAgICB4ICs9IHByZXZYO1xuICAgIHkgKz0gcHJldlk7XG4gICAgcHJldlggPSB4O1xuICAgIHByZXZZID0geTsgLy8gRGVxdWFudGl6ZVxuXG4gICAgcmVzdWx0LnB1c2goW3ggLyBlbmNvZGVTY2FsZSwgeSAvIGVuY29kZVNjYWxlXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvZ2VvL3BhcnNlR2VvSnNvblxuICogQHBhcmFtIHtPYmplY3R9IGdlb0pzb25cbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGdlb0pzb24pIHtcbiAgZGVjb2RlKGdlb0pzb24pO1xuICByZXR1cm4genJVdGlsLm1hcCh6clV0aWwuZmlsdGVyKGdlb0pzb24uZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlT2JqKSB7XG4gICAgLy8gT3V0cHV0IG9mIG1hcHNoYXBlciBtYXkgaGF2ZSBnZW9tZXRyeSBudWxsXG4gICAgcmV0dXJuIGZlYXR1cmVPYmouZ2VvbWV0cnkgJiYgZmVhdHVyZU9iai5wcm9wZXJ0aWVzICYmIGZlYXR1cmVPYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID4gMDtcbiAgfSksIGZ1bmN0aW9uIChmZWF0dXJlT2JqKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBmZWF0dXJlT2JqLnByb3BlcnRpZXM7XG4gICAgdmFyIGdlbyA9IGZlYXR1cmVPYmouZ2VvbWV0cnk7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvLmNvb3JkaW5hdGVzO1xuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG5cbiAgICBpZiAoZ2VvLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgZ2VvbWV0cmllcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIEdlb0pTT04gc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgLy8gRmlyc3QgbXVzdCBiZSBleHRlcmlvciwgYW5kIHRoZSByZXN0IGFyZSBhbGwgaW50ZXJpb3IoaG9sZXMpLlxuICAgICAgICBleHRlcmlvcjogY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIGludGVyaW9yczogY29vcmRpbmF0ZXMuc2xpY2UoMSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZW8udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGNvb3JkaW5hdGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbVswXSkge1xuICAgICAgICAgIGdlb21ldHJpZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgICAgICBleHRlcmlvcjogaXRlbVswXSxcbiAgICAgICAgICAgIGludGVyaW9yczogaXRlbS5zbGljZSgxKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVnaW9uID0gbmV3IFJlZ2lvbihwcm9wZXJ0aWVzLm5hbWUsIGdlb21ldHJpZXMsIHByb3BlcnRpZXMuY3ApO1xuICAgIHJlZ2lvbi5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICByZXR1cm4gcmVnaW9uO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY29vcmQvZ2VvL3BhcnNlR2VvSnNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///336\n");

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrender = __webpack_require__(297);\n\nexports.zrender = zrender;\n\nvar matrix = __webpack_require__(253);\n\nexports.matrix = matrix;\n\nvar vector = __webpack_require__(236);\n\nexports.vector = vector;\n\nvar zrUtil = __webpack_require__(230);\n\nvar colorTool = __webpack_require__(256);\n\nexports.color = colorTool;\n\nvar graphic = __webpack_require__(233);\n\nexports.graphic = graphic;\n\nvar numberUtil = __webpack_require__(235);\n\nexports.number = numberUtil;\n\nvar formatUtil = __webpack_require__(245);\n\nexports.format = formatUtil;\n\nvar _throttle = __webpack_require__(273);\n\nvar throttle = _throttle.throttle;\nexports.throttle = _throttle.throttle;\n\nvar ecHelper = __webpack_require__(338);\n\nexports.helper = ecHelper;\n\nvar _List = __webpack_require__(263);\n\nexports.List = _List;\n\nvar _Model = __webpack_require__(246);\n\nexports.Model = _Model;\n\nvar _Axis = __webpack_require__(300);\n\nexports.Axis = _Axis;\n\nvar _env = __webpack_require__(239);\n\nexports.env = _env;\n\nvar _parseGeoJson = __webpack_require__(336);\n\nexports.parseGeoJson = _parseGeoJson;\n\n/**\n * Do not mount those modules on 'src/echarts' for better tree shaking.\n */\nvar ecUtil = {};\nzrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {\n  ecUtil[name] = zrUtil[name];\n});\nexports.util = ecUtil;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9leHBvcnQuanM/MWYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJlbmRlciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi96cmVuZGVyXCIpO1xuXG5leHBvcnRzLnpyZW5kZXIgPSB6cmVuZGVyO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvbWF0cml4XCIpO1xuXG5leHBvcnRzLm1hdHJpeCA9IG1hdHJpeDtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvclwiKTtcblxuZXhwb3J0cy52ZWN0b3IgPSB2ZWN0b3I7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcInpyZW5kZXIvbGliL3Rvb2wvY29sb3JcIik7XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvclRvb2w7XG5cbnZhciBncmFwaGljID0gcmVxdWlyZShcIi4vdXRpbC9ncmFwaGljXCIpO1xuXG5leHBvcnRzLmdyYXBoaWMgPSBncmFwaGljO1xuXG52YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbnVtYmVyXCIpO1xuXG5leHBvcnRzLm51bWJlciA9IG51bWJlclV0aWw7XG5cbnZhciBmb3JtYXRVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9mb3JtYXRcIik7XG5cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0VXRpbDtcblxudmFyIF90aHJvdHRsZSA9IHJlcXVpcmUoXCIuL3V0aWwvdGhyb3R0bGVcIik7XG5cbnZhciB0aHJvdHRsZSA9IF90aHJvdHRsZS50aHJvdHRsZTtcbmV4cG9ydHMudGhyb3R0bGUgPSBfdGhyb3R0bGUudGhyb3R0bGU7XG5cbnZhciBlY0hlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcblxuZXhwb3J0cy5oZWxwZXIgPSBlY0hlbHBlcjtcblxudmFyIF9MaXN0ID0gcmVxdWlyZShcIi4vZGF0YS9MaXN0XCIpO1xuXG5leHBvcnRzLkxpc3QgPSBfTGlzdDtcblxudmFyIF9Nb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL01vZGVsXCIpO1xuXG5leHBvcnRzLk1vZGVsID0gX01vZGVsO1xuXG52YXIgX0F4aXMgPSByZXF1aXJlKFwiLi9jb29yZC9BeGlzXCIpO1xuXG5leHBvcnRzLkF4aXMgPSBfQXhpcztcblxudmFyIF9lbnYgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS9lbnZcIik7XG5cbmV4cG9ydHMuZW52ID0gX2VudjtcblxudmFyIF9wYXJzZUdlb0pzb24gPSByZXF1aXJlKFwiLi9jb29yZC9nZW8vcGFyc2VHZW9Kc29uXCIpO1xuXG5leHBvcnRzLnBhcnNlR2VvSnNvbiA9IF9wYXJzZUdlb0pzb247XG5cbi8qKlxuICogRG8gbm90IG1vdW50IHRob3NlIG1vZHVsZXMgb24gJ3NyYy9lY2hhcnRzJyBmb3IgYmV0dGVyIHRyZWUgc2hha2luZy5cbiAqL1xudmFyIGVjVXRpbCA9IHt9O1xuenJVdGlsLmVhY2goWydtYXAnLCAnZWFjaCcsICdmaWx0ZXInLCAnaW5kZXhPZicsICdpbmhlcml0cycsICdyZWR1Y2UnLCAnZmlsdGVyJywgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCcsICdkZWZhdWx0cycsICdjbG9uZScsICdtZXJnZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBlY1V0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XG59KTtcbmV4cG9ydHMudXRpbCA9IGVjVXRpbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///337\n");

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar createListFromArray = __webpack_require__(274);\n\nvar axisHelper = __webpack_require__(254);\n\nvar axisModelCommonMixin = __webpack_require__(301);\n\nvar Model = __webpack_require__(246);\n\nvar _completeDimensions = __webpack_require__(272);\n\nexports.completeDimensions = _completeDimensions;\n\nvar _symbol = __webpack_require__(266);\n\nexports.createSymbol = _symbol.createSymbol;\n\n/**\n * Create a muti dimension List structure from seriesModel.\n * @param  {module:echarts/model/Model} seriesModel\n * @return {module:echarts/data/List} list\n */\nfunction createList(seriesModel) {\n  var data = seriesModel.get('data');\n  return createListFromArray(data, seriesModel, seriesModel.ecModel);\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n */\n\n\n/**\n * Create scale\n * @param {Array.<number>} dataExtent\n * @param {Object|module:echarts/Model} option\n */\nfunction createScale(dataExtent, option) {\n  var axisModel = option;\n\n  if (!(option instanceof Model)) {\n    axisModel = new Model(option);\n    zrUtil.mixin(axisModel, axisModelCommonMixin);\n  }\n\n  var scale = axisHelper.createScaleByModel(axisModel);\n  scale.setExtent(dataExtent[0], dataExtent[1]);\n  axisHelper.niceScaleExtent(scale, axisModel);\n  return scale;\n}\n/**\n * Mixin common methods to axis model,\n *\n * Inlcude methods\n * `getFormattedLabels() => Array.<string>`\n * `getCategories() => Array.<string>`\n * `getMin(origin: boolean) => number`\n * `getMax(origin: boolean) => number`\n * `getNeedCrossZero() => boolean`\n * `setRange(start: number, end: number)`\n * `resetRange()`\n */\n\n\nfunction mixinAxisModelCommonMethods(Model) {\n  zrUtil.mixin(Model, axisModelCommonMixin);\n}\n\nexports.createList = createList;\nexports.createScale = createScale;\nexports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9oZWxwZXIuanM/NTc5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKFwiLi9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheVwiKTtcblxudmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKFwiLi9jb29yZC9heGlzSGVscGVyXCIpO1xuXG52YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKFwiLi9jb29yZC9heGlzTW9kZWxDb21tb25NaXhpblwiKTtcblxudmFyIE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvTW9kZWxcIik7XG5cbnZhciBfY29tcGxldGVEaW1lbnNpb25zID0gcmVxdWlyZShcIi4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zXCIpO1xuXG5leHBvcnRzLmNvbXBsZXRlRGltZW5zaW9ucyA9IF9jb21wbGV0ZURpbWVuc2lvbnM7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4vdXRpbC9zeW1ib2xcIik7XG5cbmV4cG9ydHMuY3JlYXRlU3ltYm9sID0gX3N5bWJvbC5jcmVhdGVTeW1ib2w7XG5cbi8qKlxuICogQ3JlYXRlIGEgbXV0aSBkaW1lbnNpb24gTGlzdCBzdHJ1Y3R1cmUgZnJvbSBzZXJpZXNNb2RlbC5cbiAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBzZXJpZXNNb2RlbFxuICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBsaXN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpc3Qoc2VyaWVzTW9kZWwpIHtcbiAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIHNlcmllc01vZGVsLmVjTW9kZWwpO1xufVxuLyoqXG4gKiBAc2VlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnN9XG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBzY2FsZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICogQHBhcmFtIHtPYmplY3R8bW9kdWxlOmVjaGFydHMvTW9kZWx9IG9wdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsZShkYXRhRXh0ZW50LCBvcHRpb24pIHtcbiAgdmFyIGF4aXNNb2RlbCA9IG9wdGlvbjtcblxuICBpZiAoIShvcHRpb24gaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBheGlzTW9kZWwgPSBuZXcgTW9kZWwob3B0aW9uKTtcbiAgICB6clV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gIH1cblxuICB2YXIgc2NhbGUgPSBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpO1xuICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG4gIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICByZXR1cm4gc2NhbGU7XG59XG4vKipcbiAqIE1peGluIGNvbW1vbiBtZXRob2RzIHRvIGF4aXMgbW9kZWwsXG4gKlxuICogSW5sY3VkZSBtZXRob2RzXG4gKiBgZ2V0Rm9ybWF0dGVkTGFiZWxzKCkgPT4gQXJyYXkuPHN0cmluZz5gXG4gKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICogYGdldE1pbihvcmlnaW46IGJvb2xlYW4pID0+IG51bWJlcmBcbiAqIGBnZXRNYXgob3JpZ2luOiBib29sZWFuKSA9PiBudW1iZXJgXG4gKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gKiBgc2V0UmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpYFxuICogYHJlc2V0UmFuZ2UoKWBcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluQXhpc01vZGVsQ29tbW9uTWV0aG9kcyhNb2RlbCkge1xuICB6clV0aWwubWl4aW4oTW9kZWwsIGF4aXNNb2RlbENvbW1vbk1peGluKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVMaXN0ID0gY3JlYXRlTGlzdDtcbmV4cG9ydHMuY3JlYXRlU2NhbGUgPSBjcmVhdGVTY2FsZTtcbmV4cG9ydHMubWl4aW5BeGlzTW9kZWxDb21tb25NZXRob2RzID0gbWl4aW5BeGlzTW9kZWxDb21tb25NZXRob2RzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///338\n");

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar graphic = __webpack_require__(233);\n\nvar PI = Math.PI;\n/**\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} [opts]\n * @param {string} [opts.text]\n * @param {string} [opts.color]\n * @param {string} [opts.textColor]\n * @return {module:zrender/Element}\n */\n\nfunction _default(api, opts) {\n  opts = opts || {};\n  zrUtil.defaults(opts, {\n    text: 'loading',\n    color: '#c23531',\n    textColor: '#000',\n    maskColor: 'rgba(255, 255, 255, 0.8)',\n    zlevel: 0\n  });\n  var mask = new graphic.Rect({\n    style: {\n      fill: opts.maskColor\n    },\n    zlevel: opts.zlevel,\n    z: 10000\n  });\n  var arc = new graphic.Arc({\n    shape: {\n      startAngle: -PI / 2,\n      endAngle: -PI / 2 + 0.1,\n      r: 10\n    },\n    style: {\n      stroke: opts.color,\n      lineCap: 'round',\n      lineWidth: 5\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  var labelRect = new graphic.Rect({\n    style: {\n      fill: 'none',\n      text: opts.text,\n      textPosition: 'right',\n      textDistance: 10,\n      textFill: opts.textColor\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  arc.animateShape(true).when(1000, {\n    endAngle: PI * 3 / 2\n  }).start('circularInOut');\n  arc.animateShape(true).when(1000, {\n    startAngle: PI * 3 / 2\n  }).delay(300).start('circularInOut');\n  var group = new graphic.Group();\n  group.add(arc);\n  group.add(labelRect);\n  group.add(mask); // Inject resize\n\n  group.resize = function () {\n    var cx = api.getWidth() / 2;\n    var cy = api.getHeight() / 2;\n    arc.setShape({\n      cx: cx,\n      cy: cy\n    });\n    var r = arc.shape.r;\n    labelRect.setShape({\n      x: cx - r,\n      y: cy - r,\n      width: r * 2,\n      height: r * 2\n    });\n    mask.setShape({\n      x: 0,\n      y: 0,\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  };\n\n  group.resize();\n  return group;\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9sb2FkaW5nL2RlZmF1bHQuanM/OGE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudGV4dF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb2xvcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0Q29sb3JdXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KGFwaSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgenJVdGlsLmRlZmF1bHRzKG9wdHMsIHtcbiAgICB0ZXh0OiAnbG9hZGluZycsXG4gICAgY29sb3I6ICcjYzIzNTMxJyxcbiAgICB0ZXh0Q29sb3I6ICcjMDAwJyxcbiAgICBtYXNrQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCknLFxuICAgIHpsZXZlbDogMFxuICB9KTtcbiAgdmFyIG1hc2sgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzdHlsZToge1xuICAgICAgZmlsbDogb3B0cy5tYXNrQ29sb3JcbiAgICB9LFxuICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgejogMTAwMDBcbiAgfSk7XG4gIHZhciBhcmMgPSBuZXcgZ3JhcGhpYy5BcmMoe1xuICAgIHNoYXBlOiB7XG4gICAgICBzdGFydEFuZ2xlOiAtUEkgLyAyLFxuICAgICAgZW5kQW5nbGU6IC1QSSAvIDIgKyAwLjEsXG4gICAgICByOiAxMFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHN0cm9rZTogb3B0cy5jb2xvcixcbiAgICAgIGxpbmVDYXA6ICdyb3VuZCcsXG4gICAgICBsaW5lV2lkdGg6IDVcbiAgICB9LFxuICAgIHpsZXZlbDogb3B0cy56bGV2ZWwsXG4gICAgejogMTAwMDFcbiAgfSk7XG4gIHZhciBsYWJlbFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICBzdHlsZToge1xuICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgdGV4dDogb3B0cy50ZXh0LFxuICAgICAgdGV4dFBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgdGV4dERpc3RhbmNlOiAxMCxcbiAgICAgIHRleHRGaWxsOiBvcHRzLnRleHRDb2xvclxuICAgIH0sXG4gICAgemxldmVsOiBvcHRzLnpsZXZlbCxcbiAgICB6OiAxMDAwMVxuICB9KTtcbiAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKS53aGVuKDEwMDAsIHtcbiAgICBlbmRBbmdsZTogUEkgKiAzIC8gMlxuICB9KS5zdGFydCgnY2lyY3VsYXJJbk91dCcpO1xuICBhcmMuYW5pbWF0ZVNoYXBlKHRydWUpLndoZW4oMTAwMCwge1xuICAgIHN0YXJ0QW5nbGU6IFBJICogMyAvIDJcbiAgfSkuZGVsYXkoMzAwKS5zdGFydCgnY2lyY3VsYXJJbk91dCcpO1xuICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICBncm91cC5hZGQoYXJjKTtcbiAgZ3JvdXAuYWRkKGxhYmVsUmVjdCk7XG4gIGdyb3VwLmFkZChtYXNrKTsgLy8gSW5qZWN0IHJlc2l6ZVxuXG4gIGdyb3VwLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3ggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7XG4gICAgdmFyIGN5ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcbiAgICBhcmMuc2V0U2hhcGUoe1xuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5XG4gICAgfSk7XG4gICAgdmFyIHIgPSBhcmMuc2hhcGUucjtcbiAgICBsYWJlbFJlY3Quc2V0U2hhcGUoe1xuICAgICAgeDogY3ggLSByLFxuICAgICAgeTogY3kgLSByLFxuICAgICAgd2lkdGg6IHIgKiAyLFxuICAgICAgaGVpZ2h0OiByICogMlxuICAgIH0pO1xuICAgIG1hc2suc2V0U2hhcGUoe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0pO1xuICB9O1xuXG4gIGdyb3VwLnJlc2l6ZSgpO1xuICByZXR1cm4gZ3JvdXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2xvYWRpbmcvZGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///339\n");

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(237);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(230);\n\nvar modelUtil = __webpack_require__(234);\n\nvar Model = __webpack_require__(246);\n\nvar ComponentModel = __webpack_require__(248);\n\nvar globalDefault = __webpack_require__(342);\n\nvar colorPaletteMinin = __webpack_require__(278);\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar each = zrUtil.each;\nvar filter = zrUtil.filter;\nvar map = zrUtil.map;\nvar isArray = zrUtil.isArray;\nvar indexOf = zrUtil.indexOf;\nvar isObject = zrUtil.isObject;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  constructor: GlobalModel,\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n      } else {\n        newCptTypes.push(mainType);\n      }\n    }); // FIXME OPTION 同步是否要改回原来的\n\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    this._seriesIndices = this._seriesIndices || [];\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel instanceof ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = zrUtil.extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            zrUtil.extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n      }\n    }\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = zrUtil.clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series'},\n   *     function (model, index) {...}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (zrUtil.isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    this._seriesIndices = createSeriesIndices(filteredSeries);\n  },\n  restoreData: function () {\n    var componentsMap = this._componentsMap;\n    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        component.restoreData();\n      });\n    });\n  }\n});\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  zrUtil.each(theme, function (themeItem, name) {\n    // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = zrUtil.createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices = null;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  zrUtil.merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!zrUtil.isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(seriesModels) {\n  return map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || [];\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nzrUtil.mixin(GlobalModel, colorPaletteMinin);\nvar _default = GlobalModel;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9HbG9iYWwuanM/YjlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBfX0RFVl9fID0gX2NvbmZpZy5fX0RFVl9fO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21vZGVsXCIpO1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKFwiLi9Nb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG52YXIgZ2xvYmFsRGVmYXVsdCA9IHJlcXVpcmUoXCIuL2dsb2JhbERlZmF1bHRcIik7XG5cbnZhciBjb2xvclBhbGV0dGVNaW5pbiA9IHJlcXVpcmUoXCIuL21peGluL2NvbG9yUGFsZXR0ZVwiKTtcblxuLyoqXG4gKiBFQ2hhcnRzIGdsb2JhbCBtb2RlbFxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvR2xvYmFsfVxuICovXG5cbi8qKlxuICogQ2F1dGlvbjogSWYgdGhlIG1lY2hhbmlzbSBzaG91bGQgYmUgY2hhbmdlZCBzb21lIGRheSwgdGhlc2UgY2FzZXNcbiAqIHNob3VsZCBiZSBjb25zaWRlcmVkOlxuICpcbiAqICgxKSBJbiBgbWVyZ2Ugb3B0aW9uYCBtb2RlLCBpZiB1c2luZyB0aGUgc2FtZSBvcHRpb24gdG8gY2FsbCBgc2V0T3B0aW9uYFxuICogbWFueSB0aW1lcywgdGhlIHJlc3VsdCBzaG91bGQgYmUgdGhlIHNhbWUgKHRyeSBvdXIgYmVzdCB0byBlbnN1cmUgdGhhdCkuXG4gKiAoMikgSW4gYG1lcmdlIG9wdGlvbmAgbW9kZSwgaWYgYSBjb21wb25lbnQgaGFzIG5vIGlkL25hbWUgc3BlY2lmaWVkLCBpdFxuICogd2lsbCBiZSBtZXJnZWQgYnkgaW5kZXgsIGFuZCB0aGUgcmVzdWx0IHNlcXVlbmNlIG9mIHRoZSBjb21wb25lbnRzIGlzXG4gKiBjb25zaXN0ZW50IHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAqICgzKSBgcmVzZXRgIGZlYXR1cmUgKGluIHRvb2xib3gpLiBGaW5kIGRldGFpbGVkIGluZm8gaW4gY29tbWVudHMgYWJvdXRcbiAqIGBtZXJnZU9wdGlvbmAgaW4gbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlci5cbiAqL1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBmaWx0ZXIgPSB6clV0aWwuZmlsdGVyO1xudmFyIG1hcCA9IHpyVXRpbC5tYXA7XG52YXIgaXNBcnJheSA9IHpyVXRpbC5pc0FycmF5O1xudmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBPUFRJT05fSU5ORVJfS0VZID0gJ1xcMF9lY19pbm5lcic7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBwYXJlbnRNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IHRoZW1lXG4gKi9cblxudmFyIEdsb2JhbE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcbiAgY29uc3RydWN0b3I6IEdsb2JhbE1vZGVsLFxuICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpIHtcbiAgICB0aGVtZSA9IHRoZW1lIHx8IHt9O1xuICAgIHRoaXMub3B0aW9uID0gbnVsbDsgLy8gTWFyayBhcyBub3QgaW5pdGlhbGl6ZWQuXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX3RoZW1lID0gbmV3IE1vZGVsKHRoZW1lKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuX29wdGlvbk1hbmFnZXIgPSBvcHRpb25NYW5hZ2VyO1xuICB9LFxuICBzZXRPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgenJVdGlsLmFzc2VydCghKE9QVElPTl9JTk5FUl9LRVkgaW4gb3B0aW9uKSwgJ3BsZWFzZSB1c2UgY2hhcnQuZ2V0T3B0aW9uKCknKTtcblxuICAgIHRoaXMuX29wdGlvbk1hbmFnZXIuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgdGhpcy5yZXNldE9wdGlvbihudWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgbnVsbC91bmRlZmluZWQ6IHJlc2V0IGFsbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgJ3JlY3JlYXRlJzogZm9yY2UgcmVjcmVhdGUgYWxsLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAndGltZWxpbmUnOiBvbmx5IHJlc2V0IHRpbWVsaW5lIG9wdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAnbWVkaWEnOiBvbmx5IHJlc2V0IG1lZGlhIHF1ZXJ5IG9wdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9wdGlvbiBjaGFuZ2VkLlxuICAgKi9cbiAgcmVzZXRPcHRpb246IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIG9wdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgb3B0aW9uTWFuYWdlciA9IHRoaXMuX29wdGlvbk1hbmFnZXI7XG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJykge1xuICAgICAgdmFyIGJhc2VPcHRpb24gPSBvcHRpb25NYW5hZ2VyLm1vdW50T3B0aW9uKHR5cGUgPT09ICdyZWNyZWF0ZScpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9uIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgaW5pdEJhc2UuY2FsbCh0aGlzLCBiYXNlT3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihiYXNlT3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd0aW1lbGluZScgfHwgdHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgdGhpcy5yZXN0b3JlRGF0YSgpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICd0aW1lbGluZScpIHtcbiAgICAgIHZhciB0aW1lbGluZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIuZ2V0VGltZWxpbmVPcHRpb24odGhpcyk7XG4gICAgICB0aW1lbGluZU9wdGlvbiAmJiAodGhpcy5tZXJnZU9wdGlvbih0aW1lbGluZU9wdGlvbiksIG9wdGlvbkNoYW5nZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICB2YXIgbWVkaWFPcHRpb25zID0gb3B0aW9uTWFuYWdlci5nZXRNZWRpYU9wdGlvbih0aGlzLCB0aGlzLl9hcGkpO1xuXG4gICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihtZWRpYU9wdGlvbiwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uQ2hhbmdlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHZhciBuZXdDcHRUeXBlcyA9IFtdOyAvLyDlpoLmnpzkuI3lrZjlnKjlr7nlupTnmoQgY29tcG9uZW50IG1vZGVsIOWImeebtOaOpSBtZXJnZVxuXG4gICAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChjb21wb25lbnRPcHRpb24sIG1haW5UeXBlKSB7XG4gICAgICBpZiAoY29tcG9uZW50T3B0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0aW9uW21haW5UeXBlXSA9PSBudWxsID8genJVdGlsLmNsb25lKGNvbXBvbmVudE9wdGlvbikgOiB6clV0aWwubWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NwdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBGSVhNRSBPUFRJT04g5ZCM5q2l5piv5ZCm6KaB5pS55Zue5Y6f5p2l55qEXG5cbiAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChuZXdDcHRUeXBlcywgQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMoKSwgdmlzaXRDb21wb25lbnQsIHRoaXMpO1xuICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSB0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXRDb21wb25lbnQobWFpblR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgdmFyIG5ld0NwdE9wdGlvbkxpc3QgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdPcHRpb25bbWFpblR5cGVdKTtcbiAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKSwgbmV3Q3B0T3B0aW9uTGlzdCk7XG4gICAgICBtb2RlbFV0aWwubWFrZUlkQW5kTmFtZShtYXBSZXN1bHQpOyAvLyBTZXQgbWFpblR5cGUgYW5kIGNvbXBsZXRlIHN1YlR5cGUuXG5cbiAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuXG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgaXRlbS5rZXlJbmZvLm1haW5UeXBlID0gbWFpblR5cGU7XG4gICAgICAgICAgaXRlbS5rZXlJbmZvLnN1YlR5cGUgPSBkZXRlcm1pbmVTdWJUeXBlKG1haW5UeXBlLCBvcHQsIGl0ZW0uZXhpc3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgb3B0aW9uW21haW5UeXBlXSA9IFtdO1xuICAgICAgY29tcG9uZW50c01hcC5zZXQobWFpblR5cGUsIFtdKTtcbiAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gcmVzdWx0SXRlbS5leGlzdDtcbiAgICAgICAgdmFyIG5ld0NwdE9wdGlvbiA9IHJlc3VsdEl0ZW0ub3B0aW9uO1xuICAgICAgICB6clV0aWwuYXNzZXJ0KGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsICdFbXB0eSBjb21wb25lbnQgZGVmaW5pdGlvbicpOyAvLyBDb25zaWRlciB3aGVyZSBpcyBubyBuZXcgb3B0aW9uIGFuZCBzaG91bGQgYmUgbWVyZ2VkIHVzaW5nIHt9LFxuICAgICAgICAvLyBzZWUgcmVtb3ZlRWRnZUFuZEFkZCBpbiB0b3BvbG9naWNhbFRyYXZlbCBhbmRcbiAgICAgICAgLy8gQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMuXG5cbiAgICAgICAgaWYgKCFuZXdDcHRPcHRpb24pIHtcbiAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbih7fSwgdGhpcyk7XG4gICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBDb21wb25lbnRNb2RlbENsYXNzID0gQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3MobWFpblR5cGUsIHJlc3VsdEl0ZW0ua2V5SW5mby5zdWJUeXBlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm5hbWUgPSByZXN1bHRJdGVtLmtleUluZm8ubmFtZTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm1lcmdlT3B0aW9uKG5ld0NwdE9wdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG5ld0NwdE9wdGlvbiwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQRU5ESU5HIEdsb2JhbCBhcyBwYXJlbnQgP1xuICAgICAgICAgICAgdmFyIGV4dHJhT3B0ID0genJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgIGRlcGVuZGVudE1vZGVsczogZGVwZW5kZW50TW9kZWxzLFxuICAgICAgICAgICAgICBjb21wb25lbnRJbmRleDogaW5kZXhcbiAgICAgICAgICAgIH0sIHJlc3VsdEl0ZW0ua2V5SW5mbyk7XG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbCA9IG5ldyBDb21wb25lbnRNb2RlbENsYXNzKG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHQpO1xuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChjb21wb25lbnRNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTsgLy8gQ2FsbCBvcHRpb25VcGRhdGVkIGFmdGVyIGluaXQuXG4gICAgICAgICAgICAvLyBuZXdDcHRPcHRpb24gaGFzIGJlZW4gdXNlZCBhcyBjb21wb25lbnRNb2RlbC5vcHRpb25cbiAgICAgICAgICAgIC8vIGFuZCBtYXkgYmUgbWVyZ2VkIHdpdGggdGhlbWUgYW5kIGRlZmF1bHQsIHNvIHBhc3MgbnVsbFxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgY29uZnVzaW9uLlxuXG4gICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKVtpbmRleF0gPSBjb21wb25lbnRNb2RlbDtcbiAgICAgICAgb3B0aW9uW21haW5UeXBlXVtpbmRleF0gPSBjb21wb25lbnRNb2RlbC5vcHRpb247XG4gICAgICB9LCB0aGlzKTsgLy8gQmFja3VwIHNlcmllcyBmb3IgZmlsdGVyaW5nLlxuXG4gICAgICBpZiAobWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgb3B0aW9uIGZvciBvdXRwdXQgKGNsb25lZCBvcHRpb24gYW5kIGlubmVyIGluZm8gcmVtb3ZlZClcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9uID0genJVdGlsLmNsb25lKHRoaXMub3B0aW9uKTtcbiAgICBlYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG9wdHMsIG1haW5UeXBlKSB7XG4gICAgICBpZiAoQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgIHZhciBvcHRzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IG9wdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAvLyBSZW1vdmUgb3B0aW9ucyB3aXRoIGlubmVyIGlkLlxuICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNJZElubmVyKG9wdHNbaV0pKSB7XG4gICAgICAgICAgICBvcHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWxldGUgb3B0aW9uW09QVElPTl9JTk5FUl9LRVldO1xuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgKi9cbiAgZ2V0VGhlbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2lkeD0wXVxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9XG4gICAqL1xuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgaWR4KSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4IHx8IDBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgbm9uZSBvZiBpbmRleCBhbmQgaWQgYW5kIG5hbWUgdXNlZCwgcmV0dXJuIGFsbCBjb21wb25lbnRzIHdpdGggbWFpblR5cGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBJZiBpZ25vcmUsIG9ubHkgcXVlcnkgYnkgbWFpblR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtjb25kaXRpb24uaW5kZXhdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5pZF0gRWl0aGVyIGlucHV0IGluZGV4IG9yIGlkIG9yIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbY29uZGl0aW9uLm5hbWVdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICovXG4gIHF1ZXJ5Q29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcblxuICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBjb25kaXRpb24uaW5kZXg7XG4gICAgdmFyIGlkID0gY29uZGl0aW9uLmlkO1xuICAgIHZhciBuYW1lID0gY29uZGl0aW9uLm5hbWU7XG5cbiAgICB2YXIgY3B0cyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KG1haW5UeXBlKTtcblxuICAgIGlmICghY3B0cyB8fCAhY3B0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIGlmICghaXNBcnJheShpbmRleCkpIHtcbiAgICAgICAgaW5kZXggPSBbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBmaWx0ZXIobWFwKGluZGV4LCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiBjcHRzW2lkeF07XG4gICAgICB9KSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gISF2YWw7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHZhciBpc0lkQXJyYXkgPSBpc0FycmF5KGlkKTtcbiAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgIHJldHVybiBpc0lkQXJyYXkgJiYgaW5kZXhPZihpZCwgY3B0LmlkKSA+PSAwIHx8ICFpc0lkQXJyYXkgJiYgY3B0LmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICB2YXIgaXNOYW1lQXJyYXkgPSBpc0FycmF5KG5hbWUpO1xuICAgICAgcmVzdWx0ID0gZmlsdGVyKGNwdHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFtZUFycmF5ICYmIGluZGV4T2YobmFtZSwgY3B0Lm5hbWUpID49IDAgfHwgIWlzTmFtZUFycmF5ICYmIGNwdC5uYW1lID09PSBuYW1lO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlXG4gICAgICByZXN1bHQgPSBjcHRzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcmZhY2UgaXMgZGlmZmVyZW50IGZyb20gcXVlcnlDb21wb25lbnRzLFxuICAgKiB3aGljaCBpcyBjb252ZW5pZW50IGZvciBpbm5lciB1c2FnZS5cbiAgICpcbiAgICogQHVzYWdlXG4gICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319XG4gICAqICk7XG4gICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX1cbiAgICogKTtcbiAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJ30sXG4gICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgKiApO1xuICAgKiAvLyByZXN1bHQgbGlrZSBbY29tcG9uZW50MCwgY29tcG9ubmV0MSwgLi4uXVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGUgTWFuZGF0b3J5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBPcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb24ucXVlcnldIGxpa2Uge3h4eEluZGV4LCB4eHhJZCwgeHh4TmFtZX0sXG4gICAqICAgICAgICB3aGVyZSB4eHggaXMgbWFpblR5cGUuXG4gICAqICAgICAgICBJZiBxdWVyeSBhdHRyaWJ1dGUgaXMgbnVsbC91bmRlZmluZWQgb3IgaGFzIG5vIGluZGV4L2lkL25hbWUsXG4gICAqICAgICAgICBkbyBub3QgZmlsdGVyaW5nIGJ5IHF1ZXJ5IGNvbmRpdGlvbnMsIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yXG4gICAqICAgICAgICBuby1wYXlsb2FkIHNpdHVhdGlvbnMgb3Igd2hlbiB0YXJnZXQgb2YgYWN0aW9uIGlzIGdsb2JhbC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmRpdGlvbi5maWx0ZXJdIHBhcmFtZXRlcjogY29tcG9uZW50LCByZXR1cm4gYm9vbGVhbi5cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAqL1xuICBmaW5kQ29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgIHZhciBxdWVyeSA9IGNvbmRpdGlvbi5xdWVyeTtcbiAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG4gICAgdmFyIHF1ZXJ5Q29uZCA9IGdldFF1ZXJ5Q29uZChxdWVyeSk7XG4gICAgdmFyIHJlc3VsdCA9IHF1ZXJ5Q29uZCA/IHRoaXMucXVlcnlDb21wb25lbnRzKHF1ZXJ5Q29uZCkgOiB0aGlzLl9jb21wb25lbnRzTWFwLmdldChtYWluVHlwZSk7XG4gICAgcmV0dXJuIGRvRmlsdGVyKGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbikpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UXVlcnlDb25kKHEpIHtcbiAgICAgIHZhciBpbmRleEF0dHIgPSBtYWluVHlwZSArICdJbmRleCc7XG4gICAgICB2YXIgaWRBdHRyID0gbWFpblR5cGUgKyAnSWQnO1xuICAgICAgdmFyIG5hbWVBdHRyID0gbWFpblR5cGUgKyAnTmFtZSc7XG4gICAgICByZXR1cm4gcSAmJiAocVtpbmRleEF0dHJdICE9IG51bGwgfHwgcVtpZEF0dHJdICE9IG51bGwgfHwgcVtuYW1lQXR0cl0gIT0gbnVsbCkgPyB7XG4gICAgICAgIG1haW5UeXBlOiBtYWluVHlwZSxcbiAgICAgICAgLy8gc3ViVHlwZSB3aWxsIGJlIGZpbHRlcmVkIGZpbmFsbHkuXG4gICAgICAgIGluZGV4OiBxW2luZGV4QXR0cl0sXG4gICAgICAgIGlkOiBxW2lkQXR0cl0sXG4gICAgICAgIG5hbWU6IHFbbmFtZUF0dHJdXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0ZpbHRlcihyZXMpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb24uZmlsdGVyID8gZmlsdGVyKHJlcywgY29uZGl0aW9uLmZpbHRlcikgOiByZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdXNhZ2VcbiAgICogZWFjaENvbXBvbmVudCgnbGVnZW5kJywgZnVuY3Rpb24gKGxlZ2VuZE1vZGVsLCBpbmRleCkge1xuICAgKiAgICAgLi4uXG4gICAqIH0pO1xuICAgKiBlYWNoQ29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBtb2RlbCwgaW5kZXgpIHtcbiAgICogICAgIC8vIGNvbXBvbmVudFR5cGUgZG9lcyBub3QgaW5jbHVkZSBzdWJUeXBlXG4gICAqICAgICAvLyAoY29tcG9uZW50VHlwZSBpcyAneHh4JyBidXQgbm90ICd4eHguYWEnKVxuICAgKiB9KTtcbiAgICogZWFjaENvbXBvbmVudChcbiAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319LFxuICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICogKTtcbiAgICogZWFjaENvbXBvbmVudChcbiAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX0sXG4gICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3Q9fSBtYWluVHlwZSBXaGVuIG1haW5UeXBlIGlzIG9iamVjdCwgdGhlIGRlZmluaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGhlIHNhbWUgYXMgdGhlIG1ldGhvZCAnZmluZENvbXBvbmVudHMnLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICovXG4gIGVhY2hDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICBpZiAodHlwZW9mIG1haW5UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZXh0ID0gY2I7XG4gICAgICBjYiA9IG1haW5UeXBlO1xuICAgICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIGVhY2goY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKG1haW5UeXBlKSkge1xuICAgICAgZWFjaChjb21wb25lbnRzTWFwLmdldChtYWluVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgdmFyIHF1ZXJ5UmVzdWx0ID0gdGhpcy5maW5kQ29tcG9uZW50cyhtYWluVHlwZSk7XG4gICAgICBlYWNoKHF1ZXJ5UmVzdWx0LCBjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc31cbiAgICovXG4gIGdldFNlcmllc0J5SW5kZXg6IGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJylbc2VyaWVzSW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViVHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICovXG4gIGdldFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUpIHtcbiAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpO1xuXG4gICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgIHJldHVybiBvbmVTZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAqL1xuICBnZXRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5nZXQoJ3NlcmllcycpLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1NlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudC5cbiAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICpcbiAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBlYWNoU2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKVtyYXdTZXJpZXNJbmRleF07XG5cbiAgICAgIGlmIChzZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkIG9mIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgKi9cbiAgZWFjaFJhd1Nlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGVhY2godGhpcy5nZXRTZXJpZXNCeVR5cGUoc3ViVHlwZSksIGNiLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAqL1xuICBpc1Nlcmllc0ZpbHRlcmVkOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICByZXR1cm4genJVdGlsLmluZGV4T2YodGhpcy5fc2VyaWVzSW5kaWNlcywgc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgpIDwgMDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBnZXRDdXJyZW50U2VyaWVzSW5kaWNlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fc2VyaWVzSW5kaWNlcyB8fCBbXSkuc2xpY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAqL1xuICBmaWx0ZXJTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgIHZhciBmaWx0ZXJlZFNlcmllcyA9IGZpbHRlcih0aGlzLl9jb21wb25lbnRzTWFwLmdldCgnc2VyaWVzJyksIGNiLCBjb250ZXh0KTtcbiAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhmaWx0ZXJlZFNlcmllcyk7XG4gIH0sXG4gIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuZ2V0KCdzZXJpZXMnKSk7XG4gICAgdmFyIGNvbXBvbmVudFR5cGVzID0gW107XG4gICAgY29tcG9uZW50c01hcC5lYWNoKGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgIH0pO1xuICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKGNvbXBvbmVudFR5cGVzLCBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLCBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICBlYWNoKGNvbXBvbmVudHNNYXAuZ2V0KGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5yZXN0b3JlRGF0YSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZVRoZW1lKG9wdGlvbiwgdGhlbWUpIHtcbiAgenJVdGlsLmVhY2godGhlbWUsIGZ1bmN0aW9uICh0aGVtZUl0ZW0sIG5hbWUpIHtcbiAgICAvLyDlpoLmnpzmnIkgY29tcG9uZW50IG1vZGVsIOWImeaKiuWFt+S9k+eahCBtZXJnZSDpgLvovpHkuqTnu5nor6UgbW9kZWwg5aSE55CGXG4gICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGVtZUl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbltuYW1lXSA9ICFvcHRpb25bbmFtZV0gPyB6clV0aWwuY2xvbmUodGhlbWVJdGVtKSA6IHpyVXRpbC5tZXJnZShvcHRpb25bbmFtZV0sIHRoZW1lSXRlbSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9uW25hbWVdID0gdGhlbWVJdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdEJhc2UoYmFzZU9wdGlvbikge1xuICBiYXNlT3B0aW9uID0gYmFzZU9wdGlvbjsgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUsXG4gIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRlbi5cblxuICB0aGlzLm9wdGlvbiA9IHt9O1xuICB0aGlzLm9wdGlvbltPUFRJT05fSU5ORVJfS0VZXSA9IDE7XG4gIC8qKlxuICAgKiBJbml0IHdpdGggc2VyaWVzOiBbXSwgaW4gY2FzZSBvZiBjYWxsaW5nIGZpbmRTZXJpZXMgbWV0aG9kXG4gICAqIGJlZm9yZSBzZXJpZXMgaW5pdGlhbGl6ZWQuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2NvbXBvbmVudHNNYXAgPSB6clV0aWwuY3JlYXRlSGFzaE1hcCh7XG4gICAgc2VyaWVzOiBbXVxuICB9KTtcbiAgLyoqXG4gICAqIE1hcHBpbmcgYmV0d2VlbiBmaWx0ZXJlZCBzZXJpZXMgbGlzdCBhbmQgcmF3IHNlcmllcyBsaXN0LlxuICAgKiBrZXk6IGZpbHRlcmVkIHNlcmllcyBpbmRpY2VzLCB2YWx1ZTogcmF3IHNlcmllcyBpbmRpY2VzLlxuICAgKiBAdHlwZSB7QXJyYXkuPG51Ym1lcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3Nlcmllc0luZGljZXMgPSBudWxsO1xuICBtZXJnZVRoZW1lKGJhc2VPcHRpb24sIHRoaXMuX3RoZW1lLm9wdGlvbik7IC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcblxuICB6clV0aWwubWVyZ2UoYmFzZU9wdGlvbiwgZ2xvYmFsRGVmYXVsdCwgZmFsc2UpO1xuICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICogQHJldHVybiB7T2JqZWN0fSBrZXk6IHtzdHJpbmd9IHR5cGUsIHZhbHVlOiB7QXJyYXkuPE9iamVjdD59IG1vZGVsc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50c0J5VHlwZXMoY29tcG9uZW50c01hcCwgdHlwZXMpIHtcbiAgaWYgKCF6clV0aWwuaXNBcnJheSh0eXBlcykpIHtcbiAgICB0eXBlcyA9IHR5cGVzID8gW3R5cGVzXSA6IFtdO1xuICB9XG5cbiAgdmFyIHJldCA9IHt9O1xuICBlYWNoKHR5cGVzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwLmdldCh0eXBlKSB8fCBbXSkuc2xpY2UoKTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgbmV3Q3B0T3B0aW9uLCBleGlzdENvbXBvbmVudCkge1xuICB2YXIgc3ViVHlwZSA9IG5ld0NwdE9wdGlvbi50eXBlID8gbmV3Q3B0T3B0aW9uLnR5cGUgOiBleGlzdENvbXBvbmVudCA/IGV4aXN0Q29tcG9uZW50LnN1YlR5cGUgLy8gVXNlIGRldGVybWluZVN1YlR5cGUgb25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0Q29tcG9uZW50LlxuICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7IC8vIHRvb2x0aXAsIG1hcmtsaW5lLCBtYXJrcG9pbnQgbWF5IGFsd2F5cyBoYXMgbm8gc3ViVHlwZVxuXG4gIHJldHVybiBzdWJUeXBlO1xufVxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgcmV0dXJuIHNlcmllcy5jb21wb25lbnRJbmRleDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gZmlsdGVyQnlTdWJUeXBlKGNvbXBvbmVudHMsIGNvbmRpdGlvbikge1xuICAvLyBVc2luZyBoYXNPd25Qcm9wZXJ0eSBmb3IgcmVzdHJpY3QuIENvbnNpZGVyXG4gIC8vIHN1YlR5cGUgaXMgdW5kZWZpbmVkIGluIHVzZXIgcGF5bG9hZC5cbiAgcmV0dXJuIGNvbmRpdGlvbi5oYXNPd25Qcm9wZXJ0eSgnc3ViVHlwZScpID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICB9KSA6IGNvbXBvbmVudHM7XG59XG4vKipcbiAqIEBpbm5lclxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQoZWNNb2RlbCkge31cblxuenJVdGlsLm1peGluKEdsb2JhbE1vZGVsLCBjb2xvclBhbGV0dGVNaW5pbik7XG52YXIgX2RlZmF1bHQgPSBHbG9iYWxNb2RlbDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL0dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///340\n");

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar modelUtil = __webpack_require__(234);\n\nvar ComponentModel = __webpack_require__(248);\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\n\nfunction OptionManager(api) {\n  /**\n   * @private\n   * @type {module:echarts/ExtensionAPI}\n   */\n  this._api = api;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._timelineOptions = [];\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n\n  this._mediaList = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._mediaDefault;\n  /**\n   * -1, means default.\n   * empty means no media.\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._currentMediaIndices = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._optionBackup;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\n   * @public\n   * @param {Object} rawOption Raw option.\n   * @param {module:echarts/model/Global} ecModel\n   * @param {Array.<Function>} optionPreprocessorFuncs\n   * @return {Object} Init option\n   */\n  setOption: function (rawOption, optionPreprocessorFuncs) {\n    rawOption = clone(rawOption, true); // FIXME\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\n   * @param {boolean} isRecreate\n   * @return {Object}\n   */\n  mountOption: function (isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // 如果没有reset功能则不clone。\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Object}\n   */\n  getTimelineOption: function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Array.<Object>}\n   */\n  getMediaOption: function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9PcHRpb25NYW5hZ2VyLmpzP2E3YTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuXG4vKipcbiAqIEVDaGFydHMgb3B0aW9uIG1hbmFnZXJcbiAqXG4gKiBAbW9kdWxlIHtlY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJ9XG4gKi9cbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG52YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG52YXIgbWFwID0genJVdGlsLm1hcDtcbnZhciBtZXJnZSA9IHpyVXRpbC5tZXJnZTtcbnZhciBRVUVSWV9SRUcgPSAvXihtaW58bWF4KT8oLispJC87XG4vKipcbiAqIFRFUk0gRVhQTEFOQVRJT05TOlxuICpcbiAqIFtvcHRpb25dOlxuICpcbiAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAqICAgICB2YXIgb3B0aW9uID0ge1xuICogICAgICAgICB0aXRsZTogey4uLn0sXG4gKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gKiAgICAgICAgIHZpc3VhbE1hcDogey4uLn0sXG4gKiAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogW3Jhd09wdGlvbl06XG4gKlxuICogICAgIEFuIG9iamVjdCBpbnB1dCB0byBlY2hhcnRzLnNldE9wdGlvbi4gJ3Jhd09wdGlvbicgbWF5IGJlIGFuXG4gKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAqICAgICAgICAgYmFzZU9wdGlvbjoge1xuICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICogICAgICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAqICAgICAgICAgICAgIHNlcmllczogW1xuICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAqICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgIF1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgdGltZWxpbmU6IHsuLi59LFxuICogICAgICAgICBvcHRpb25zOiBbXG4gKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdLFxuICogICAgICAgICBtZWRpYTogW1xuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWF4V2lkdGg6IDMyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMjB9LCB2aXN1YWxNYXA6IHtzaG93OiBmYWxzZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWluV2lkdGg6IDMyMCwgbWF4V2lkdGg6IDcyMH0sXG4gKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAqICAgICAgICAgICAgIH1cbiAqICAgICAgICAgXVxuICogICAgIH07XG4gKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJcbiAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAqL1xuXG5mdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICovXG4gIHRoaXMuX2FwaSA9IGFwaTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG5cbiAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gW107XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuXG4gIHRoaXMuX21lZGlhTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAvKipcbiAgICogLTEsIG1lYW5zIGRlZmF1bHQuXG4gICAqIGVtcHR5IG1lYW5zIG5vIG1lZGlhLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuXG4gIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX25ld0Jhc2VPcHRpb247XG59IC8vIHRpbWVsaW5lLm5vdE1lcmdlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZWMzLiBGaXJzdGx5IHRoZXJlIGlzIHJlYXJseVxuLy8gY2FzZSB0aGF0IG5vdE1lcmdlIGlzIG5lZWRlZC4gU2Vjb25kbHkgc3VwcG9ydGluZyAnbm90TWVyZ2UnIHJlcXVpcmVzXG4vLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbi8vIGdvb2QgdG8gcGVyZm9ybWFuY2UuIFdoYXQncyBtb3JlLCB0aGF0IGJvdGggdGltZWxpbmUgYW5kIHNldE9wdGlvblxuLy8gbWV0aG9kIHN1cHBseSAnbm90TWVyZ2UnIGJyaW5ncyBjb21wbGV4IGFuZCBzb21lIHByb2JsZW1zLlxuLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuLy8gKHN0ZXAxKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IGZhbHNlfSwgLi4ufSwgZmFsc2UpO1xuLy8gKHN0ZXAyKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IHRydWV9LCAuLi59LCBmYWxzZSk7XG5cblxuT3B0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAqL1xuICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgcmF3T3B0aW9uID0gY2xvbmUocmF3T3B0aW9uLCB0cnVlKTsgLy8gRklYTUVcbiAgICAvLyDlpoLmnpwgdGltZWxpbmUgb3B0aW9ucyDmiJbogIUgbWVkaWEg5Lit6K6+572u5LqG5p+Q5Liq5bGe5oCn77yM6ICMYmFzZU9wdGlvbuS4reayoeacieiuvue9ru+8jOWImei/m+ihjOitpuWRiuOAglxuXG4gICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICB2YXIgbmV3UGFyc2VkT3B0aW9uID0gcGFyc2VSYXdPcHRpb24uY2FsbCh0aGlzLCByYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCAhb2xkT3B0aW9uQmFja3VwKTtcbiAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247IC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuXG4gICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgLy8gT25seSBiYXNlT3B0aW9uIGNhbiBiZSBtZXJnZWQuXG4gICAgICBtZXJnZU9wdGlvbihvbGRPcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb24pOyAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgIC8vIHRoYXQgaXMsIGlmIHlvdSBgc2V0T3B0aW9uYCB0d2ljZSBhbmQgYm90aCBoYXMgdGltZWxpbmUgb3B0aW9ucywgdGhlIGxhdHRlclxuICAgICAgLy8gdGltZWxpbmUgb3BpdG9ucyB3aWxsIG5vdCBiZSBtZXJnZWQgdG8gdGhlIGZvcm1lcnMsIGJ1dCBqdXN0IHN1YnN0aXR1ZGUgdGhlbS5cblxuICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMgPSBuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhTGlzdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0KSB7XG4gICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVjcmVhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgbW91bnRPcHRpb246IGZ1bmN0aW9uIChpc1JlY3JlYXRlKSB7XG4gICAgdmFyIG9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDsgLy8gVE9ET1xuICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgIHRoaXMuX3RpbWVsaW5lT3B0aW9ucyA9IG1hcChvcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zLCBjbG9uZSk7XG4gICAgdGhpcy5fbWVkaWFMaXN0ID0gbWFwKG9wdGlvbkJhY2t1cC5tZWRpYUxpc3QsIGNsb25lKTtcbiAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG4gICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGUgLy8gdGhpcy5fb3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIHdoaWNoIGlzIGNyZWF0ZWQgYXQgdGhlIGZpcnN0IGBzZXRPcHRpb25gXG4gICAgLy8gY2FsbGVkLCBhbmQgaXMgbWVyZ2VkIGludG8gZXZlcnkgbmV3IG9wdGlvbiBieSBpbm5lciBtZXRob2QgYG1lcmdlT3B0aW9uYFxuICAgIC8vIGVhY2ggdGltZSBgc2V0T3B0aW9uYCBjYWxsZWQsIGNhbiBiZSBvbmx5IHVzZWQgaW4gYGlzUmVjcmVhdGVgLCBiZWNhdXNlXG4gICAgLy8gaXRzIHJlbGlhYmlsaXR5IGlzIHVuZGVyIHN1c3BpY2lvbi4gSW4gb3RoZXIgY2FzZXMgb3B0aW9uIG1lcmdlIGlzXG4gICAgLy8gcGVyZm9ybWVkIGJ5IGBtb2RlbC5tZXJnZU9wdGlvbmAuXG4gICAgPyBvcHRpb25CYWNrdXAuYmFzZU9wdGlvbiA6IHRoaXMuX25ld0Jhc2VPcHRpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRUaW1lbGluZU9wdGlvbjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICB2YXIgb3B0aW9uO1xuICAgIHZhciB0aW1lbGluZU9wdGlvbnMgPSB0aGlzLl90aW1lbGluZU9wdGlvbnM7XG5cbiAgICBpZiAodGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0VGltZWxpbmVPcHRpb24gY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGVjTW9kZWwgaW5pdGVkLFxuICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcblxuICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgb3B0aW9uID0gY2xvbmUodGltZWxpbmVPcHRpb25zW3RpbWVsaW5lTW9kZWwuZ2V0Q3VycmVudEluZGV4KCldLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgIHZhciBlY1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG5cbiAgICB2YXIgZWNIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG5cbiAgICB2YXIgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFMaXN0O1xuICAgIHZhciBtZWRpYURlZmF1bHQgPSB0aGlzLl9tZWRpYURlZmF1bHQ7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107IC8vIE5vIG1lZGlhIGRlZmluZWQuXG5cbiAgICBpZiAoIW1lZGlhTGlzdC5sZW5ndGggJiYgIW1lZGlhRGVmYXVsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vIE11bHRpIG1lZGlhIG1heSBiZSBhcHBsaWVkLCB0aGUgbGF0dGVyIGRlZmluZWQgbWVkaWEgaGFzIGhpZ2hlciBwcmlvcml0eS5cblxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFwcGx5TWVkaWFRdWVyeShtZWRpYUxpc3RbaV0ucXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSAvLyBGSVhNRVxuICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuXG5cbiAgICBpZiAoIWluZGljZXMubGVuZ3RoICYmIG1lZGlhRGVmYXVsdCkge1xuICAgICAgaW5kaWNlcyA9IFstMV07XG4gICAgfVxuXG4gICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICByZXN1bHQgPSBtYXAoaW5kaWNlcywgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjbG9uZShpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb24pO1xuICAgICAgfSk7XG4gICAgfSAvLyBPdGhlcndpc2UgcmV0dXJuIG5vdGhpbmcuXG5cblxuICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBpbmRpY2VzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlUmF3T3B0aW9uKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsIGlzTmV3KSB7XG4gIHZhciB0aW1lbGluZU9wdGlvbnMgPSBbXTtcbiAgdmFyIG1lZGlhTGlzdCA9IFtdO1xuICB2YXIgbWVkaWFEZWZhdWx0O1xuICB2YXIgYmFzZU9wdGlvbjsgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMi5cblxuICB2YXIgdGltZWxpbmVPcHQgPSByYXdPcHRpb24udGltZWxpbmU7XG5cbiAgaWYgKHJhd09wdGlvbi5iYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbi5iYXNlT3B0aW9uO1xuICB9IC8vIEZvciB0aW1lbGluZVxuXG5cbiAgaWYgKHRpbWVsaW5lT3B0IHx8IHJhd09wdGlvbi5vcHRpb25zKSB7XG4gICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICB9IC8vIEZvciBtZWRpYSBxdWVyeVxuXG5cbiAgaWYgKHJhd09wdGlvbi5tZWRpYSkge1xuICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgIHZhciBtZWRpYSA9IHJhd09wdGlvbi5tZWRpYTtcbiAgICBlYWNoKG1lZGlhLCBmdW5jdGlvbiAoc2luZ2xlTWVkaWEpIHtcbiAgICAgIGlmIChzaW5nbGVNZWRpYSAmJiBzaW5nbGVNZWRpYS5vcHRpb24pIHtcbiAgICAgICAgaWYgKHNpbmdsZU1lZGlhLnF1ZXJ5KSB7XG4gICAgICAgICAgbWVkaWFMaXN0LnB1c2goc2luZ2xlTWVkaWEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgbWVkaWFEZWZhdWx0ID0gc2luZ2xlTWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBGb3Igbm9ybWFsIG9wdGlvblxuXG5cbiAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbjtcbiAgfSAvLyBTZXQgdGltZWxpbmVPcHQgdG8gYmFzZU9wdGlvbiBpbiBlYzMsXG4gIC8vIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIG1lcmdlIG9wdGlvbi5cblxuXG4gIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgIGJhc2VPcHRpb24udGltZWxpbmUgPSB0aW1lbGluZU9wdDtcbiAgfSAvLyBQcmVwcm9jZXNzLlxuXG5cbiAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucykuY29uY2F0KHpyVXRpbC5tYXAobWVkaWFMaXN0LCBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4gbWVkaWEub3B0aW9uO1xuICB9KSksIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBlYWNoKG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJlUHJvY2Vzcykge1xuICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICB0aW1lbGluZU9wdGlvbnM6IHRpbWVsaW5lT3B0aW9ucyxcbiAgICBtZWRpYURlZmF1bHQ6IG1lZGlhRGVmYXVsdCxcbiAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICB9O1xufVxuLyoqXG4gKiBAc2VlIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW1lZGlhcXVlcmllcy8jbWVkaWExPlxuICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAqIENhbiB1c2UgbWF4IG9yIG1pbiBhcyBwcmVmaXguXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseU1lZGlhUXVlcnkocXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSB7XG4gIHZhciByZWFsTWFwID0ge1xuICAgIHdpZHRoOiBlY1dpZHRoLFxuICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgYXNwZWN0cmF0aW86IGVjV2lkdGggLyBlY0hlaWdodCAvLyBsb3dzZXIgY2FzZSBmb3IgY29udmVuaWVudGNlLlxuXG4gIH07XG4gIHZhciBhcHBsaWNhdGFibGUgPSB0cnVlO1xuICB6clV0aWwuZWFjaChxdWVyeSwgZnVuY3Rpb24gKHZhbHVlLCBhdHRyKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICBpZiAoIW1hdGNoZWQgfHwgIW1hdGNoZWRbMV0gfHwgIW1hdGNoZWRbMl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0b3IgPSBtYXRjaGVkWzFdO1xuICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghY29tcGFyZShyZWFsTWFwW3JlYWxBdHRyXSwgdmFsdWUsIG9wZXJhdG9yKSkge1xuICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFwcGxpY2F0YWJsZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICByZXR1cm4gcmVhbCA+PSBleHBlY3Q7XG4gIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtYXgnKSB7XG4gICAgcmV0dXJuIHJlYWwgPD0gZXhwZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIEVxdWFsc1xuICAgIHJldHVybiByZWFsID09PSBleHBlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG59XG4vKipcbiAqIENvbnNpZGVyIGNhc2U6XG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAqIFRoZW4gdXNlciBkbyBzb21lIGludGVyYWN0aW9uIGxpa2UgZGF0YVpvb20sIGRhdGFWaWV3IGNoYW5naW5nLlxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgXG4gKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAqXG4gKiBBZnRlciBkb2luZyB0aGF0IGFsbCBvZiB0aGUgaW50ZXJhY3Rpb24gZWZmZWN0cyBzaG91bGQgYmUgcmVzZXQsIHRoZVxuICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YC5cbiAqXG4gKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AgaXMgZXF1aXZhbGVudHMgdG9cbiAqIGBjaGFydC5zZXRPcHRpb24obWVyZ2Uob3B0MSwgb3B0MikpO2AgZXhhY3RseSxcbiAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICpcbiAqIE1FTU86IFdlJ3ZlIGNvbnNpZGVyZWQgc29tZSBvdGhlciBhcHByb2FjaGVzOlxuICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAqICAgICAoVG9vIGNvbXBsZXggaW4gbG9naWMgYW5kIGVycm9yLXByb25lKVxuICogMi4gVXNlIGEgc2hhZG93IGVjTW9kZWwuIChQZXJmb3JtYWNlIGV4cGVuc2l2ZSlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcbiAgZWFjaChuZXdPcHRpb24sIGZ1bmN0aW9uIChuZXdDcHRPcHQsIG1haW5UeXBlKSB7XG4gICAgaWYgKG5ld0NwdE9wdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICBpZiAoIUNvbXBvbmVudE1vZGVsLmhhc0NsYXNzKG1haW5UeXBlKSkge1xuICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3Q3B0T3B0KTtcbiAgICAgIG9sZENwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9sZENwdE9wdCk7XG4gICAgICB2YXIgbWFwUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhvbGRDcHRPcHQsIG5ld0NwdE9wdCk7XG4gICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWFwKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QgPyBtZXJnZShpdGVtLmV4aXN0LCBpdGVtLm9wdGlvbiwgdHJ1ZSkgOiBpdGVtLmV4aXN0IHx8IGl0ZW0ub3B0aW9uO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gT3B0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///341\n");

/***/ }),
/* 342 */
/***/ (function(module, exports) {

eval("var platform = ''; // Navigator not exists in node\n\nif (typeof navigator !== 'undefined') {\n  platform = navigator.platform || '';\n}\n\nvar _default = {\n  // 全图默认背景\n  // backgroundColor: 'rgba(0,0,0,0)',\n  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n  // 浅色\n  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n  // 深色\n  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],\n  // 默认需要 Grid 配置项\n  // grid: {},\n  // 主题，主题\n  textStyle: {\n    // color: '#000',\n    // decoration: 'none',\n    // PENDING\n    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n    // fontFamily: 'Arial, Verdana, sans-serif',\n    fontSize: 12,\n    fontStyle: 'normal',\n    fontWeight: 'normal'\n  },\n  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n  // Default is source-over\n  blendMode: null,\n  animation: 'auto',\n  animationDuration: 1000,\n  animationDurationUpdate: 300,\n  animationEasing: 'exponentialOut',\n  animationEasingUpdate: 'cubicOut',\n  animationThreshold: 2000,\n  // Configuration for progressive/incremental rendering\n  progressiveThreshold: 3000,\n  progressive: 400,\n  // Threshold of if use single hover layer to optimize.\n  // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n  // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n  // which is unexpected.\n  // see example <echarts/test/heatmap-large.html>.\n  hoverLayerThreshold: 3000,\n  // See: module:echarts/scale/Time\n  useUTC: false\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9nbG9iYWxEZWZhdWx0LmpzP2ZkNTQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBsYXRmb3JtID0gJyc7IC8vIE5hdmlnYXRvciBub3QgZXhpc3RzIGluIG5vZGVcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtIHx8ICcnO1xufVxuXG52YXIgX2RlZmF1bHQgPSB7XG4gIC8vIOWFqOWbvum7mOiupOiDjOaZr1xuICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgLy8gaHR0cHM6Ly9kcmliYmJsZS5jb20vc2hvdHMvMTA2NTk2MC1JbmZvZ3JhcGhpYy1QaWUtY2hhcnQtdmlzdWFsaXphdGlvblxuICAvLyBjb2xvcjogWycjNTc5M2YzJywgJyNkMTRhNjEnLCAnI2ZkOWMzNScsICcjNjc1YmJhJywgJyNmZWM0MmMnLCAnI2RkNDQ0NCcsICcjZDRkZjVhJywgJyNjZDQ4NzAnXSxcbiAgLy8g5rWF6ImyXG4gIC8vIGNvbG9yOiBbJyNiY2QzYmInLCAnI2U4OGY3MCcsICcjZWRjMWE1JywgJyM5ZGM1YzgnLCAnI2UxZThjOCcsICcjN2I3YzY4JywgJyNlNWI1YjUnLCAnI2YwYjQ4OScsICcjOTI4ZWE4JywgJyNiZGEyOWEnXSxcbiAgLy8gY29sb3I6IFsnI2NjNTY2NCcsICcjOWJkNmVjJywgJyNlYTk0NmUnLCAnIzhhY2FhYScsICcjZjFlYzY0JywgJyNlZTg2ODYnLCAnI2E0OGRjMScsICcjNWRhNmJjJywgJyNiOWRjYWUnXSxcbiAgLy8g5rex6ImyXG4gIGNvbG9yOiBbJyNjMjM1MzEnLCAnIzJmNDU1NCcsICcjNjFhMGE4JywgJyNkNDgyNjUnLCAnIzkxYzdhZScsICcjNzQ5ZjgzJywgJyNjYTg2MjInLCAnI2JkYTI5YScsICcjNmU3MDc0JywgJyM1NDY1NzAnLCAnI2M0Y2NkMyddLFxuICAvLyDpu5jorqTpnIDopoEgR3JpZCDphY3nva7poblcbiAgLy8gZ3JpZDoge30sXG4gIC8vIOS4u+mimO+8jOS4u+mimFxuICB0ZXh0U3R5bGU6IHtcbiAgICAvLyBjb2xvcjogJyMwMDAnLFxuICAgIC8vIGRlY29yYXRpb246ICdub25lJyxcbiAgICAvLyBQRU5ESU5HXG4gICAgZm9udEZhbWlseTogcGxhdGZvcm0ubWF0Y2goL15XaW4vKSA/ICdNaWNyb3NvZnQgWWFIZWknIDogJ3NhbnMtc2VyaWYnLFxuICAgIC8vIGZvbnRGYW1pbHk6ICdBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsXG4gICAgZm9udFNpemU6IDEyLFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgfSxcbiAgLy8gaHR0cDovL2Jsb2dzLmFkb2JlLmNvbS93ZWJwbGF0Zm9ybS8yMDE0LzAyLzI0L3VzaW5nLWJsZW5kLW1vZGVzLWluLWh0bWwtY2FudmFzL1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAvLyBEZWZhdWx0IGlzIHNvdXJjZS1vdmVyXG4gIGJsZW5kTW9kZTogbnVsbCxcbiAgYW5pbWF0aW9uOiAnYXV0bycsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMzAwLFxuICBhbmltYXRpb25FYXNpbmc6ICdleHBvbmVudGlhbE91dCcsXG4gIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2N1YmljT3V0JyxcbiAgYW5pbWF0aW9uVGhyZXNob2xkOiAyMDAwLFxuICAvLyBDb25maWd1cmF0aW9uIGZvciBwcm9ncmVzc2l2ZS9pbmNyZW1lbnRhbCByZW5kZXJpbmdcbiAgcHJvZ3Jlc3NpdmVUaHJlc2hvbGQ6IDMwMDAsXG4gIHByb2dyZXNzaXZlOiA0MDAsXG4gIC8vIFRocmVzaG9sZCBvZiBpZiB1c2Ugc2luZ2xlIGhvdmVyIGxheWVyIHRvIG9wdGltaXplLlxuICAvLyBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IGBob3ZlckxheWVyVGhyZXNob2xkYCBpcyBlcXVpdmFsZW50IHRvIG9yIGxlc3MgdGhhblxuICAvLyBgcHJvZ3Jlc3NpdmVUaHJlc2hvbGRgLCBvdGhlcndpc2UgaG92ZXIgd2lsbCBjYXVzZSByZXN0YXJ0IG9mIHByb2dyZXNzaXZlLFxuICAvLyB3aGljaCBpcyB1bmV4cGVjdGVkLlxuICAvLyBzZWUgZXhhbXBsZSA8ZWNoYXJ0cy90ZXN0L2hlYXRtYXAtbGFyZ2UuaHRtbD4uXG4gIGhvdmVyTGF5ZXJUaHJlc2hvbGQ6IDMwMDAsXG4gIC8vIFNlZTogbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZVxuICB1c2VVVEM6IGZhbHNlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvbW9kZWwvZ2xvYmFsRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gMzQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///342\n");

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

eval("var makeStyleMapper = __webpack_require__(261);\n\nvar getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);\nvar _default = {\n  getAreaStyle: function (excludes, includes) {\n    return getAreaStyle(this, excludes, includes);\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9hcmVhU3R5bGUuanM/NGU0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0QXJlYVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Q29sb3InXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRBcmVhU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICByZXR1cm4gZ2V0QXJlYVN0eWxlKHRoaXMsIGV4Y2x1ZGVzLCBpbmNsdWRlcyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9hcmVhU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///343\n");

/***/ }),
/* 344 */
/***/ (function(module, exports) {

eval("var _default = {\n  getBoxLayoutParams: function () {\n    return {\n      left: this.get('left'),\n      top: this.get('top'),\n      right: this.get('right'),\n      bottom: this.get('bottom'),\n      width: this.get('width'),\n      height: this.get('height')\n    };\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9ib3hMYXlvdXQuanM/OTJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2RlZmF1bHQgPSB7XG4gIGdldEJveExheW91dFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLmdldCgnbGVmdCcpLFxuICAgICAgdG9wOiB0aGlzLmdldCgndG9wJyksXG4gICAgICByaWdodDogdGhpcy5nZXQoJ3JpZ2h0JyksXG4gICAgICBib3R0b206IHRoaXMuZ2V0KCdib3R0b20nKSxcbiAgICAgIHdpZHRoOiB0aGlzLmdldCgnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogdGhpcy5nZXQoJ2hlaWdodCcpXG4gICAgfTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2JveExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///344\n");

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

eval("var makeStyleMapper = __webpack_require__(261);\n\nvar getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);\nvar _default = {\n  getItemStyle: function (excludes, includes) {\n    var style = getItemStyle(this, excludes, includes);\n    var lineDash = this.getBorderLineDash();\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getBorderLineDash: function () {\n    var lineType = this.get('borderType');\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9pdGVtU3R5bGUuanM/OTAxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0SXRlbVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2ZpbGwnLCAnY29sb3InXSwgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSwgWydsaW5lV2lkdGgnLCAnYm9yZGVyV2lkdGgnXSwgWydvcGFjaXR5J10sIFsnc2hhZG93Qmx1ciddLCBbJ3NoYWRvd09mZnNldFgnXSwgWydzaGFkb3dPZmZzZXRZJ10sIFsnc2hhZG93Q29sb3InXSwgWyd0ZXh0UG9zaXRpb24nXSwgWyd0ZXh0QWxpZ24nXV0pO1xudmFyIF9kZWZhdWx0ID0ge1xuICBnZXRJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcywgaW5jbHVkZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRJdGVtU3R5bGUodGhpcywgZXhjbHVkZXMsIGluY2x1ZGVzKTtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldEJvcmRlckxpbmVEYXNoKCk7XG4gICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgZ2V0Qm9yZGVyTGluZURhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgnYm9yZGVyVHlwZScpO1xuICAgIHJldHVybiBsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsID8gbnVsbCA6IGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFs1LCA1XSA6IFsxLCAxXTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///345\n");

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

eval("var makeStyleMapper = __webpack_require__(261);\n\nvar getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getLineStyle: function (excludes) {\n    var style = getLineStyle(this, excludes);\n    var lineDash = this.getLineDash(style.lineWidth);\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getLineDash: function (lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    var lineType = this.get('type');\n    var dotSize = Math.max(lineWidth, 2);\n    var dashSize = lineWidth * 4;\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanM/MzU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFrZVN0eWxlTWFwcGVyID0gcmVxdWlyZShcIi4vbWFrZVN0eWxlTWFwcGVyXCIpO1xuXG52YXIgZ2V0TGluZVN0eWxlID0gbWFrZVN0eWxlTWFwcGVyKFtbJ2xpbmVXaWR0aCcsICd3aWR0aCddLCBbJ3N0cm9rZScsICdjb2xvciddLCBbJ29wYWNpdHknXSwgWydzaGFkb3dCbHVyJ10sIFsnc2hhZG93T2Zmc2V0WCddLCBbJ3NoYWRvd09mZnNldFknXSwgWydzaGFkb3dDb2xvciddXSk7XG52YXIgX2RlZmF1bHQgPSB7XG4gIGdldExpbmVTdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0TGluZVN0eWxlKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldExpbmVEYXNoKHN0eWxlLmxpbmVXaWR0aCk7XG4gICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcbiAgICBpZiAobGluZVdpZHRoID09IG51bGwpIHtcbiAgICAgIGxpbmVXaWR0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgZG90U2l6ZSA9IE1hdGgubWF4KGxpbmVXaWR0aCwgMik7XG4gICAgdmFyIGRhc2hTaXplID0gbGluZVdpZHRoICogNDtcbiAgICByZXR1cm4gbGluZVR5cGUgPT09ICdzb2xpZCcgfHwgbGluZVR5cGUgPT0gbnVsbCA/IG51bGwgOiBsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbZGFzaFNpemUsIGRhc2hTaXplXSA6IFtkb3RTaXplLCBkb3RTaXplXTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///346\n");

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

eval("var textContain = __webpack_require__(250);\n\nvar graphicUtil = __webpack_require__(233);\n\nvar PATH_COLOR = ['textStyle', 'color'];\nvar _default = {\n  /**\n   * Get color property or get color from option.textStyle.color\n   * @param {boolean} [isEmphasis]\n   * @return {string}\n   */\n  getTextColor: function (isEmphasis) {\n    var ecModel = this.ecModel;\n    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);\n  },\n\n  /**\n   * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n   * @return {string}\n   */\n  getFont: function () {\n    return graphicUtil.getFont({\n      fontStyle: this.getShallow('fontStyle'),\n      fontWeight: this.getShallow('fontWeight'),\n      fontSize: this.getShallow('fontSize'),\n      fontFamily: this.getShallow('fontFamily')\n    }, this.ecModel);\n  },\n  getTextRect: function (text) {\n    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanM/ZTRjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi90ZXh0XCIpO1xuXG52YXIgZ3JhcGhpY1V0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ncmFwaGljXCIpO1xuXG52YXIgUEFUSF9DT0xPUiA9IFsndGV4dFN0eWxlJywgJ2NvbG9yJ107XG52YXIgX2RlZmF1bHQgPSB7XG4gIC8qKlxuICAgKiBHZXQgY29sb3IgcHJvcGVydHkgb3IgZ2V0IGNvbG9yIGZyb20gb3B0aW9uLnRleHRTdHlsZS5jb2xvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0VtcGhhc2lzXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0Q29sb3I6IGZ1bmN0aW9uIChpc0VtcGhhc2lzKSB7XG4gICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnY29sb3InKSB8fCAoIWlzRW1waGFzaXMgJiYgZWNNb2RlbCA/IGVjTW9kZWwuZ2V0KFBBVEhfQ09MT1IpIDogbnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IHN0cmluZyBmcm9tIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0Rm9udDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBncmFwaGljVXRpbC5nZXRGb250KHtcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5nZXRTaGFsbG93KCdmb250U3R5bGUnKSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFdlaWdodCcpLFxuICAgICAgZm9udFNpemU6IHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpXG4gICAgfSwgdGhpcy5lY01vZGVsKTtcbiAgfSxcbiAgZ2V0VGV4dFJlY3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCB0aGlzLmdldEZvbnQoKSwgdGhpcy5nZXRTaGFsbG93KCdhbGlnbicpLCB0aGlzLmdldFNoYWxsb3coJ3ZlcnRpY2FsQWxpZ24nKSB8fCB0aGlzLmdldFNoYWxsb3coJ2Jhc2VsaW5lJyksIHRoaXMuZ2V0U2hhbGxvdygncGFkZGluZycpLCB0aGlzLmdldFNoYWxsb3coJ3JpY2gnKSwgdGhpcy5nZXRTaGFsbG93KCd0cnVuY2F0ZVRleHQnKSk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///347\n");

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _util = __webpack_require__(230);\n\nvar each = _util.each;\nvar isArray = _util.isArray;\nvar isObject = _util.isObject;\n\nvar compatStyle = __webpack_require__(349);\n\nvar _model = __webpack_require__(234);\n\nvar normalizeToArray = _model.normalizeToArray;\n\n// Compatitable with 2.0\nfunction get(opt, path) {\n  path = path.split(',');\n  var obj = opt;\n\n  for (var i = 0; i < path.length; i++) {\n    obj = obj && obj[path[i]];\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  return obj;\n}\n\nfunction set(opt, path, val, overwrite) {\n  path = path.split(',');\n  var obj = opt;\n  var key;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n\n    if (obj[key] == null) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  if (overwrite || obj[path[i]] == null) {\n    obj[path[i]] = val;\n  }\n}\n\nfunction compatLayoutProperties(option) {\n  each(LAYOUT_PROPERTIES, function (prop) {\n    if (prop[0] in option && !(prop[1] in option)) {\n      option[prop[1]] = option[prop[0]];\n    }\n  });\n}\n\nvar LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];\nvar COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];\nvar COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];\n\nfunction _default(option, isTheme) {\n  compatStyle(option, isTheme); // Make sure series array for model initialization.\n\n  option.series = normalizeToArray(option.series);\n  each(option.series, function (seriesOpt) {\n    if (!isObject(seriesOpt)) {\n      return;\n    }\n\n    var seriesType = seriesOpt.type;\n\n    if (seriesType === 'pie' || seriesType === 'gauge') {\n      if (seriesOpt.clockWise != null) {\n        seriesOpt.clockwise = seriesOpt.clockWise;\n      }\n    }\n\n    if (seriesType === 'gauge') {\n      var pointerColor = get(seriesOpt, 'pointer.color');\n      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n    }\n\n    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n      if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n        compatLayoutProperties(seriesOpt);\n        break;\n      }\n    }\n  }); // dataRange has changed to visualMap\n\n  if (option.dataRange) {\n    option.visualMap = option.dataRange;\n  }\n\n  each(COMPATITABLE_COMPONENTS, function (componentName) {\n    var options = option[componentName];\n\n    if (options) {\n      if (!isArray(options)) {\n        options = [options];\n      }\n\n      each(options, function (option) {\n        compatLayoutProperties(option);\n      });\n    }\n  });\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanM/ZjE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3V0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG52YXIgaXNBcnJheSA9IF91dGlsLmlzQXJyYXk7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcblxudmFyIGNvbXBhdFN0eWxlID0gcmVxdWlyZShcIi4vaGVscGVyL2NvbXBhdFN0eWxlXCIpO1xuXG52YXIgX21vZGVsID0gcmVxdWlyZShcIi4uL3V0aWwvbW9kZWxcIik7XG5cbnZhciBub3JtYWxpemVUb0FycmF5ID0gX21vZGVsLm5vcm1hbGl6ZVRvQXJyYXk7XG5cbi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuZnVuY3Rpb24gZ2V0KG9wdCwgcGF0aCkge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICB2YXIgb2JqID0gb3B0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIG9iaiA9IG9iaiAmJiBvYmpbcGF0aFtpXV07XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHNldChvcHQsIHBhdGgsIHZhbCwgb3ZlcndyaXRlKSB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcsJyk7XG4gIHZhciBvYmogPSBvcHQ7XG4gIHZhciBrZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGtleSA9IHBhdGhbaV07XG5cbiAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpba2V5XTtcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGUgfHwgb2JqW3BhdGhbaV1dID09IG51bGwpIHtcbiAgICBvYmpbcGF0aFtpXV0gPSB2YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pIHtcbiAgZWFjaChMQVlPVVRfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAocHJvcFswXSBpbiBvcHRpb24gJiYgIShwcm9wWzFdIGluIG9wdGlvbikpIHtcbiAgICAgIG9wdGlvbltwcm9wWzFdXSA9IG9wdGlvbltwcm9wWzBdXTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgTEFZT1VUX1BST1BFUlRJRVMgPSBbWyd4JywgJ2xlZnQnXSwgWyd5JywgJ3RvcCddLCBbJ3gyJywgJ3JpZ2h0J10sIFsneTInLCAnYm90dG9tJ11dO1xudmFyIENPTVBBVElUQUJMRV9DT01QT05FTlRTID0gWydncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXTtcbnZhciBDT01QQVRJVEFCTEVfU0VSSUVTID0gWydiYXInLCAnYm94cGxvdCcsICdjYW5kbGVzdGljaycsICdjaG9yZCcsICdlZmZlY3RTY2F0dGVyJywgJ2Z1bm5lbCcsICdnYXVnZScsICdsaW5lcycsICdncmFwaCcsICdoZWF0bWFwJywgJ2xpbmUnLCAnbWFwJywgJ3BhcmFsbGVsJywgJ3BpZScsICdyYWRhcicsICdzYW5rZXknLCAnc2NhdHRlcicsICd0cmVlbWFwJ107XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG9wdGlvbiwgaXNUaGVtZSkge1xuICBjb21wYXRTdHlsZShvcHRpb24sIGlzVGhlbWUpOyAvLyBNYWtlIHN1cmUgc2VyaWVzIGFycmF5IGZvciBtb2RlbCBpbml0aWFsaXphdGlvbi5cblxuICBvcHRpb24uc2VyaWVzID0gbm9ybWFsaXplVG9BcnJheShvcHRpb24uc2VyaWVzKTtcbiAgZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgaWYgKCFpc09iamVjdChzZXJpZXNPcHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc1R5cGUgPSBzZXJpZXNPcHQudHlwZTtcblxuICAgIGlmIChzZXJpZXNUeXBlID09PSAncGllJyB8fCBzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICBpZiAoc2VyaWVzT3B0LmNsb2NrV2lzZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmllc09wdC5jbG9ja3dpc2UgPSBzZXJpZXNPcHQuY2xvY2tXaXNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICB2YXIgcG9pbnRlckNvbG9yID0gZ2V0KHNlcmllc09wdCwgJ3BvaW50ZXIuY29sb3InKTtcbiAgICAgIHBvaW50ZXJDb2xvciAhPSBudWxsICYmIHNldChzZXJpZXNPcHQsICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJywgcG9pbnRlckNvbG9yKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPTVBBVElUQUJMRV9TRVJJRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChDT01QQVRJVEFCTEVfU0VSSUVTW2ldID09PSBzZXJpZXNPcHQudHlwZSkge1xuICAgICAgICBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKHNlcmllc09wdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIGRhdGFSYW5nZSBoYXMgY2hhbmdlZCB0byB2aXN1YWxNYXBcblxuICBpZiAob3B0aW9uLmRhdGFSYW5nZSkge1xuICAgIG9wdGlvbi52aXN1YWxNYXAgPSBvcHRpb24uZGF0YVJhbmdlO1xuICB9XG5cbiAgZWFjaChDT01QQVRJVEFCTEVfQ09NUE9ORU5UUywgZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgIH1cblxuICAgICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMob3B0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qc1xuLy8gbW9kdWxlIGlkID0gMzQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///348\n");

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar modelUtil = __webpack_require__(234);\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];\n\nfunction compatItemStyle(opt) {\n  var itemStyleOpt = opt && opt.itemStyle;\n\n  if (!itemStyleOpt) {\n    return;\n  }\n\n  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n    var styleName = POSSIBLE_STYLES[i];\n    var normalItemStyleOpt = itemStyleOpt.normal;\n    var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\n    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].normal) {\n        opt[styleName].normal = normalItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n      }\n\n      normalItemStyleOpt[styleName] = null;\n    }\n\n    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].emphasis) {\n        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n      }\n\n      emphasisItemStyleOpt[styleName] = null;\n    }\n  }\n}\n\nfunction compatTextStyle(opt, propName) {\n  var labelOptSingle = isObject(opt) && opt[propName];\n  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n\n  if (textStyle) {\n    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {\n      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];\n\n      if (textStyle.hasOwnProperty(propName)) {\n        labelOptSingle[propName] = textStyle[propName];\n      }\n    }\n  }\n}\n\nfunction compatLabelTextStyle(labelOpt) {\n  if (isObject(labelOpt)) {\n    compatTextStyle(labelOpt, 'normal');\n    compatTextStyle(labelOpt, 'emphasis');\n  }\n}\n\nfunction processSeries(seriesOpt) {\n  if (!isObject(seriesOpt)) {\n    return;\n  }\n\n  compatItemStyle(seriesOpt);\n  compatLabelTextStyle(seriesOpt.label); // treemap\n\n  compatLabelTextStyle(seriesOpt.upperLabel); // graph\n\n  compatLabelTextStyle(seriesOpt.edgeLabel);\n  var markPoint = seriesOpt.markPoint;\n  compatItemStyle(markPoint);\n  compatLabelTextStyle(markPoint && markPoint.label);\n  var markLine = seriesOpt.markLine;\n  compatItemStyle(seriesOpt.markLine);\n  compatLabelTextStyle(markLine && markLine.label);\n  var markArea = seriesOpt.markArea;\n  compatLabelTextStyle(markArea && markArea.label); // For gauge\n\n  compatTextStyle(seriesOpt, 'axisLabel');\n  compatTextStyle(seriesOpt, 'title');\n  compatTextStyle(seriesOpt, 'detail');\n  var data = seriesOpt.data;\n\n  if (data) {\n    for (var i = 0; i < data.length; i++) {\n      compatItemStyle(data[i]);\n      compatLabelTextStyle(data[i] && data[i].label);\n    }\n  } // mark point data\n\n\n  var markPoint = seriesOpt.markPoint;\n\n  if (markPoint && markPoint.data) {\n    var mpData = markPoint.data;\n\n    for (var i = 0; i < mpData.length; i++) {\n      compatItemStyle(mpData[i]);\n      compatLabelTextStyle(mpData[i] && mpData[i].label);\n    }\n  } // mark line data\n\n\n  var markLine = seriesOpt.markLine;\n\n  if (markLine && markLine.data) {\n    var mlData = markLine.data;\n\n    for (var i = 0; i < mlData.length; i++) {\n      if (zrUtil.isArray(mlData[i])) {\n        compatItemStyle(mlData[i][0]);\n        compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n        compatItemStyle(mlData[i][1]);\n        compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n      } else {\n        compatItemStyle(mlData[i]);\n        compatLabelTextStyle(mlData[i] && mlData[i].label);\n      }\n    }\n  }\n}\n\nfunction toArr(o) {\n  return zrUtil.isArray(o) ? o : o ? [o] : [];\n}\n\nfunction toObj(o) {\n  return (zrUtil.isArray(o) ? o[0] : o) || {};\n}\n\nfunction _default(option, isTheme) {\n  each(toArr(option.series), function (seriesOpt) {\n    isObject(seriesOpt) && processSeries(seriesOpt);\n  });\n  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n  each(axes, function (axisName) {\n    each(toArr(option[axisName]), function (axisOpt) {\n      if (axisOpt) {\n        compatTextStyle(axisOpt, 'axisLabel');\n        compatTextStyle(axisOpt.axisPointer, 'label');\n      }\n    });\n  });\n  each(toArr(option.parallel), function (parallelOpt) {\n    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n    compatTextStyle(parallelAxisDefault, 'axisLabel');\n    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n  });\n  each(toArr(option.calendar), function (calendarOpt) {\n    compatTextStyle(calendarOpt, 'dayLabel');\n    compatTextStyle(calendarOpt, 'monthLabel');\n    compatTextStyle(calendarOpt, 'yearLabel');\n  }); // radar.name.textStyle\n\n  each(toArr(option.radar), function (radarOpt) {\n    compatTextStyle(radarOpt, 'name');\n  });\n  each(toArr(option.geo), function (geoOpt) {\n    if (isObject(geoOpt)) {\n      compatLabelTextStyle(geoOpt.label);\n      each(toArr(geoOpt.regions), function (regionObj) {\n        compatLabelTextStyle(regionObj.label);\n      });\n    }\n  });\n  compatLabelTextStyle(toObj(option.timeline).label);\n  compatTextStyle(toObj(option.axisPointer), 'label');\n  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9wcmVwcm9jZXNzb3IvaGVscGVyL2NvbXBhdFN0eWxlLmpzP2FmZjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBtb2RlbFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9tb2RlbFwiKTtcblxudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcbnZhciBQT1NTSUJMRV9TVFlMRVMgPSBbJ2FyZWFTdHlsZScsICdsaW5lU3R5bGUnLCAnbm9kZVN0eWxlJywgJ2xpbmtTdHlsZScsICdjaG9yZFN0eWxlJywgJ2xhYmVsJywgJ2xhYmVsTGluZSddO1xuXG5mdW5jdGlvbiBjb21wYXRJdGVtU3R5bGUob3B0KSB7XG4gIHZhciBpdGVtU3R5bGVPcHQgPSBvcHQgJiYgb3B0Lml0ZW1TdHlsZTtcblxuICBpZiAoIWl0ZW1TdHlsZU9wdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBQT1NTSUJMRV9TVFlMRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc3R5bGVOYW1lID0gUE9TU0lCTEVfU1RZTEVTW2ldO1xuICAgIHZhciBub3JtYWxJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQubm9ybWFsO1xuICAgIHZhciBlbXBoYXNpc0l0ZW1TdHlsZU9wdCA9IGl0ZW1TdHlsZU9wdC5lbXBoYXNpcztcblxuICAgIGlmIChub3JtYWxJdGVtU3R5bGVPcHQgJiYgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgIG9wdFtzdHlsZU5hbWVdID0gb3B0W3N0eWxlTmFtZV0gfHwge307XG5cbiAgICAgIGlmICghb3B0W3N0eWxlTmFtZV0ubm9ybWFsKSB7XG4gICAgICAgIG9wdFtzdHlsZU5hbWVdLm5vcm1hbCA9IG5vcm1hbEl0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLm5vcm1hbCwgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGVtcGhhc2lzSXRlbVN0eWxlT3B0ICYmIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pIHtcbiAgICAgIG9wdFtzdHlsZU5hbWVdID0gb3B0W3N0eWxlTmFtZV0gfHwge307XG5cbiAgICAgIGlmICghb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMpIHtcbiAgICAgICAgb3B0W3N0eWxlTmFtZV0uZW1waGFzaXMgPSBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgenJVdGlsLm1lcmdlKG9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzLCBlbXBoYXNpc0l0ZW1TdHlsZU9wdFtzdHlsZU5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhdFRleHRTdHlsZShvcHQsIHByb3BOYW1lKSB7XG4gIHZhciBsYWJlbE9wdFNpbmdsZSA9IGlzT2JqZWN0KG9wdCkgJiYgb3B0W3Byb3BOYW1lXTtcbiAgdmFyIHRleHRTdHlsZSA9IGlzT2JqZWN0KGxhYmVsT3B0U2luZ2xlKSAmJiBsYWJlbE9wdFNpbmdsZS50ZXh0U3R5bGU7XG5cbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb2RlbFV0aWwuVEVYVF9TVFlMRV9PUFRJT05TLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBtb2RlbFV0aWwuVEVYVF9TVFlMRV9PUFRJT05TW2ldO1xuXG4gICAgICBpZiAodGV4dFN0eWxlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBsYWJlbE9wdFNpbmdsZVtwcm9wTmFtZV0gPSB0ZXh0U3R5bGVbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXRMYWJlbFRleHRTdHlsZShsYWJlbE9wdCkge1xuICBpZiAoaXNPYmplY3QobGFiZWxPcHQpKSB7XG4gICAgY29tcGF0VGV4dFN0eWxlKGxhYmVsT3B0LCAnbm9ybWFsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGxhYmVsT3B0LCAnZW1waGFzaXMnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2VyaWVzKHNlcmllc09wdCkge1xuICBpZiAoIWlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0KTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUoc2VyaWVzT3B0LmxhYmVsKTsgLy8gdHJlZW1hcFxuXG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKHNlcmllc09wdC51cHBlckxhYmVsKTsgLy8gZ3JhcGhcblxuICBjb21wYXRMYWJlbFRleHRTdHlsZShzZXJpZXNPcHQuZWRnZUxhYmVsKTtcbiAgdmFyIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG4gIGNvbXBhdEl0ZW1TdHlsZShtYXJrUG9pbnQpO1xuICBjb21wYXRMYWJlbFRleHRTdHlsZShtYXJrUG9pbnQgJiYgbWFya1BvaW50LmxhYmVsKTtcbiAgdmFyIG1hcmtMaW5lID0gc2VyaWVzT3B0Lm1hcmtMaW5lO1xuICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0Lm1hcmtMaW5lKTtcbiAgY29tcGF0TGFiZWxUZXh0U3R5bGUobWFya0xpbmUgJiYgbWFya0xpbmUubGFiZWwpO1xuICB2YXIgbWFya0FyZWEgPSBzZXJpZXNPcHQubWFya0FyZWE7XG4gIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1hcmtBcmVhICYmIG1hcmtBcmVhLmxhYmVsKTsgLy8gRm9yIGdhdWdlXG5cbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2F4aXNMYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUoc2VyaWVzT3B0LCAndGl0bGUnKTtcbiAgY29tcGF0VGV4dFN0eWxlKHNlcmllc09wdCwgJ2RldGFpbCcpO1xuICB2YXIgZGF0YSA9IHNlcmllc09wdC5kYXRhO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wYXRJdGVtU3R5bGUoZGF0YVtpXSk7XG4gICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShkYXRhW2ldICYmIGRhdGFbaV0ubGFiZWwpO1xuICAgIH1cbiAgfSAvLyBtYXJrIHBvaW50IGRhdGFcblxuXG4gIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuXG4gIGlmIChtYXJrUG9pbnQgJiYgbWFya1BvaW50LmRhdGEpIHtcbiAgICB2YXIgbXBEYXRhID0gbWFya1BvaW50LmRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcGF0SXRlbVN0eWxlKG1wRGF0YVtpXSk7XG4gICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtcERhdGFbaV0gJiYgbXBEYXRhW2ldLmxhYmVsKTtcbiAgICB9XG4gIH0gLy8gbWFyayBsaW5lIGRhdGFcblxuXG4gIHZhciBtYXJrTGluZSA9IHNlcmllc09wdC5tYXJrTGluZTtcblxuICBpZiAobWFya0xpbmUgJiYgbWFya0xpbmUuZGF0YSkge1xuICAgIHZhciBtbERhdGEgPSBtYXJrTGluZS5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh6clV0aWwuaXNBcnJheShtbERhdGFbaV0pKSB7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMF0pO1xuICAgICAgICBjb21wYXRMYWJlbFRleHRTdHlsZShtbERhdGFbaV1bMF0gJiYgbWxEYXRhW2ldWzBdLmxhYmVsKTtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVsxXSk7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1sRGF0YVtpXVsxXSAmJiBtbERhdGFbaV1bMV0ubGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXSk7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKG1sRGF0YVtpXSAmJiBtbERhdGFbaV0ubGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0b0FycihvKSB7XG4gIHJldHVybiB6clV0aWwuaXNBcnJheShvKSA/IG8gOiBvID8gW29dIDogW107XG59XG5cbmZ1bmN0aW9uIHRvT2JqKG8pIHtcbiAgcmV0dXJuICh6clV0aWwuaXNBcnJheShvKSA/IG9bMF0gOiBvKSB8fCB7fTtcbn1cblxuZnVuY3Rpb24gX2RlZmF1bHQob3B0aW9uLCBpc1RoZW1lKSB7XG4gIGVhY2godG9BcnIob3B0aW9uLnNlcmllcyksIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICBpc09iamVjdChzZXJpZXNPcHQpICYmIHByb2Nlc3NTZXJpZXMoc2VyaWVzT3B0KTtcbiAgfSk7XG4gIHZhciBheGVzID0gWyd4QXhpcycsICd5QXhpcycsICdyYWRpdXNBeGlzJywgJ2FuZ2xlQXhpcycsICdzaW5nbGVBeGlzJywgJ3BhcmFsbGVsQXhpcycsICdyYWRhciddO1xuICBpc1RoZW1lICYmIGF4ZXMucHVzaCgndmFsdWVBeGlzJywgJ2NhdGVnb3J5QXhpcycsICdsb2dBeGlzJywgJ3RpbWVBeGlzJyk7XG4gIGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXNOYW1lKSB7XG4gICAgZWFjaCh0b0FycihvcHRpb25bYXhpc05hbWVdKSwgZnVuY3Rpb24gKGF4aXNPcHQpIHtcbiAgICAgIGlmIChheGlzT3B0KSB7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LCAnYXhpc0xhYmVsJyk7XG4gICAgICAgIGNvbXBhdFRleHRTdHlsZShheGlzT3B0LmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLnBhcmFsbGVsKSwgZnVuY3Rpb24gKHBhcmFsbGVsT3B0KSB7XG4gICAgdmFyIHBhcmFsbGVsQXhpc0RlZmF1bHQgPSBwYXJhbGxlbE9wdCAmJiBwYXJhbGxlbE9wdC5wYXJhbGxlbEF4aXNEZWZhdWx0O1xuICAgIGNvbXBhdFRleHRTdHlsZShwYXJhbGxlbEF4aXNEZWZhdWx0LCAnYXhpc0xhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKHBhcmFsbGVsQXhpc0RlZmF1bHQgJiYgcGFyYWxsZWxBeGlzRGVmYXVsdC5heGlzUG9pbnRlciwgJ2xhYmVsJyk7XG4gIH0pO1xuICBlYWNoKHRvQXJyKG9wdGlvbi5jYWxlbmRhciksIGZ1bmN0aW9uIChjYWxlbmRhck9wdCkge1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ2RheUxhYmVsJyk7XG4gICAgY29tcGF0VGV4dFN0eWxlKGNhbGVuZGFyT3B0LCAnbW9udGhMYWJlbCcpO1xuICAgIGNvbXBhdFRleHRTdHlsZShjYWxlbmRhck9wdCwgJ3llYXJMYWJlbCcpO1xuICB9KTsgLy8gcmFkYXIubmFtZS50ZXh0U3R5bGVcblxuICBlYWNoKHRvQXJyKG9wdGlvbi5yYWRhciksIGZ1bmN0aW9uIChyYWRhck9wdCkge1xuICAgIGNvbXBhdFRleHRTdHlsZShyYWRhck9wdCwgJ25hbWUnKTtcbiAgfSk7XG4gIGVhY2godG9BcnIob3B0aW9uLmdlbyksIGZ1bmN0aW9uIChnZW9PcHQpIHtcbiAgICBpZiAoaXNPYmplY3QoZ2VvT3B0KSkge1xuICAgICAgY29tcGF0TGFiZWxUZXh0U3R5bGUoZ2VvT3B0LmxhYmVsKTtcbiAgICAgIGVhY2godG9BcnIoZ2VvT3B0LnJlZ2lvbnMpLCBmdW5jdGlvbiAocmVnaW9uT2JqKSB7XG4gICAgICAgIGNvbXBhdExhYmVsVGV4dFN0eWxlKHJlZ2lvbk9iai5sYWJlbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb21wYXRMYWJlbFRleHRTdHlsZSh0b09iaihvcHRpb24udGltZWxpbmUpLmxhYmVsKTtcbiAgY29tcGF0VGV4dFN0eWxlKHRvT2JqKG9wdGlvbi5heGlzUG9pbnRlciksICdsYWJlbCcpO1xuICBjb21wYXRUZXh0U3R5bGUodG9PYmoob3B0aW9uLnRvb2x0aXApLmF4aXNQb2ludGVyLCAnbGFiZWwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///349\n");

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Scale = __webpack_require__(257);\n\nvar numberUtil = __webpack_require__(235);\n\nvar IntervalScale = __webpack_require__(264);\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true, function (val) {\n      return val > 0;\n    }));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9Mb2cuanM/MGFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIFNjYWxlID0gcmVxdWlyZShcIi4vU2NhbGVcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoXCIuL0ludGVydmFsXCIpO1xuXG4vKipcbiAqIExvZyBzY2FsZVxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL0xvZ1xuICovXG4vLyBVc2Ugc29tZSBtZXRob2Qgb2YgSW50ZXJ2YWxTY2FsZVxudmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG52YXIgaW50ZXJ2YWxTY2FsZVByb3RvID0gSW50ZXJ2YWxTY2FsZS5wcm90b3R5cGU7XG52YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbnZhciByb3VuZGluZ0Vycm9yRml4ID0gbnVtYmVyVXRpbC5yb3VuZDtcbnZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoTG9nID0gTWF0aC5sb2c7XG52YXIgTG9nU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuICB0eXBlOiAnbG9nJyxcbiAgYmFzZTogMTAsXG4gICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIFNjYWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fb3JpZ2luYWxTY2FsZSA9IG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZ2luYWxTY2FsZSA9IHRoaXMuX29yaWdpbmFsU2NhbGU7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBvcmlnaW5hbFNjYWxlLmdldEV4dGVudCgpO1xuICAgIHJldHVybiB6clV0aWwubWFwKGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHRoaXMpLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgcG93VmFsID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoUG93KHRoaXMuYmFzZSwgdmFsKSk7IC8vIEZpeCAjNDE1OFxuXG4gICAgICBwb3dWYWwgPSB2YWwgPT09IGV4dGVudFswXSAmJiBvcmlnaW5hbFNjYWxlLl9fZml4TWluID8gZml4Um91bmRpbmdFcnJvcihwb3dWYWwsIG9yaWdpbmFsRXh0ZW50WzBdKSA6IHBvd1ZhbDtcbiAgICAgIHBvd1ZhbCA9IHZhbCA9PT0gZXh0ZW50WzFdICYmIG9yaWdpbmFsU2NhbGUuX19maXhNYXggPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMV0pIDogcG93VmFsO1xuICAgICAgcmV0dXJuIHBvd1ZhbDtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogaW50ZXJ2YWxTY2FsZVByb3RvLmdldExhYmVsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgIHJldHVybiBtYXRoUG93KHRoaXMuYmFzZSwgdmFsKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICovXG4gIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICBlbmQgPSBtYXRoTG9nKGVuZCkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIGludGVydmFsU2NhbGVQcm90by5zZXRFeHRlbnQuY2FsbCh0aGlzLCBzdGFydCwgZW5kKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmRcbiAgICovXG4gIGdldEV4dGVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIHZhciBleHRlbnQgPSBzY2FsZVByb3RvLmdldEV4dGVudC5jYWxsKHRoaXMpO1xuICAgIGV4dGVudFswXSA9IG1hdGhQb3coYmFzZSwgZXh0ZW50WzBdKTtcbiAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7IC8vIEZpeCAjNDE1OFxuXG4gICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1pbiAmJiAoZXh0ZW50WzBdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMF0sIG9yaWdpbmFsRXh0ZW50WzBdKSk7XG4gICAgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heCAmJiAoZXh0ZW50WzFdID0gZml4Um91bmRpbmdFcnJvcihleHRlbnRbMV0sIG9yaWdpbmFsRXh0ZW50WzFdKSk7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dGVudFxuICAgKi9cbiAgdW5pb25FeHRlbnQ6IGZ1bmN0aW9uIChleHRlbnQpIHtcbiAgICB0aGlzLl9vcmlnaW5hbFNjYWxlLnVuaW9uRXh0ZW50KGV4dGVudCk7XG5cbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICBleHRlbnRbMF0gPSBtYXRoTG9nKGV4dGVudFswXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgIGV4dGVudFsxXSA9IG1hdGhMb2coZXh0ZW50WzFdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudC5jYWxsKHRoaXMsIGV4dGVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgdHJ1ZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCA+IDA7XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbYXBwcm94VGlja051bSA9IDEwXSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICovXG4gIG5pY2VUaWNrczogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0pIHtcbiAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuXG4gICAgaWYgKHNwYW4gPT09IEluZmluaXR5IHx8IHNwYW4gPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnZhbCA9IG51bWJlclV0aWwucXVhbnRpdHkoc3Bhbik7XG4gICAgdmFyIGVyciA9IGFwcHJveFRpY2tOdW0gLyBzcGFuICogaW50ZXJ2YWw7IC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuXG4gICAgaWYgKGVyciA8PSAwLjUpIHtcbiAgICAgIGludGVydmFsICo9IDEwO1xuICAgIH0gLy8gSW50ZXJ2YWwgc2hvdWxkIGJlIGludGVnZXJcblxuXG4gICAgd2hpbGUgKCFpc05hTihpbnRlcnZhbCkgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpIDwgMSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPiAwKSB7XG4gICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICB9XG5cbiAgICB2YXIgbmljZUV4dGVudCA9IFtudW1iZXJVdGlsLnJvdW5kKG1hdGhDZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKSwgbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpXTtcbiAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBOaWNlIGV4dGVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgaW50ZXJ2YWxTY2FsZVByb3RvLm5pY2VFeHRlbnQuY2FsbCh0aGlzLCBvcHQpO1xuICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWluID0gb3B0LmZpeE1pbjtcbiAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWF4ID0gb3B0LmZpeE1heDtcbiAgfVxufSk7XG56clV0aWwuZWFjaChbJ2NvbnRhaW4nLCAnbm9ybWFsaXplJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIExvZ1NjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBtYXRoTG9nKHZhbCkgLyBtYXRoTG9nKHRoaXMuYmFzZSk7XG4gICAgcmV0dXJuIHNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB2YWwpO1xuICB9O1xufSk7XG5cbkxvZ1NjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBMb2dTY2FsZSgpO1xufTtcblxuZnVuY3Rpb24gZml4Um91bmRpbmdFcnJvcih2YWwsIG9yaWdpbmFsVmFsKSB7XG4gIHJldHVybiByb3VuZGluZ0Vycm9yRml4KHZhbCwgZ2V0UHJlY2lzaW9uU2FmZShvcmlnaW5hbFZhbCkpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBMb2dTY2FsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3NjYWxlL0xvZy5qc1xuLy8gbW9kdWxlIGlkID0gMzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///350\n");

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Scale = __webpack_require__(257);\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n  init: function (data, extent) {\n    this._data = data;\n    this._extent = extent || [0, data.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    return this._data[n];\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, false));\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9PcmRpbmFsLmpzPzNhNmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBTY2FsZSA9IHJlcXVpcmUoXCIuL1NjYWxlXCIpO1xuXG4vKipcbiAqIExpbmVhciBjb250aW51b3VzIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvT3JkaW5hbFxuICpcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2ZWxfb2ZfbWVhc3VyZW1lbnRcbiAqL1xuLy8gRklYTUUgb25seSBvbmUgZGF0YVxudmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG52YXIgT3JkaW5hbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ29yZGluYWwnLFxuICBpbml0OiBmdW5jdGlvbiAoZGF0YSwgZXh0ZW50KSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5fZXh0ZW50ID0gZXh0ZW50IHx8IFswLCBkYXRhLmxlbmd0aCAtIDFdO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHpyVXRpbC5pbmRleE9mKHRoaXMuX2RhdGEsIHZhbCkgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgIDogTWF0aC5yb3VuZCh2YWwpO1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAocmFuaykge1xuICAgIHJhbmsgPSB0aGlzLnBhcnNlKHJhbmspO1xuICAgIHJldHVybiBzY2FsZVByb3RvLmNvbnRhaW4uY2FsbCh0aGlzLCByYW5rKSAmJiB0aGlzLl9kYXRhW3JhbmtdICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBnaXZlbiByYW5rIG9yIG5hbWUgdG8gbGluZWFyIFswLCAxXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFt2YWxdXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBzY2FsZVByb3RvLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gIH0sXG4gIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoc2NhbGVQcm90by5zY2FsZS5jYWxsKHRoaXMsIHZhbCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpY2tzID0gW107XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICB2YXIgcmFuayA9IGV4dGVudFswXTtcblxuICAgIHdoaWxlIChyYW5rIDw9IGV4dGVudFsxXSkge1xuICAgICAgdGlja3MucHVzaChyYW5rKTtcbiAgICAgIHJhbmsrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBpdGVtIG9uIHJhbmsgblxuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYWJlbDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVtuXTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0ZW50WzFdIC0gdGhpcy5fZXh0ZW50WzBdICsgMTtcbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmlvbkV4dGVudEZyb21EYXRhOiBmdW5jdGlvbiAoZGF0YSwgZGltKSB7XG4gICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCBmYWxzZSkpO1xuICB9LFxuICBuaWNlVGlja3M6IHpyVXRpbC5ub29wLFxuICBuaWNlRXh0ZW50OiB6clV0aWwubm9vcFxufSk7XG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gKi9cblxuT3JkaW5hbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IE9yZGluYWxTY2FsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///351\n");

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar numberUtil = __webpack_require__(235);\n\nvar formatUtil = __webpack_require__(245);\n\nvar scaleHelper = __webpack_require__(279);\n\nvar IntervalScale = __webpack_require__(264);\n\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design have\n// concidered these common case:\n// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\nvar intervalScaleProto = IntervalScale.prototype;\nvar mathCeil = Math.ceil;\nvar mathFloor = Math.floor;\nvar ONE_SECOND = 1000;\nvar ONE_MINUTE = ONE_SECOND * 60;\nvar ONE_HOUR = ONE_MINUTE * 60;\nvar ONE_DAY = ONE_HOUR * 24; // FIXME 公用？\n\nvar bisect = function (a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (a[mid][1] < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n};\n/**\n * @alias module:echarts/coord/scale/Time\n * @constructor\n */\n\n\nvar TimeScale = IntervalScale.extend({\n  type: 'time',\n\n  /**\n   * @override\n   */\n  getLabel: function (val) {\n    var stepLvl = this._stepLvl;\n    var date = new Date(val);\n    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n  },\n\n  /**\n   * @override\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      // Expand extent\n      extent[0] -= ONE_DAY;\n      extent[1] += ONE_DAY;\n    } // If there are no data and extent are [Infinity, -Infinity]\n\n\n    if (extent[1] === -Infinity && extent[0] === Infinity) {\n      var d = new Date();\n      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      extent[0] = extent[1] - ONE_DAY;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n    }\n  },\n\n  /**\n   * @override\n   */\n  niceTicks: function (approxTickNum, minInterval, maxInterval) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    var approxInterval = span / approxTickNum;\n\n    if (minInterval != null && approxInterval < minInterval) {\n      approxInterval = minInterval;\n    }\n\n    if (maxInterval != null && approxInterval > maxInterval) {\n      approxInterval = maxInterval;\n    }\n\n    var scaleLevelsLen = scaleLevels.length;\n    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n    var interval = level[1]; // Same with interval scale if span is much larger than 1 year\n\n    if (level[0] === 'year') {\n      var yearSpan = span / interval; // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n      // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\n      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n      interval *= yearStep;\n    }\n\n    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;\n    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];\n    scaleHelper.fixExtent(niceExtent, extent);\n    this._stepLvl = level; // Interval will be used in getTicks\n\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n  parse: function (val) {\n    // val might be float.\n    return +numberUtil.parseDate(val);\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  TimeScale.prototype[methodName] = function (val) {\n    return intervalScaleProto[methodName].call(this, this.parse(val));\n  };\n}); // Steps from d3\n\nvar scaleLevels = [// Format              interval\n['hh:mm:ss', ONE_SECOND], // 1s\n['hh:mm:ss', ONE_SECOND * 5], // 5s\n['hh:mm:ss', ONE_SECOND * 10], // 10s\n['hh:mm:ss', ONE_SECOND * 15], // 15s\n['hh:mm:ss', ONE_SECOND * 30], // 30s\n['hh:mm\\nMM-dd', ONE_MINUTE], // 1m\n['hh:mm\\nMM-dd', ONE_MINUTE * 5], // 5m\n['hh:mm\\nMM-dd', ONE_MINUTE * 10], // 10m\n['hh:mm\\nMM-dd', ONE_MINUTE * 15], // 15m\n['hh:mm\\nMM-dd', ONE_MINUTE * 30], // 30m\n['hh:mm\\nMM-dd', ONE_HOUR], // 1h\n['hh:mm\\nMM-dd', ONE_HOUR * 2], // 2h\n['hh:mm\\nMM-dd', ONE_HOUR * 6], // 6h\n['hh:mm\\nMM-dd', ONE_HOUR * 12], // 12h\n['MM-dd\\nyyyy', ONE_DAY], // 1d\n['MM-dd\\nyyyy', ONE_DAY * 2], // 2d\n['MM-dd\\nyyyy', ONE_DAY * 3], // 3d\n['MM-dd\\nyyyy', ONE_DAY * 4], // 4d\n['MM-dd\\nyyyy', ONE_DAY * 5], // 5d\n['MM-dd\\nyyyy', ONE_DAY * 6], // 6d\n['week', ONE_DAY * 7], // 7d\n['MM-dd\\nyyyy', ONE_DAY * 10], // 10d\n['week', ONE_DAY * 14], // 2w\n['week', ONE_DAY * 21], // 3w\n['month', ONE_DAY * 31], // 1M\n['week', ONE_DAY * 42], // 6w\n['month', ONE_DAY * 62], // 2M\n['week', ONE_DAY * 42], // 10w\n['quarter', ONE_DAY * 380 / 4], // 3M\n['month', ONE_DAY * 31 * 4], // 4M\n['month', ONE_DAY * 31 * 5], // 5M\n['half-year', ONE_DAY * 380 / 2], // 6M\n['month', ONE_DAY * 31 * 8], // 8M\n['month', ONE_DAY * 31 * 10], // 10M\n['year', ONE_DAY * 380] // 1Y\n];\n/**\n * @param {module:echarts/model/Model}\n * @return {module:echarts/scale/Time}\n */\n\nTimeScale.create = function (model) {\n  return new TimeScale({\n    useUTC: model.ecModel.get('useUTC')\n  });\n};\n\nvar _default = TimeScale;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9zY2FsZS9UaW1lLmpzPzZmZGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCJ6cmVuZGVyL2xpYi9jb3JlL3V0aWxcIik7XG5cbnZhciBudW1iZXJVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbnVtYmVyXCIpO1xuXG52YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL2Zvcm1hdFwiKTtcblxudmFyIHNjYWxlSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuXG52YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoXCIuL0ludGVydmFsXCIpO1xuXG4vLyBbQWJvdXQgVVRDIGFuZCBsb2NhbCB0aW1lIHpvbmVdOlxuLy8gSW4gbW9zdCBjYXNlcywgYG51bWJlci5wYXJzZURhdGVgIHdpbGwgdHJlYXQgaW5wdXQgZGF0YSBzdHJpbmcgYXMgbG9jYWwgdGltZVxuLy8gKGV4Y2VwdCB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkIGluIHRpbWUgc3RyaW5nKS4gQW5kIGBmb3JtYXQuZm9ybWF0ZVRpbWVgIHJldHVybnNcbi8vIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC4gb3B0aW9uLnVzZVVUQyBpcyBmYWxzZSBieSBkZWZhdWx0LiBUaGlzIGRlc2lnbiBoYXZlXG4vLyBjb25jaWRlcmVkIHRoZXNlIGNvbW1vbiBjYXNlOlxuLy8gKDEpIFRpbWUgdGhhdCBpcyBwZXJzaXN0ZW50IGluIHNlcnZlciBpcyBpbiBVVEMsIGJ1dCBpdCBpcyBuZWVkZWQgdG8gYmUgZGlwbGF5ZWRcbi8vIGluIGxvY2FsIHRpbWUgYnkgZGVmYXVsdC5cbi8vICgyKSBCeSBkZWZhdWx0LCB0aGUgaW5wdXQgZGF0YSBzdHJpbmcgKGUuZy4sICcyMDExLTAxLTAyJykgc2hvdWxkIGJlIGRpc3BsYXllZFxuLy8gYXMgaXRzIG9yaWdpbmFsIHRpbWUsIHdpdGhvdXQgYW55IHRpbWUgZGlmZmVyZW5jZS5cbnZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcbnZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIE9ORV9TRUNPTkQgPSAxMDAwO1xudmFyIE9ORV9NSU5VVEUgPSBPTkVfU0VDT05EICogNjA7XG52YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG52YXIgT05FX0RBWSA9IE9ORV9IT1VSICogMjQ7IC8vIEZJWE1FIOWFrOeUqO+8n1xuXG52YXIgYmlzZWN0ID0gZnVuY3Rpb24gKGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuXG4gICAgaWYgKGFbbWlkXVsxXSA8IHgpIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvO1xufTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL1RpbWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRpbWVTY2FsZSA9IEludGVydmFsU2NhbGUuZXh0ZW5kKHtcbiAgdHlwZTogJ3RpbWUnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExhYmVsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHN0ZXBMdmwgPSB0aGlzLl9zdGVwTHZsO1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcbiAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUaW1lKHN0ZXBMdmxbMF0sIGRhdGUsIHRoaXMuZ2V0U2V0dGluZygndXNlVVRDJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG5pY2VFeHRlbnQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50OyAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cblxuICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgLy8gRXhwYW5kIGV4dGVudFxuICAgICAgZXh0ZW50WzBdIC09IE9ORV9EQVk7XG4gICAgICBleHRlbnRbMV0gKz0gT05FX0RBWTtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuXG5cbiAgICBpZiAoZXh0ZW50WzFdID09PSAtSW5maW5pdHkgJiYgZXh0ZW50WzBdID09PSBJbmZpbml0eSkge1xuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXh0ZW50WzFdID0gK25ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICBleHRlbnRbMF0gPSBleHRlbnRbMV0gLSBPTkVfREFZO1xuICAgIH1cblxuICAgIHRoaXMubmljZVRpY2tzKG9wdC5zcGxpdE51bWJlciwgb3B0Lm1pbkludGVydmFsLCBvcHQubWF4SW50ZXJ2YWwpOyAvLyB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuXG4gICAgdmFyIGludGVydmFsID0gdGhpcy5faW50ZXJ2YWw7XG5cbiAgICBpZiAoIW9wdC5maXhNaW4pIHtcbiAgICAgIGV4dGVudFswXSA9IG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdC5maXhNYXgpIHtcbiAgICAgIGV4dGVudFsxXSA9IG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtLCBtaW5JbnRlcnZhbCwgbWF4SW50ZXJ2YWwpIHtcbiAgICBhcHByb3hUaWNrTnVtID0gYXBwcm94VGlja051bSB8fCAxMDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgIHZhciBhcHByb3hJbnRlcnZhbCA9IHNwYW4gLyBhcHByb3hUaWNrTnVtO1xuXG4gICAgaWYgKG1pbkludGVydmFsICE9IG51bGwgJiYgYXBwcm94SW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgYXBwcm94SW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgICB9XG5cbiAgICBpZiAobWF4SW50ZXJ2YWwgIT0gbnVsbCAmJiBhcHByb3hJbnRlcnZhbCA+IG1heEludGVydmFsKSB7XG4gICAgICBhcHByb3hJbnRlcnZhbCA9IG1heEludGVydmFsO1xuICAgIH1cblxuICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gYmlzZWN0KHNjYWxlTGV2ZWxzLCBhcHByb3hJbnRlcnZhbCwgMCwgc2NhbGVMZXZlbHNMZW4pO1xuICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgdmFyIGludGVydmFsID0gbGV2ZWxbMV07IC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG5cbiAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgdmFyIHllYXJTcGFuID0gc3BhbiAvIGludGVydmFsOyAvLyBGcm9tIFwiTmljZSBOdW1iZXJzIGZvciBHcmFwaCBMYWJlbHNcIiBvZiBHcmFwaGljIEdlbXNcbiAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcblxuICAgICAgdmFyIHllYXJTdGVwID0gbnVtYmVyVXRpbC5uaWNlKHllYXJTcGFuIC8gYXBwcm94VGlja051bSwgdHJ1ZSk7XG4gICAgICBpbnRlcnZhbCAqPSB5ZWFyU3RlcDtcbiAgICB9XG5cbiAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpID8gMCA6IG5ldyBEYXRlKCtleHRlbnRbMF0gfHwgK2V4dGVudFsxXSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbiAgICB2YXIgbmljZUV4dGVudCA9IFtNYXRoLnJvdW5kKG1hdGhDZWlsKChleHRlbnRbMF0gLSB0aW1lem9uZU9mZnNldCkgLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCArIHRpbWV6b25lT2Zmc2V0KSwgTWF0aC5yb3VuZChtYXRoRmxvb3IoKGV4dGVudFsxXSAtIHRpbWV6b25lT2Zmc2V0KSAvIGludGVydmFsKSAqIGludGVydmFsICsgdGltZXpvbmVPZmZzZXQpXTtcbiAgICBzY2FsZUhlbHBlci5maXhFeHRlbnQobmljZUV4dGVudCwgZXh0ZW50KTtcbiAgICB0aGlzLl9zdGVwTHZsID0gbGV2ZWw7IC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgcmV0dXJuICtudW1iZXJVdGlsLnBhcnNlRGF0ZSh2YWwpO1xuICB9XG59KTtcbnpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gaW50ZXJ2YWxTY2FsZVByb3RvW21ldGhvZE5hbWVdLmNhbGwodGhpcywgdGhpcy5wYXJzZSh2YWwpKTtcbiAgfTtcbn0pOyAvLyBTdGVwcyBmcm9tIGQzXG5cbnZhciBzY2FsZUxldmVscyA9IFsvLyBGb3JtYXQgICAgICAgICAgICAgIGludGVydmFsXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORF0sIC8vIDFzXG5bJ2hoOm1tOnNzJywgT05FX1NFQ09ORCAqIDVdLCAvLyA1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxMF0sIC8vIDEwc1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAxNV0sIC8vIDE1c1xuWydoaDptbTpzcycsIE9ORV9TRUNPTkQgKiAzMF0sIC8vIDMwc1xuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURV0sIC8vIDFtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogNV0sIC8vIDVtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfTUlOVVRFICogMTBdLCAvLyAxMG1cblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9NSU5VVEUgKiAxNV0sIC8vIDE1bVxuWydoaDptbVxcbk1NLWRkJywgT05FX01JTlVURSAqIDMwXSwgLy8gMzBtXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUl0sIC8vIDFoXG5bJ2hoOm1tXFxuTU0tZGQnLCBPTkVfSE9VUiAqIDJdLCAvLyAyaFxuWydoaDptbVxcbk1NLWRkJywgT05FX0hPVVIgKiA2XSwgLy8gNmhcblsnaGg6bW1cXG5NTS1kZCcsIE9ORV9IT1VSICogMTJdLCAvLyAxMmhcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWV0sIC8vIDFkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiAyXSwgLy8gMmRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDNdLCAvLyAzZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogNF0sIC8vIDRkXG5bJ01NLWRkXFxueXl5eScsIE9ORV9EQVkgKiA1XSwgLy8gNWRcblsnTU0tZGRcXG55eXl5JywgT05FX0RBWSAqIDZdLCAvLyA2ZFxuWyd3ZWVrJywgT05FX0RBWSAqIDddLCAvLyA3ZFxuWydNTS1kZFxcbnl5eXknLCBPTkVfREFZICogMTBdLCAvLyAxMGRcblsnd2VlaycsIE9ORV9EQVkgKiAxNF0sIC8vIDJ3XG5bJ3dlZWsnLCBPTkVfREFZICogMjFdLCAvLyAzd1xuWydtb250aCcsIE9ORV9EQVkgKiAzMV0sIC8vIDFNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyA2d1xuWydtb250aCcsIE9ORV9EQVkgKiA2Ml0sIC8vIDJNXG5bJ3dlZWsnLCBPTkVfREFZICogNDJdLCAvLyAxMHdcblsncXVhcnRlcicsIE9ORV9EQVkgKiAzODAgLyA0XSwgLy8gM01cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA0XSwgLy8gNE1cblsnbW9udGgnLCBPTkVfREFZICogMzEgKiA1XSwgLy8gNU1cblsnaGFsZi15ZWFyJywgT05FX0RBWSAqIDM4MCAvIDJdLCAvLyA2TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDhdLCAvLyA4TVxuWydtb250aCcsIE9ORV9EQVkgKiAzMSAqIDEwXSwgLy8gMTBNXG5bJ3llYXInLCBPTkVfREFZICogMzgwXSAvLyAxWVxuXTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gKi9cblxuVGltZVNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICByZXR1cm4gbmV3IFRpbWVTY2FsZSh7XG4gICAgdXNlVVRDOiBtb2RlbC5lY01vZGVsLmdldCgndXNlVVRDJylcbiAgfSk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBUaW1lU2NhbGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9zY2FsZS9UaW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///352\n");

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Gradient = __webpack_require__(269);\n\nfunction _default(ecModel) {\n  function encodeColor(seriesModel) {\n    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n    var data = seriesModel.getData();\n    var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n    || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color\n    // FIXME Set color function or use the platte color\n\n    data.setVisual('color', color); // Only visible series has each data be visual encoded\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      if (typeof color === 'function' && !(color instanceof Gradient)) {\n        data.each(function (idx) {\n          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n        });\n      } // itemStyle in each data item\n\n\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var color = itemModel.get(colorAccessPath, true);\n\n        if (color != null) {\n          data.setItemVisual(idx, 'color', color);\n        }\n      });\n    }\n  }\n\n  ecModel.eachRawSeries(encodeColor);\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi92aXN1YWwvc2VyaWVzQ29sb3IuanM/NGI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3JhZGllbnQgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxuZnVuY3Rpb24gX2RlZmF1bHQoZWNNb2RlbCkge1xuICBmdW5jdGlvbiBlbmNvZGVDb2xvcihzZXJpZXNNb2RlbCkge1xuICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgY29sb3IgPSBzZXJpZXNNb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoKSAvLyBTZXQgaW4gaXRlbVN0eWxlXG4gICAgfHwgc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShzZXJpZXNNb2RlbC5nZXQoJ25hbWUnKSk7IC8vIERlZmF1bHQgY29sb3JcbiAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcblxuICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTsgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG5cbiAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdmdW5jdGlvbicgJiYgIShjb2xvciBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gaXRlbVN0eWxlIGluIGVhY2ggZGF0YSBpdGVtXG5cblxuICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgIHZhciBjb2xvciA9IGl0ZW1Nb2RlbC5nZXQoY29sb3JBY2Nlc3NQYXRoLCB0cnVlKTtcblxuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGVuY29kZUNvbG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///353\n");

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(230);\n\nvar vec2 = __webpack_require__(236);\n\nvar Draggable = __webpack_require__(386);\n\nvar Eventful = __webpack_require__(252);\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzP2ZiZWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBEcmFnZ2FibGUgPSByZXF1aXJlKFwiLi9taXhpbi9EcmFnZ2FibGVcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG4vKipcbiAqIEhhbmRsZXJcbiAqIEBtb2R1bGUgenJlbmRlci9IYW5kbGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoc2hlbnlpLjkxNEBnbWFpbC5jb20pXG4gKi9cbnZhciBTSUxFTlQgPSAnc2lsZW50JztcblxuZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldEluZm8sIGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXZlVHlwZSxcbiAgICBldmVudDogZXZlbnQsXG4gICAgLy8gdGFyZ2V0IGNhbiBvbmx5IGJlIGFuIGVsZW1lbnQgdGhhdCBpcyBub3Qgc2lsZW50LlxuICAgIHRhcmdldDogdGFyZ2V0SW5mby50YXJnZXQsXG4gICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgIHRvcFRhcmdldDogdGFyZ2V0SW5mby50b3BUYXJnZXQsXG4gICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICB6ckJ5VG91Y2g6IGV2ZW50LnpyQnlUb3VjaCxcbiAgICB3aGljaDogZXZlbnQud2hpY2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gRW1wdHlQcm94eSgpIHt9XG5cbkVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhbmRsZXJOYW1lcyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0hhbmRsZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZSBTdG9yYWdlIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyIFBhaW50ZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHl9IHByb3h5IEhhbmRsZXJQcm94eSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhaW50ZXJSb290IHBhaW50ZXIucm9vdCAobm90IHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpLlxuICovXG5cbnZhciBIYW5kbGVyID0gZnVuY3Rpb24gKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG4gIHByb3h5ID0gcHJveHkgfHwgbmV3IEVtcHR5UHJveHkoKTtcbiAgLyoqXG4gICAqIFByb3h5IG9mIGV2ZW50LiBjYW4gYmUgRG9tLCBXZWJHTFN1cmZhY2UsIGV0Yy5cbiAgICovXG5cbiAgdGhpcy5wcm94eSA9IHByb3h5OyAvLyBBdHRhY2ggaGFuZGxlclxuXG4gIHByb3h5LmhhbmRsZXIgPSB0aGlzO1xuICAvKipcbiAgICoge3RhcmdldCwgdG9wVGFyZ2V0LCB4LCB5fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFg7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WTtcbiAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG4gIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gIH0sIHRoaXMpO1xufTtcblxuSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGVyLFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgIHZhciB5ID0gZXZlbnQuenJZO1xuICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgdmFyIGxhc3RIb3ZlcmVkVGFyZ2V0ID0gbGFzdEhvdmVyZWQudGFyZ2V0OyAvLyBJZiBsYXN0SG92ZXJlZFRhcmdldCBpcyByZW1vdmVkIGZyb20genIgKGRldGVjdGVkIGJ5ICdfX3pyJykgYnkgc29tZSBBUEkgY2FsbFxuICAgIC8vIChsaWtlICdzZXRPcHRpb24nIG9yICdkaXNwYXRjaEFjdGlvbicpIGluIGV2ZW50IGhhbmRsZXJzLCB3ZSBzaG91bGQgZmluZFxuICAgIC8vIGxhc3RIb3ZlcmVkIGFnYWluIGhlcmUuIE90aGVyd2lzZSAnbW91c2VvdXQnIGNhbiBub3QgYmUgdHJpZ2dlcmVkIG5vcm1hbGx5LlxuICAgIC8vIFNlZSAjNjE5OC5cblxuICAgIGlmIChsYXN0SG92ZXJlZFRhcmdldCAmJiAhbGFzdEhvdmVyZWRUYXJnZXQuX196cikge1xuICAgICAgbGFzdEhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihsYXN0SG92ZXJlZC54LCBsYXN0SG92ZXJlZC55KTtcbiAgICAgIGxhc3RIb3ZlcmVkVGFyZ2V0ID0gbGFzdEhvdmVyZWQudGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5faG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGhvdmVyZWRUYXJnZXQgPyBob3ZlcmVkVGFyZ2V0LmN1cnNvciA6ICdkZWZhdWx0Jyk7IC8vIE1vdXNlIG91dCBvbiBwcmV2aW91cyBob3ZlcmVkIGVsZW1lbnRcblxuICAgIGlmIChsYXN0SG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0SG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgIH0gLy8gTW91c2UgbW92aW5nIG9uIG9uZSBlbGVtZW50XG5cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlbW92ZScsIGV2ZW50KTsgLy8gTW91c2Ugb3ZlciBvbiBhIG5ldyBlbGVtZW50XG5cbiAgICBpZiAoaG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpOyAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgIC8vIGF0IHRoZSBzYW1lIGxldmVsIG9mIHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkgKGUuZy4sIHRvb2x0aXBcbiAgICAvLyBkb20gY3JlYXRlZCBieSBlY2hhcnRzKSwgd2hlcmUgJ2dsb2JhbG91dCcgZXZlbnQgc2hvdWxkIG5vdFxuICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAvLyBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0IHRoZSBvcmlnaW5hbCBob3ZlcmVkIGVsZW1lbnQgYXMgdXN1YWwpLlxuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICB2YXIgaW5uZXJEb207XG5cbiAgICBkbyB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkgJiYgIShpbm5lckRvbSA9IGVsZW1lbnQgPT09IHRoaXMucGFpbnRlclJvb3QpKTtcblxuICAgICFpbm5lckRvbSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemVcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICovXG4gIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXNbZXZlbnROYW1lXTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwb3NlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gdGhpcy5wcm94eSA9IHRoaXMucGFpbnRlciA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAqL1xuICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEluZm8sIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mbyB8fCB7fTtcbiAgICB2YXIgZWwgPSB0YXJnZXRJbmZvLnRhcmdldDtcblxuICAgIGlmIChlbCAmJiBlbC5zaWxlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRJbmZvLCBldmVudCk7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGVsW2V2ZW50SGFuZGxlcl0gJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcbiAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7IC8vIOWIhuWPkeS6i+S7tuWIsOeUqOaIt+iHquWumuS5ieWxglxuICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG5cbiAgICAgIHRoaXMucGFpbnRlciAmJiB0aGlzLnBhaW50ZXIuZWFjaE90aGVyTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGF5ZXJbZXZlbnRIYW5kbGVyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGF5ZXJbZXZlbnRIYW5kbGVyXS5jYWxsKGxheWVyLCBldmVudFBhY2tldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgIGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfSBleGNsdWRlXG4gICAqIEByZXR1cm4ge21vZGVsOnpyZW5kZXIvRWxlbWVudH1cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSwgZXhjbHVkZSkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgdmFyIG91dCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgaG92ZXJDaGVja1Jlc3VsdDtcblxuICAgICAgaWYgKGxpc3RbaV0gIT09IGV4Y2x1ZGUgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAmJiAhbGlzdFtpXS5pZ25vcmUgJiYgKGhvdmVyQ2hlY2tSZXN1bHQgPSBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSkge1xuICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGxpc3RbaV0pO1xuXG4gICAgICAgIGlmIChob3ZlckNoZWNrUmVzdWx0ICE9PSBTSUxFTlQpIHtcbiAgICAgICAgICBvdXQudGFyZ2V0ID0gbGlzdFtpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07IC8vIENvbW1vbiBoYW5kbGVyc1xuXG51dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZKTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuXG4gICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICB0aGlzLl9kb3duRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5fZG93blBvaW50ID0gW2V2ZW50LnpyWCwgZXZlbnQuenJZXTsgLy8gSW4gY2FzZSBjbGljayB0cmlnZ2VyZWQgYmVmb3JlIG1vdXNldXBcblxuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnbW9zdWV1cCcpIHtcbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaWYgKHRoaXMuX2Rvd25FbCAhPT0gdGhpcy5fdXBFbCAvLyBPcmlnaW5hbCBjbGljayBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhlIHdob2xlIGNhbnZhcyBlbGVtZW50LFxuICAgICAgLy8gaW5jbHVkaW5nIHRoZSBjYXNlIHRoYXQgYG1vdXNlZG93bmAgLSBgbW91c2Vtb3ZlYCAtIGBtb3VzZXVwYCxcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWx0ZXJlZCwgb3RoZXJ3aXNlIGl0IHdpbGwgYnJpbmcgdHJvdWJsZSB0b1xuICAgICAgLy8gcGFuIGFuZCB6b29tLlxuICAgICAgfHwgIXRoaXMuX2Rvd25Qb2ludCAvLyBBcmJpdHJhcnkgdmFsdWVcbiAgICAgIHx8IHZlYzIuZGlzdCh0aGlzLl9kb3duUG9pbnQsIFtldmVudC56clgsIGV2ZW50LnpyWV0pID4gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCBuYW1lLCBldmVudCk7XG4gIH07XG59KTtcblxuZnVuY3Rpb24gaXNIb3ZlcihkaXNwbGF5YWJsZSwgeCwgeSkge1xuICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICB2YXIgZWwgPSBkaXNwbGF5YWJsZTtcbiAgICB2YXIgaXNTaWxlbnQ7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIC8vIElmIGNsaXBwZWQgYnkgYW5jZXN0b3IuXG4gICAgICAvLyBGSVhNRTogSWYgY2xpcFBhdGggaGFzIG5laXRoZXIgc3Ryb2tlIG5vciBmaWxsLFxuICAgICAgLy8gZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAgICBpZiAoZWwuY2xpcFBhdGggJiYgIWVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwuc2lsZW50KSB7XG4gICAgICAgIGlzU2lsZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzU2lsZW50ID8gU0lMRU5UIDogdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG51dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvSGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMzU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///354\n");

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(230);\n\nvar _config = __webpack_require__(258);\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = __webpack_require__(292);\n\nvar Pattern = __webpack_require__(291);\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * 创建dom\n *\n * @inner\n * @param {string} id dom id 待用\n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * 每次清空画布的颜色\n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * 是否开启动态模糊\n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * 清空该层画布\n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9MYXllci5qcz9mNTg2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvU3R5bGVcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9QYXR0ZXJuXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICog5Yib5bu6ZG9tXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBuZXdEb20gPSB1dGlsLmNyZWF0ZUNhbnZhcygpO1xuICB2YXIgd2lkdGggPSBwYWludGVyLmdldFdpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBwYWludGVyLmdldEhlaWdodCgpO1xuICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7IC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cblxuICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIG5ld0RvbVN0eWxlLmxlZnQgPSAwO1xuICBuZXdEb21TdHlsZS50b3AgPSAwO1xuICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgbmV3RG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgbmV3RG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7IC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG5cbiAgbmV3RG9tLnNldEF0dHJpYnV0ZSgnZGF0YS16ci1kb20taWQnLCBpZCk7XG4gIHJldHVybiBuZXdEb207XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlclxuICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gKi9cblxuXG52YXIgTGF5ZXIgPSBmdW5jdGlvbiAoaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgZG9tO1xuICBkcHIgPSBkcHIgfHwgZGV2aWNlUGl4ZWxSYXRpbztcblxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKTtcbiAgfSAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoaWQpKSB7XG4gICAgICBkb20gPSBpZDtcbiAgICAgIGlkID0gZG9tLmlkO1xuICAgIH1cblxuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG5cbiAgaWYgKGRvbVN0eWxlKSB7XG4gICAgLy8gTm90IGluIG5vZGVcbiAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBkb21TdHlsZVsncGFkZGluZyddID0gMDtcbiAgICBkb21TdHlsZVsnbWFyZ2luJ10gPSAwO1xuICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gIH1cblxuICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICB0aGlzLmNvbmZpZyA9IG51bGw7IC8vIENvbmZpZ3NcblxuICAvKipcbiAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG5cbiAgdGhpcy5jbGVhckNvbG9yID0gMDtcbiAgLyoqXG4gICAqIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG5cbiAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gIC8qKlxuICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjdcbiAgICovXG5cbiAgdGhpcy5sYXN0RnJhbWVBbHBoYSA9IDAuNztcbiAgLyoqXG4gICAqIExheWVyIGRwclxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmRwciA9IGRwcjtcbn07XG5cbkxheWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExheWVyLFxuICBlbENvdW50OiAwLFxuICBfX2RpcnR5OiB0cnVlLFxuICBpbml0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eC5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLmN0eC5kcHIgPSB0aGlzLmRwcjtcbiAgfSxcbiAgY3JlYXRlQmFja0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcbiAgICB0aGlzLmRvbUJhY2sgPSBjcmVhdGVEb20oJ2JhY2stJyArIHRoaXMuaWQsIHRoaXMucGFpbnRlciwgZHByKTtcbiAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eEJhY2suX19jdXJyZW50VmFsdWVzID0ge307XG5cbiAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0XG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgaWYgKGRvbUJhY2spIHtcbiAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQWxsIENsZWFyIGFsbCB3aXRoIG91dCBtb3Rpb24gYmx1clxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCkge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuICAgIHZhciBjbGVhckNvbG9yID0gdGhpcy5jbGVhckNvbG9yO1xuICAgIHZhciBoYXZlTW90aW9uQkx1ciA9IHRoaXMubW90aW9uQmx1ciAmJiAhY2xlYXJBbGw7XG4gICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIGlmICghdGhpcy5kb21CYWNrKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgdGhpcy5jdHhCYWNrLmRyYXdJbWFnZShkb20sIDAsIDAsIHdpZHRoIC8gZHByLCBoZWlnaHQgLyBkcHIpO1xuICAgIH1cblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgdmFyIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjsgLy8gR3JhZGllbnRcblxuICAgICAgaWYgKGNsZWFyQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAvLyBDYWNoZSBjYW52YXMgZ3JhZGllbnRcbiAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50IHx8IFN0eWxlLmdldEdyYWRpZW50KGN0eCwgY2xlYXJDb2xvciwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgIH0gLy8gUGF0dGVyblxuICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4uY2FsbChjbGVhckNvbG9yLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuIHx8IGNsZWFyQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICBjdHguZHJhd0ltYWdlKGRvbUJhY2ssIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBMYXllcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///355\n");

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _config = __webpack_require__(258);\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = __webpack_require__(230);\n\nvar log = __webpack_require__(289);\n\nvar BoundingRect = __webpack_require__(244);\n\nvar timsort = __webpack_require__(267);\n\nvar Layer = __webpack_require__(355);\n\nvar requestAnimationFrame = __webpack_require__(283);\n\nvar Image = __webpack_require__(290);\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // 层中的元素数量有发生变化\n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // 优化没有实际改变的resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzP2VlOTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2NvcmUvbG9nXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG52YXIgTGF5ZXIgPSByZXF1aXJlKFwiLi9MYXllclwiKTtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBJbWFnZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvSW1hZ2VcIik7XG5cbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFBFTkRJR05cbi8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbi8vXG4vLyBNYXhpbXVtIHByb2dyZXNzaXZlIGxheWVyLiBXaGVuIGV4Y2VlZGluZyB0aGlzIG51bWJlci4gQWxsIGVsZW1lbnRzIHdpbGwgYmUgZHJhd2VkIGluIHRoZSBsYXN0IGxheWVyLlxudmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG5mdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICBpZiAoIWxheWVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGxheWVyLnJlc2l6ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbGF5ZXIucmVmcmVzaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xufVxuXG5mdW5jdGlvbiBwb3N0UHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGlmIChsYXllci5fX3VudXNlZENvdW50ID09IDEpIHtcbiAgICBsYXllci5jbGVhcigpO1xuICB9XG59XG5cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbnZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG5cbmZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcblxuICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICB9XG5cbiAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykge1xuICAgIC8vIENhbiBib3RoIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgY2xpcFBhdGhzLmxlbmd0aCAhPT0gcHJldkNsaXBQYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNsaXBQYXRoc1tpXSAhPT0gcHJldkNsaXBQYXRoc1tpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjbGlwUGF0aCA9IGNsaXBQYXRoc1tpXTtcbiAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY2xpcFBhdGguYnVpbGRQYXRoKGN0eCwgY2xpcFBhdGguc2hhcGUpO1xuICAgIGN0eC5jbGlwKCk7IC8vIFRyYW5zZm9ybSBiYWNrXG5cbiAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGRvbVJvb3Qub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbJ3Bvc2l0aW9uOnJlbGF0aXZlJywgJ292ZXJmbG93OmhpZGRlbicsICd3aWR0aDonICsgd2lkdGggKyAncHgnLCAnaGVpZ2h0OicgKyBoZWlnaHQgKyAncHgnLCAncGFkZGluZzowJywgJ21hcmdpbjowJywgJ2JvcmRlci13aWR0aDowJ10uam9pbignOycpICsgJzsnO1xuICByZXR1cm4gZG9tUm9vdDtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuXG5cbnZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgdGhpcy50eXBlID0gJ2NhbnZhcyc7IC8vIEluIG5vZGUgZW52aXJvbm1lbnQgdXNpbmcgbm9kZS1jYW52YXNcblxuICB2YXIgc2luZ2xlQ2FudmFzID0gIXJvb3Qubm9kZU5hbWUgLy8gSW4gbm9kZSA/XG4gIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG4gIHRoaXMuX29wdHMgPSBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMgfHwge30pO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgZGV2aWNlUGl4ZWxSYXRpbztcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gIC8qKlxuICAgKiDnu5jlm77lrrnlmahcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cblxuICB0aGlzLnJvb3QgPSByb290O1xuICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICBpZiAocm9vdFN0eWxlKSB7XG4gICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPSByb290U3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgKi9cblxuXG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICogQHR5cGUge3ByaXZhdGV9XG4gICAqL1xuXG4gIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgcm9vdC53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHJvb3QuaGVpZ2h0ID0gb3B0cy5oZWlnaHQ7XG4gICAgfSAvLyBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZGlyZWN0bHlcblxuXG4gICAgdmFyIHdpZHRoID0gcm9vdC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7IC8vIENyZWF0ZSBsYXllciBpZiBvbmx5IG9uZSBnaXZlbiBjYW52YXNcbiAgICAvLyBEZXZpY2UgcGl4ZWwgcmF0aW8gaXMgZml4ZWQgdG8gMSBiZWNhdXNlIGdpdmVuIGNhbnZhcyBoYXMgaXRzIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG5cbiAgICB2YXIgbWFpbkxheWVyID0gbmV3IExheWVyKHJvb3QsIHRoaXMsIDEpO1xuICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpOyAvLyBGSVhNRSBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgIHpsZXZlbExpc3QucHVzaCgwKTtcbiAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgfSAvLyBMYXllcnMgZm9yIHByb2dyZXNzaXZlIHJlbmRlcmluZ1xuXG5cbiAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5faG92ZXJsYXllcjtcbiAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdjYW52YXMnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIt+aWsFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYWludEFsbD1mYWxzZV0g5by65Yi257uY5Yi25omA5pyJZGlzcGxheWFibGVcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIChwYWludEFsbCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcblxuICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7IC8vIFBhaW50IGN1c3R1bSBsYXllcnNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcblxuICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0UHJvZ2Vzc2l2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XG4gICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgc3R5bGU6IGVsLnN0eWxlLFxuICAgICAgc2hhcGU6IGVsLnNoYXBlXG4gICAgfSk7XG4gICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgZWwuX19ob3Zlck1pciA9IGVsTWlycm9yO1xuICAgIGVsTWlycm9yLnNldFN0eWxlKGhvdmVyU3R5bGUpO1xuXG4gICAgdGhpcy5faG92ZXJFbGVtZW50cy5wdXNoKGVsTWlycm9yKTtcbiAgfSxcbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBlbE1pcnJvciA9IGVsLl9faG92ZXJNaXI7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICB9LFxuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvdmVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmcm9tID0gaG92ZXJFbGVtZW50c1tpXS5fX2Zyb207XG5cbiAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgIGZyb20uX19ob3Zlck1pciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG92ZXJFbGVtZW50cy5sZW5ndGggPSAwO1xuICB9LFxuICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgdmFyIGxlbiA9IGhvdmVyRWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltc29ydChob3ZlckVsZW1lbnRzLCB0aGlzLnN0b3JhZ2UuZGlzcGxheWFibGVTb3J0RnVuYyk7IC8vIFVzZSBhIGV4dHJlYW0gbGFyZ2UgemxldmVsXG4gICAgLy8gRklYTUU/XG5cbiAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyID0gdGhpcy5nZXRMYXllcigxZTUpO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHt9O1xuICAgIGhvdmVyTGF5ZXIuY3R4LnNhdmUoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGVsID0gaG92ZXJFbGVtZW50c1tpXTtcbiAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tOyAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAvLyBQRU5ESU5HXG5cbiAgICAgIGlmICghKG9yaWdpbmFsRWwgJiYgb3JpZ2luYWxFbC5fX3pyKSkge1xuICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3JpZ2luYWxFbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgbGVuLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpKys7IC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgIC8vIEZJWE1FIHN0eWxlIGFuZCBzaGFwZSA/XG5cbiAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7IC8vIGVsLlxuXG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaG92ZXJMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgfSxcbiAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVc2UgYSB0b2tlbiB0byBzdG9wIHByb2dyZXNzIHN0ZXBzIHRyaWdnZXJlZCBieVxuICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cblxuXG4gICAgdmFyIHRva2VuID0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9ICtuZXcgRGF0ZSgpO1xuICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIC8vIEluIGNhc2UgcmVmcmVzaGVkIG9yIGRpc3Bvc2VkXG4gICAgICBpZiAodG9rZW4gPT09IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gJiYgc2VsZi5zdG9yYWdlKSB7XG4gICAgICAgIHNlbGYuX2RvUGFpbnRMaXN0KHNlbGYuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpKTtcblxuICAgICAgICBpZiAoc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLl9fZGlydHkgJiYgbGF5ZXIuY2xlYXIoKTtcbiAgICB9KTtcbiAgfSxcbiAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgIHBhaW50QWxsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJTdGF0dXMobGlzdCk7XG5cbiAgICB0aGlzLl9jbGVhclByb2dyZXNzaXZlKCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgIHRoaXMuX2RvUGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihwb3N0UHJvY2Vzc0xheWVyKTtcbiAgfSxcbiAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICB2YXIgY3VycmVudExheWVyO1xuICAgIHZhciBjdXJyZW50WkxldmVsO1xuICAgIHZhciBjdHg7IC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcblxuICAgIHZhciBzY29wZTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcklkeCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgdmFyIGxheWVyUHJvZ3Jlc3M7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5fcHJvZ3Jlc3M7XG5cbiAgICBmdW5jdGlvbiBmbHVzaFByb2dyZXNzaXZlTGF5ZXIobGF5ZXIpIHtcbiAgICAgIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDsgLy8gQXZvaWQgbGF5ZXIgZG9uJ3QgY2xlYXIgaW4gbmV4dCBwcm9ncmVzc2l2ZSBmcmFtZVxuXG4gICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3R4LmRyYXdJbWFnZShsYXllci5kb20sIDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTsgLy8gRmx1c2ggYXQgY3VycmVudCBjb250ZXh0XG4gICAgICAvLyBQRU5ESU5HXG5cbiAgICAgIGlmIChlbEZyYW1lIDwgMCAmJiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICB9IC8vIENoYW5nZSBkcmF3IGxheWVyXG5cblxuICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHNjb3BlXG5cblxuICAgICAgICBzY29wZSA9IHt9OyAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcblxuICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICBsb2coJ1pMZXZlbCAnICsgY3VycmVudFpMZXZlbCArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpOyAvLyBSZXNldCB0aGUgY291bnRcblxuICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgY3VycmVudExheWVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnNbTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllcklkeCsrLCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSldO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUgPSB7fTtcblxuICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciAmJiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIC8vIFF1aWNrIGp1bXAgYWxsIHByb2dyZXNzaXZlIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICBpID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyAtIDE7IC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA9IGZyYW1lICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbEZyYW1lID09PSBmcmFtZSkge1xuICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIsIHRydWUsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgfSAvLyBSZXN0b3JlIHRoZSBsYXN0TGF5ZXIgY3R4XG5cblxuICAgIGN0eCAmJiBjdHgucmVzdG9yZSgpOyAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAvLyBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gZmFsc2U7XG4gICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGlmIChsYXllci5fX21heFByb2dyZXNzID49IGxheWVyLl9fcHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgdmFyIG0gPSBlbC50cmFuc2Zvcm07XG5cbiAgICBpZiAoKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IGZvcmNlUGFpbnQpICYmIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICFlbC5pbnZpc2libGUgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwIC8vIElnbm9yZSBzY2FsZSAwIGVsZW1lbnQsIGluIHNvbWUgZW52aXJvbm1lbnQgbGlrZSBub2RlLWNhbnZhc1xuICAgIC8vIERyYXcgYSBzY2FsZSAwIGVsZW1lbnQgY2FuIGNhdXNlIGFsbCBmb2xsb3dpbmcgZHJhdyB3cm9uZ1xuICAgIC8vIEFuZCBzZXRUcmFuc2Zvcm0gd2l0aCBzY2FsZSAwIHdpbGwgY2F1c2Ugc2V0IGJhY2sgdHJhbnNmb3JtIGZhaWxlZC5cbiAgICAmJiAhKG0gJiYgIW1bMF0gJiYgIW1bM10pIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSkpIHtcbiAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRoczsgLy8gT3B0aW1pemUgd2hlbiBjbGlwcGluZyBvbiBncm91cCB3aXRoIHNldmVyYWwgZWxlbWVudHNcblxuICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllciB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocykpIHtcbiAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDsgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcblxuICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgIH0gLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG5cblxuICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKGN0eCk7XG4gICAgICBlbC5icnVzaChjdHgsIHNjb3BlLnByZXZFbCB8fCBudWxsKTtcbiAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5YgemxldmVsIOaJgOWcqOWxgu+8jOWmguaenOS4jeWtmOWcqOWImeS8muWIm+W7uuS4gOS4quaWsOeahOWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgKi9cbiAgZ2V0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICBsYXllciA9IG5ldyBMYXllcignenJfJyArIHpsZXZlbCwgdGhpcywgdGhpcy5kcHIpO1xuICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTsgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGFmdGVyIGRvbSBpbnNlcnRlZCB0byBkb2N1bWVudFxuICAgICAgLy8gT3IgZXhjYW52YXMgd2lsbCBnZXQgMHB4IGNsaWVudFdpZHRoIGFuZCBjbGllbnRIZWlnaHRcblxuICAgICAgbGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH0sXG4gIGluc2VydExheWVyOiBmdW5jdGlvbiAoemxldmVsLCBsYXllcikge1xuICAgIHZhciBsYXllcnNNYXAgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICB2YXIgcHJldkxheWVyID0gbnVsbDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgIGlmIChsYXllcnNNYXBbemxldmVsXSkge1xuICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDaGVjayBpZiBpcyBhIHZhbGlkIGxheWVyXG5cblxuICAgIGlmICghaXNMYXllclZhbGlkKGxheWVyKSkge1xuICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbiA+IDAgJiYgemxldmVsID4gemxldmVsTGlzdFswXSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICBpZiAoemxldmVsTGlzdFtpXSA8IHpsZXZlbCAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICB9XG5cbiAgICB6bGV2ZWxMaXN0LnNwbGljZShpICsgMSwgMCwgemxldmVsKTtcbiAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyOyAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgIC8vIChJdCBjYW4gYmUgYSBXZWJHTCBsYXllciBhbmQgYXNzaWduZWQgdG8gYSBaSW1hZ2UgZWxlbWVudClcbiAgICAvLyBCdXQgaXQgc3RpbGwgdW5kZXIgbWFuYWdlbWVudCBvZiB6cmVuZGVyLlxuXG4gICAgaWYgKCFsYXllci52aXJ0dWFsKSB7XG4gICAgICBpZiAocHJldkxheWVyKSB7XG4gICAgICAgIHZhciBwcmV2RG9tID0gcHJldkxheWVyLmRvbTtcblxuICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgcHJldkRvbS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZG9tUm9vdC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIGxheWVyXG4gIGVhY2hMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbel0sIHopO1xuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIGJ1aWxkaW4gbGF5ZXJcbiAgZWFjaEJ1aWx0aW5MYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllcjtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggb3RoZXIgbGF5ZXIgZXhjZXB0IGJ1aWxkaW4gbGF5ZXJcbiAgZWFjaE90aGVyTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9MYXllcj59IFtwcmV2TGF5ZXJdXG4gICAqL1xuICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICB9LFxuICBfdXBkYXRlTGF5ZXJTdGF0dXM6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcnMgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVycztcbiAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgIGVsQ291bnRzTGFzdEZyYW1lW3pdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG4gICAgdmFyIGxhc3RQcm9ncmVzc2l2ZUtleTtcbiAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgdmFyIHpsZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgIHZhciBlbFByb2dyZXNzID0gZWwucHJvZ3Jlc3NpdmU7XG5cbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICB9IC8vLy8vLy8gVXBkYXRlIHByb2dyZXNzaXZlXG5cblxuICAgICAgaWYgKGVsUHJvZ3Jlc3MgPj0gMCkge1xuICAgICAgICAvLyBGaXggd3JvbmcgcHJvZ3Jlc3NpdmUgc2VxdWVuY2UgcHJvYmxlbS5cbiAgICAgICAgaWYgKGxhc3RQcm9ncmVzc2l2ZUtleSAhPT0gZWxQcm9ncmVzcykge1xuICAgICAgICAgIGxhc3RQcm9ncmVzc2l2ZUtleSA9IGVsUHJvZ3Jlc3M7XG4gICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lID0gZnJhbWVDb3VudCAtIDE7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIHZhciBpZHggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG5cbiAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF0gPSBuZXcgTGF5ZXIoJ3Byb2dyZXNzaXZlJywgdGhpcywgdGhpcy5kcHIpO1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IE1hdGgubWF4KGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MsIGVsRnJhbWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID49IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBTaG91bGQga2VlcCByZW5kZXJpbmcgdGhpcyAgbGF5ZXIgYmVjYXVzZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyA9IGk7XG4gICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgIH0gLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG5cblxuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgIGlmIChlbENvdW50c0xhc3RGcmFtZVt6XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIodGhpcy5fY2xlYXJMYXllcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBsYXllci5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkv67mlLnmjIflrpp6bGV2ZWznmoTnu5jliLblj4LmlbBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpsZXZlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIOmFjee9ruWvueixoVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XVxuICAgKiAgICAgICAgICAgICAgICAg5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoemxldmVsLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB2YXIgbGF5ZXJDb25maWcgPSB0aGlzLl9sYXllckNvbmZpZztcblxuICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgIGxheWVyQ29uZmlnW3psZXZlbF0gPSBjb25maWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyQ29uZmlnW3psZXZlbF0sIGNvbmZpZywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTmjIflrprlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbCDlsYLmiYDlnKjnmoR6bGV2ZWxcbiAgICovXG4gIGRlbExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAoIWxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGF5ZXIuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG4gICAgemxldmVsTGlzdC5zcGxpY2UodXRpbC5pbmRleE9mKHpsZXZlbExpc3QsIHpsZXZlbCksIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDljLrln5/lpKflsI/lj5jljJblkI7ph43nu5hcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7IC8vIEZJWE1FIFdoeSA/XG5cbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIFNhdmUgaW5wdXQgdy9oXG5cbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICBoZWlnaHQgIT0gbnVsbCAmJiAob3B0cy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICBoZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnOyAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcblxuICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICBkb21Sb290LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgZG9tUm9vdC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBsYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICovXG4gIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOmHiuaUvlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLnJvb3QgPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLl9kb21Sb290ID0gdGhpcy5fbGF5ZXJzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5waXhlbFJhdGlvXVxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VMYXllciA9IG5ldyBMYXllcignaW1hZ2UnLCB0aGlzLCBvcHRzLnBpeGVsUmF0aW8gfHwgdGhpcy5kcHIpO1xuICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICBpbWFnZUxheWVyLmNsZWFyQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG4gICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuICAgIHZhciBzY29wZSA9IHt9O1xuICAgIHZhciB6bGV2ZWw7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmluZEFuZERyYXdPdGhlckxheWVyKHNtYWxsZXIsIGxhcmdlcikge1xuICAgICAgdmFyIHpsZXZlbExpc3QgPSBzZWxmLl96bGV2ZWxMaXN0O1xuXG4gICAgICBpZiAoc21hbGxlciA9PSBudWxsKSB7XG4gICAgICAgIHNtYWxsZXIgPSAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnRlcm1lZGlhdGVMYXllcjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgdmFyIGxheWVyID0gc2VsZi5fbGF5ZXJzW3pdO1xuXG4gICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgeiA+IHNtYWxsZXIgJiYgeiA8IGxhcmdlcikge1xuICAgICAgICAgIGludGVybWVkaWF0ZUxheWVyID0gbGF5ZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGludGVybWVkaWF0ZUxheWVyICYmIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKSB7XG4gICAgICAgIGltYWdlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIucmVuZGVyVG9DYW52YXMoaW1hZ2VMYXllci5jdHgpO1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG5cbiAgICAgIGlmIChlbC56bGV2ZWwgIT09IHpsZXZlbCkge1xuICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBlbC56bGV2ZWwpO1xuICAgICAgICB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgIH1cblxuICAgIGZpbmRBbmREcmF3T3RoZXJMYXllcih6bGV2ZWwsIEluZmluaXR5KTtcbiAgICByZXR1cm4gaW1hZ2VMYXllci5kb207XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlue7mOWbvuWMuuWfn+mrmOW6plxuICAgKi9cbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfSxcbiAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICB2YXIgd2ggPSBbJ3dpZHRoJywgJ2hlaWdodCddW3doSWR4XTtcbiAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIHBsdCA9IFsncGFkZGluZ0xlZnQnLCAncGFkZGluZ1RvcCddW3doSWR4XTtcbiAgICB2YXIgcHJiID0gWydwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbSddW3doSWR4XTtcblxuICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG9wdHNbd2hdKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDsgLy8gSUU4IGRvZXMgbm90IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSwgYnV0IGl0IHVzZSBWTUwuXG5cbiAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcbiAgICByZXR1cm4gKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKSAtIChwYXJzZUludDEwKHN0bFtwbHRdKSB8fCAwKSAtIChwYXJzZUludDEwKHN0bFtwcmJdKSB8fCAwKSB8IDA7XG4gIH0sXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAocGF0aCwgZHByKSB7XG4gICAgZHByID0gZHByIHx8IHRoaXMuZHByO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHBhdGguc3R5bGU7XG4gICAgdmFyIHNoYWRvd0JsdXJTaXplID0gc3R5bGUuc2hhZG93Qmx1cjtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFg7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZO1xuICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmxpbmVXaWR0aCA6IDA7XG4gICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgcmlnaHRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciB0b3BNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoICsgbGVmdE1hcmdpbiArIHJpZ2h0TWFyZ2luO1xuICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCArIHRvcE1hcmdpbiArIGJvdHRvbU1hcmdpbjtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHguZHByID0gZHByO1xuICAgIHZhciBwYXRoVHJhbnNmb3JtID0ge1xuICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgIHNjYWxlOiBwYXRoLnNjYWxlXG4gICAgfTtcbiAgICBwYXRoLnBvc2l0aW9uID0gW2xlZnRNYXJnaW4gLSByZWN0LngsIHRvcE1hcmdpbiAtIHJlY3QueV07XG4gICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICBwYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgSW1hZ2VTaGFwZSA9IEltYWdlO1xuICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5zY2FsZSA9IHBhdGguc2NhbGUgPSBwYXRoVHJhbnNmb3JtLnNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBpbWdTaGFwZTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFBhaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///356\n");

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(230);\n\nvar env = __webpack_require__(239);\n\nvar Group = __webpack_require__(259);\n\nvar timsort = __webpack_require__(267);\n\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n * 内容仓库 (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * 返回所有图形的绘制队列\n   * @param {boolean} [update=false] 是否在返回前更新该数组\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n   *\n   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * 更新图形的绘制队列。\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * 添加图形(Shape)或者组(Group)到根节点\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * 删除指定的图形(Shape)或者组(Group)\n   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清空并且释放Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzPzdlOTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIEdyb3VwID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0dyb3VwXCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuLy8gVXNlIHRpbXNvcnQgYmVjYXVzZSBpbiBtb3N0IGNhc2UgZWxlbWVudHMgYXJlIHBhcnRpYWxseSBzb3J0ZWRcbi8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbmZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgLy8gICAgIC8vIEZJWE1FIFNsb3cgaGFzIHJlbmRlcmlkeCBjb21wYXJlXG4gICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAvLyAgICAgcmV0dXJuIGEuX19yZW5kZXJpZHggLSBiLl9fcmVuZGVyaWR4O1xuICAgICAgLy8gfVxuICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgIH1cblxuICAgIHJldHVybiBhLnogLSBiLno7XG4gIH1cblxuICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbn1cbi8qKlxuICog5YaF5a655LuT5bqTIChNKVxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1N0b3JhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB0aGlzLl9yb290cyA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG59O1xuXG5TdG9yYWdlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKlxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICpcbiAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAqL1xuICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgIGluY2x1ZGVJZ25vcmUgPSBpbmNsdWRlSWdub3JlIHx8IGZhbHNlO1xuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheUxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOabtOaWsOWbvuW9oueahOe7mOWItumYn+WIl+OAglxuICAgKiDmr4/mrKHnu5jliLbliY3pg73kvJrosIPnlKjvvIzor6Xmlrnms5XkvJrlhYjmt7HluqbkvJjlhYjpgY3ljobmlbTkuKrmoJHvvIzmm7TmlrDmiYDmnIlHcm91cOWSjFNoYXBl55qE5Y+Y5o2i5bm25LiU5oqK5omA5pyJ5Y+v6KeB55qEU2hhcGXkv53lrZjliLDmlbDnu4TkuK3vvIxcbiAgICog5pyA5ZCO5qC55o2u57uY5Yi255qE5LyY5YWI57qn77yIemxldmVsID4geiA+IOaPkuWFpemhuuW6j++8ieaOkuW6j+W+l+WIsOe7mOWItumYn+WIl1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hFxuICAgKi9cbiAgdXBkYXRlRGlzcGxheUxpc3Q6IGZ1bmN0aW9uIChpbmNsdWRlSWdub3JlKSB7XG4gICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuX2Rpc3BsYXlMaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheUxpc3QubGVuZ3RoID0gdGhpcy5fZGlzcGxheUxpc3RMZW47IC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgLy8gfVxuICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG5cbiAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICB9LFxuICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgIGVsLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGVsLmFmdGVyVXBkYXRlKCk7XG4gICAgdmFyIHVzZXJTZXRDbGlwUGF0aCA9IGVsLmNsaXBQYXRoO1xuXG4gICAgaWYgKHVzZXJTZXRDbGlwUGF0aCkge1xuICAgICAgLy8gRklYTUUg5pWI546H5b2x5ZONXG4gICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xpcFBhdGggPSB1c2VyU2V0Q2xpcFBhdGg7XG4gICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDsgLy8gUmVjdXJzaXZlbHkgYWRkIGNsaXAgcGF0aFxuXG4gICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG4gICAgICAgIHBhcmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoO1xuICAgICAgICBjdXJyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGguY2xpcFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLl9jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTsgLy8gRm9yY2UgdG8gbWFyayBhcyBkaXJ0eSBpZiBncm91cCBpcyBkaXJ0eVxuICAgICAgICAvLyBGSVhNRSBfX2RpcnR5UGF0aCA/XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBjaGlsZC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKGNoaWxkLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgfSAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcblxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5fX3N0b3JhZ2UgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgZWwuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2UodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuXG4gICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICovXG4gIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuXG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuZGVsRnJvbVN0b3JhZ2UoZWwpO1xuXG4gICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFkZFRvU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJMaXN0ID0gdGhpcy5fcm9vdHMgPSBudWxsO1xuICB9LFxuICBkaXNwbGF5YWJsZVNvcnRGdW5jOiBzaGFwZUNvbXBhcmVGdW5jXG59O1xudmFyIF9kZWZhdWx0ID0gU3RvcmFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///357\n");

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

eval("var util = __webpack_require__(230);\n\nvar _event = __webpack_require__(255);\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = __webpack_require__(283);\n\nvar Animator = __webpack_require__(282);\n\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * 添加 clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * 添加 animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * 删除动画片段\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * 开始运行动画\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * 停止运行动画\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * 清除所有动画片段\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] 是否循环播放动画\n   * @param  {Function} [options.getter=null]\n   *         如果指定getter函数，会通过getter函数取属性值\n   * @param  {Function} [options.setter=null]\n   *         如果指定setter函数，会通过setter函数设置属性值\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzPzg3NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBEaXNwYXRjaGVyID0gX2V2ZW50LkRpc3BhdGNoZXI7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuL0FuaW1hdG9yXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25mcmFtZV1cbiAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgeDogMTAwLFxuICogICAgICAgICB5OiAxMDBcbiAqICAgICB9O1xuICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDUwMCxcbiAqICAgICAgICAgICAgIHk6IDUwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAud2hlbigyMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAqL1xudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24gKCkge307IC8vIHByaXZhdGUgcHJvcGVydGllc1xuXG5cbiAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB0aGlzLl90aW1lO1xuICB0aGlzLl9wYXVzZWRUaW1lO1xuICB0aGlzLl9wYXVzZVN0YXJ0O1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGlvbixcblxuICAvKipcbiAgICog5re75YqgIGNsaXBcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcy5wdXNoKGNsaXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICByZW1vdmVDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG5cbiAgICBhbmltYXRvci5hbmltYXRpb24gPSBudWxsO1xuICB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpOyAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgbGVuLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXVzZVxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3VtZVxuICAgKi9cbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgKi9cbiAgLy8gVE9ETyBHYXBcbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIG9wdGlvbnMubG9vcCwgb3B0aW9ucy5nZXR0ZXIsIG9wdGlvbnMuc2V0dGVyKTtcbiAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn07XG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG52YXIgX2RlZmF1bHQgPSBBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///358\n");

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

eval("var easingFuncs = __webpack_require__(360);\n\n/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // 生命周期\n\n  this._life = options.life || 1000; // 延时\n\n  this._delay = options.delay || 0; // 开始时间\n  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\n  this._initialized = false; // 是否循环\n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // 结束\n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // 重新开始周期\n        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n        return 'restart';\n      } // 动画完成将这个控制器标识为待删除\n      // 在Animation.update中进行批量删除\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcz9mZWY5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoXCIuL2Vhc2luZ1wiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5mdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcbiAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7IC8vIOeUn+WRveWRqOacn1xuXG4gIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDsgLy8g5bu25pe2XG5cbiAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7IC8vIOW8gOWni+aXtumXtFxuICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuXG4gIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7IC8vIOaYr+WQpuW+queOr1xuXG4gIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG4gIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2xpcCxcbiAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUsIGRlbHRhVGltZSkge1xuICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgIC8vIFBFTkRJTkdcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTsgLy8g6L+Y5rKh5byA5aeLXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG4gICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbicgPyBlYXNpbmdGdW5jKHBlcmNlbnQpIDogcGVyY2VudDtcbiAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpOyAvLyDnu5PmnZ9cblxuICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KGdsb2JhbFRpbWUpOyAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcblxuICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgfSAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcblxuXG4gICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcblxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgfVxuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2xpcDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///359\n");

/***/ }),
/* 360 */
/***/ (function(module, exports) {

eval("/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzPzY0YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbnZhciBlYXNpbmcgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbiAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gLS1rICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgfSxcbiAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgfSxcbiAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gIH0sXG4gIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1rICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICB9LFxuICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzO1xuICAgIHZhciBhID0gMC4xO1xuICAgIHZhciBwID0gMC40O1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChrID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gIH0sXG4gIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gIH0sXG4gIC8vIOWIm+W7uuW8uei3s+aViOaenFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgIH0gZWxzZSBpZiAoayA8IDIgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMS41IC8gMi43NSkgKiBrICsgMC43NTtcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi4yNSAvIDIuNzUpICogayArIDAuOTM3NTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDAuNSkge1xuICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IGVhc2luZztcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///360\n");

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _util = __webpack_require__(284);\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * 圆弧描边包含判断\n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcz83MzY3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///361\n");

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

eval("var curve = __webpack_require__(251);\n\n/**\n * 三次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzP2I5MGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///362\n");

/***/ }),
/* 363 */
/***/ (function(module, exports) {

eval("/**\n * 线段包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanM/NDMyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOe6v+auteWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHZhciBfYSA9IDA7XG4gIHZhciBfYiA9IHgwOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoeDAgIT09IHgxKSB7XG4gICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgfVxuXG4gIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG5cbiAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcblxuICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///363\n");

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

eval("var PathProxy = __webpack_require__(260);\n\nvar line = __webpack_require__(363);\n\nvar cubic = __webpack_require__(362);\n\nvar quadratic = __webpack_require__(366);\n\nvar arc = __webpack_require__(361);\n\nvar _util = __webpack_require__(284);\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = __webpack_require__(251);\n\nvar windingLine = __webpack_require__(285);\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanM/MmU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgbGluZSA9IHJlcXVpcmUoXCIuL2xpbmVcIik7XG5cbnZhciBjdWJpYyA9IHJlcXVpcmUoXCIuL2N1YmljXCIpO1xuXG52YXIgcXVhZHJhdGljID0gcmVxdWlyZShcIi4vcXVhZHJhdGljXCIpO1xuXG52YXIgYXJjID0gcmVxdWlyZShcIi4vYXJjXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgbm9ybWFsaXplUmFkaWFuID0gX3V0aWwubm9ybWFsaXplUmFkaWFuO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZShcIi4vd2luZGluZ0xpbmVcIik7XG5cbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIEVQU0lMT04gPSAxZS00O1xuXG5mdW5jdGlvbiBpc0Fyb3VuZEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IEVQU0lMT047XG59IC8vIOS4tOaXtuaVsOe7hFxuXG5cbnZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbnZhciBleHRyZW1hID0gWy0xLCAtMV07XG5cbmZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gIGV4dHJlbWFbMV0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIHdpbmRpbmdDdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiAmJiB5ID4geTMgfHwgeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIgJiYgeSA8IHkzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcblxuICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSAwO1xuICAgIHZhciBuRXh0cmVtYSA9IC0xO1xuICAgIHZhciB5MF8sIHkxXztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcm9vdHNbaV07IC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuXG4gICAgICB2YXIgdW5pdCA9IHQgPT09IDAgfHwgdCA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcblxuICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuXG4gICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG5cbiAgICAgICAgaWYgKG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgdyArPSB5MV8gPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcblxuICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHQgPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKTtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICB2YXIgdyA9IDA7XG4gICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICB2YXIgdW5pdCA9IHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxID8gMC41IDogMTtcbiAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuXG4gICAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb290c1tpXSA8IHQpIHtcbiAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgdmFyIHVuaXQgPSByb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geTIgPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICB9XG4gIH1cbn0gLy8gVE9ET1xuLy8gQXJjIOaXi+i9rFxuXG5cbmZ1bmN0aW9uIHdpbmRpbmdBcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgeCwgeSkge1xuICB5IC09IGN5O1xuXG4gIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gIHJvb3RzWzBdID0gLXRtcDtcbiAgcm9vdHNbMV0gPSB0bXA7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICBpZiAoeCA+PSByb290c1swXSArIGN4ICYmIHggPD0gcm9vdHNbMV0gKyBjeCkge1xuICAgICAgcmV0dXJuIGRpcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciB3ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuXG4gICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgZGlyID0gLWRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgKz0gZGlyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG5mdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gIHZhciB3ID0gMDtcbiAgdmFyIHhpID0gMDtcbiAgdmFyIHlpID0gMDtcbiAgdmFyIHgwID0gMDtcbiAgdmFyIHkwID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgIHZhciBjbWQgPSBkYXRhW2krK107IC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcblxuICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICBpZiAoIWlzU3Ryb2tlKSB7XG4gICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgfSAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyB9XG5cbiAgICB9XG5cbiAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgLy9cbiAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICB4aSA9IGRhdGFbaV07XG4gICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgeDAgPSB4aTtcbiAgICAgIHkwID0geWk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5PVEUg5Zyo56ys5LiA5Liq5ZG95Luk5Li6IEwsIEMsIFEg55qE5pe25YCZ5Lya6K6h566X5Ye6IE5hTlxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0N1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5OyAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuXG4gICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgfSAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuXG5cbiAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCBfeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBfeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IE1hdGguY29zKHRoZXRhICsgZFRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHlpID0gTWF0aC5zaW4odGhldGEgKyBkVGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MCwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MCwgeTEsIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MSwgeTAsIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsb3NlIGEgc3VicGF0aFxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpOyAvLyDlpoLmnpzooqvku7vkvZXkuIDkuKogc3VicGF0aCDljIXlkKtcbiAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNTdHJva2UgJiYgIWlzQXJvdW5kRXF1YWwoeWksIHkwKSkge1xuICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gIH1cblxuICByZXR1cm4gdyAhPT0gMDtcbn1cblxuZnVuY3Rpb24gY29udGFpbihwYXRoRGF0YSwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIDAsIGZhbHNlLCB4LCB5KTtcbn1cblxuZnVuY3Rpb24gY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbn1cblxuZXhwb3J0cy5jb250YWluID0gY29udGFpbjtcbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///364\n");

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

eval("var windingLine = __webpack_require__(285);\n\nvar EPSILON = 1e-8;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n\nfunction contain(points, x, y) {\n  var w = 0;\n  var p = points[0];\n\n  if (!p) {\n    return false;\n  }\n\n  for (var i = 1; i < points.length; i++) {\n    var p2 = points[i];\n    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n    p = p2;\n  } // Close polygon\n\n\n  var p0 = points[0];\n\n  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {\n    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n  }\n\n  return w !== 0;\n}\n\nexports.contain = contain;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3BvbHlnb24uanM/MWY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKFwiLi93aW5kaW5nTGluZVwiKTtcblxudmFyIEVQU0lMT04gPSAxZS04O1xuXG5mdW5jdGlvbiBpc0Fyb3VuZEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IEVQU0lMT047XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocG9pbnRzLCB4LCB5KSB7XG4gIHZhciB3ID0gMDtcbiAgdmFyIHAgPSBwb2ludHNbMF07XG5cbiAgaWYgKCFwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcDIgPSBwb2ludHNbaV07XG4gICAgdyArPSB3aW5kaW5nTGluZShwWzBdLCBwWzFdLCBwMlswXSwgcDJbMV0sIHgsIHkpO1xuICAgIHAgPSBwMjtcbiAgfSAvLyBDbG9zZSBwb2x5Z29uXG5cblxuICB2YXIgcDAgPSBwb2ludHNbMF07XG5cbiAgaWYgKCFpc0Fyb3VuZEVxdWFsKHBbMF0sIHAwWzBdKSB8fCAhaXNBcm91bmRFcXVhbChwWzFdLCBwMFsxXSkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHBbMF0sIHBbMV0sIHAwWzBdLCBwMFsxXSwgeCwgeSk7XG4gIH1cblxuICByZXR1cm4gdyAhPT0gMDtcbn1cblxuZXhwb3J0cy5jb250YWluID0gY29udGFpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///365\n");

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _curve = __webpack_require__(251);\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * 二次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcz9mNTg5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1Byb2plY3RQb2ludCA9IF9jdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQ7XG5cbi8qKlxuICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG51bGwpO1xuICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///366\n");

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

eval("var eventUtil = __webpack_require__(255);\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanM/MDBmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXZlbnRVdGlsID0gcmVxdWlyZShcIi4vZXZlbnRcIik7XG5cbi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG52YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIHRoaXMuX3RyYWNrID0gW107XG59O1xuXG5HZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICB0b3VjaGVzOiBbXSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgfSxcbiAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgcmV0dXJuIFsocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMl07XG59XG5cbnZhciByZWNvZ25pemVycyA9IHtcbiAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgaWYgKHBpbmNoUHJlICYmIHBpbmNoUHJlLmxlbmd0aCA+IDEgJiYgcGluY2hFbmQgJiYgcGluY2hFbmQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG4gICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcbiAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG5cbn07XG52YXIgX2RlZmF1bHQgPSBHZXN0dXJlTWdyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///367\n");

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _event = __webpack_require__(255);\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = __webpack_require__(230);\n\nvar Eventful = __webpack_require__(252);\n\nvar env = __webpack_require__(239);\n\nvar GestureMgr = __webpack_require__(367);\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // 忽略包含在root中的dom引起的mouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch开始响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch移动响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch结束响应函数\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * 为控制类实例初始化dom 事件处理函数\n *\n * @inner\n * @param {module:zrender/Handler} instance 控制类实例\n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzPzJmYzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5hZGRFdmVudExpc3RlbmVyO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBfZXZlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbnZhciBub3JtYWxpemVFdmVudCA9IF9ldmVudC5ub3JtYWxpemVFdmVudDtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIEdlc3R1cmVNZ3IgPSByZXF1aXJlKFwiLi4vY29yZS9HZXN0dXJlTWdyXCIpO1xuXG52YXIgVE9VQ0hfQ0xJQ0tfREVMQVkgPSAzMDA7XG52YXIgbW91c2VIYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG52YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ107XG52YXIgcG9pbnRlckV2ZW50TmFtZXMgPSB7XG4gIHBvaW50ZXJkb3duOiAxLFxuICBwb2ludGVydXA6IDEsXG4gIHBvaW50ZXJtb3ZlOiAxLFxuICBwb2ludGVyb3V0OiAxXG59O1xudmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSB6clV0aWwubWFwKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgbm0gPSBuYW1lLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcbiAgcmV0dXJuIHBvaW50ZXJFdmVudE5hbWVzW25tXSA/IG5tIDogbmFtZTtcbn0pO1xuXG5mdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ21vdXNld2hlZWwnICYmIGVudi5icm93c2VyLmZpcmVmb3ggPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0dlc3R1cmUocHJveHksIGV2ZW50LCBzdGFnZSkge1xuICB2YXIgZ2VzdHVyZU1nciA9IHByb3h5Ll9nZXN0dXJlTWdyO1xuICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG4gIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKGV2ZW50LCBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LCBwcm94eS5kb20pO1xuICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpOyAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuXG4gIGlmIChnZXN0dXJlSW5mbykge1xuICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe1xuICAgICAgdGFyZ2V0OiBnZXN0dXJlSW5mby50YXJnZXRcbiAgICB9LCB0eXBlLCBnZXN0dXJlSW5mby5ldmVudCk7XG4gIH1cbn0gLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4vLyAgICAgaWYgKGV2ZW50LnRyYW5zbGF0aW9uWCB8fCBldmVudC50cmFuc2xhdGlvblkpIHtcbi8vICAgICAgICAgLy8gbW91c2Vtb3ZlIGlzIGNhcnJpZWQgYnkgTVNHZXN0dXJlIHRvIHJlZHVjZSB0aGUgc2Vuc2l0aXZpdHkuXG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vICAgICBpZiAoZXZlbnQuc2NhbGUgIT09IDEpIHtcbi8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbi8vICAgICAgICAgZXZlbnQucGluY2hZID0gZXZlbnQub2Zmc2V0WTtcbi8vICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IGV2ZW50LnNjYWxlO1xuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuLy8gICAgIH1cbi8vIH1cblxuLyoqXG4gKiBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gKiBAc2VlIDxodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqcy9ibG9iL21hc3Rlci9zcmMvaGFuZC5iYXNlLmpzPlxuICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAqIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAqIFJlc3VsdDogQmxvY2tpbmcgTW91c2UgRXZlbnRzIGZvciA3MDBtcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgfSwgNzAwKTtcbn1cblxudmFyIGRvbUhhbmRsZXJzID0ge1xuICAvKipcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSkge1xuICAgICAgICAvLyDlv73nlaXljIXlkKvlnKhyb2905Lit55qEZG9t5byV6LW355qEbW91c2VPdXRcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOW8gOWni+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIERlZmF1bHQgbW91c2UgYmVoYXZpb3VyIHNob3VsZCBub3QgYmUgZGlzYWJsZWQgaGVyZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTsgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAvLyBiZSB0cmlnZ2VyZWQsIGFuZCBtdXN0IGJlZm9yZSBgbW91c2Vkb3duYCB0cmlnZ2VyZWQuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo56e75Yqo5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdjaGFuZ2UnKTsgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQsIGJlY2F1c2UgbW91c2UgbW92ZSBhbmQgcGluY2ggbWF5XG4gICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo57uT5p2f5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2VuZCcpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7IC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgLy8gdHJpZ2dlcmVkIGluIGB0b3VjaHN0YXJ0YC4gVGhpcyBzZWVtcyB0byBiZSBpbGxvZ2ljYWwsIGJ1dCBieSB0aGlzIG1lY2hhbmlzbSxcbiAgICAvLyB3ZSBjYW4gY29udmVuaWVudGx5IGltcGxlbWVudCBcImhvdmVyIHN0eWxlXCIgaW4gYm90aCBQQyBhbmQgdG91Y2ggZGV2aWNlIGp1c3RcbiAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAvLyB0byByZW1vdmUgXCJob3ZlciBzdHlsZVwiIG9uIGFuIGVsZW1lbnQsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29kZSBmb3JcbiAgICAvLyBjb21wYXRpYmlsaXR5LiAoYG1vdXNlb3V0YCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgaW4gYHRvdWNoZW5kYCwgc28gXCJob3ZlclxuICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcbiAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cblxuICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICBkb21IYW5kbGVycy5jbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuICBwb2ludGVyZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpOyAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAvLyB9XG4gIH0sXG4gIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIHBvaW50ZXJtb3ZlIGlzIHNvIHNlbnNpdGl2ZSB0aGF0IGl0IGFsd2F5cyB0cmlnZ2VyZWQgd2hlblxuICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAvLyB1cHBlciBhcHBsaWNhdGlvbi4gU28sIHdlIGRvbnQgc3VwcG9ydCBtb3VzZW1vdmUgb24gTVMgdG91Y2hcbiAgICAvLyBkZXZpY2UgeWV0LlxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgcG9pbnRlcnVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuICB9LFxuICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwb2ludGVyb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGFwIG9uIHRvdWNoIHNjcmVlblxuICAgIC8vIChJRTExKy9FZGdlIG9uIE1TIFN1cmZhY2UpIGFmdGVyIGNsaWNrIGV2ZW50IHRyaWdnZXJlZCxcbiAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgLy8gaW4gdG91Y2hlbmQuIFNvIHdlIHVuaWZ5IHRoZW0uXG4gICAgLy8gKGNoZWNrIGRvbUhhbmRsZXJzLnRvdWNoZW5kIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbilcbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlb3V0LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSB7XG4gIHZhciBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICByZXR1cm4gcG9pbnRlclR5cGUgPT09ICdwZW4nIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufSAvLyBmdW5jdGlvbiB1c2VNU0d1ZXN0dXJlKGhhbmRsZXJQcm94eSwgZXZlbnQpIHtcbi8vICAgICByZXR1cm4gaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSAmJiAhIWhhbmRsZXJQcm94eS5fbXNHZXN0dXJlO1xuLy8gfVxuLy8gQ29tbW9uIGhhbmRsZXJzXG5cblxuenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gIH07XG59KTtcbi8qKlxuICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICpcbiAqIEBpbm5lclxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAqL1xuXG5mdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gocG9pbnRlckhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcbiAgenJVdGlsLmVhY2gobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0gbWFrZU1vdXNlSGFuZGxlcihkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICB9KTtcblxuICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gSGFuZGxlckRvbVByb3h5KGRvbSkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hUaW1lcjtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAqL1xuXG4gIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICBpbml0RG9tSGFuZGxlcih0aGlzKTtcblxuICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBPbmx5IElFMTErL0VkZ2VcbiAgICAvLyAxLiBPbiBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIChlLmcuLCBNUyBTdXJmYWNlIGFuZCBsZW5vdm8gWDI0MCksXG4gICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIGl0IHByb2JhYmxlbHkgb25seSB0cmlnZ2VyIG1vdXNlZG93biBidXQgbm8gbW91c2V1cCB3aGVuIHRhcCBvblxuICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgIC8vIFNvIHdlIHVzZSBwb2ludGVyIGV2ZW50IHRvIGJvdGggZGV0ZWN0IHRvdWNoIGdlc3R1cmUgYW5kIG1vdXNlIGJlaGF2aW9yLlxuICAgIG1vdW50SGFuZGxlcnMocG9pbnRlckhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEZJWE1FXG4gICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAvLyB3aGljaCBkb2VzIG5vdCBwcmV2ZW50IGRlZnVhdWx0IGJlaGF2aW9yIG9jY2FzaW9uYWxseSAod2hpY2ggbWF5IGNhdXNlIHZpZXcgcG9ydFxuICAgIC8vIHpvb21lZCBpbiBidXQgdXNlIGNhbiBub3Qgem9vbSBpdCBiYWNrKS4gQW5kIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgZG9lcyBub3Qgd29yay5cbiAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgLy8gdG91Y2ggc2NyZWVuLiBBbmQgd2Ugb25seSBzdXBwb3J0IGNsaWNrIGJlaGF2aW9yIG9uIE1TIHRvdWNoIHNjcmVlbiBub3cuXG4gICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgIC8vIFdlIGRvbnQgc3VwcG9ydCB0b3VjaCBvbiBJRSBvbiB3aW43LlxuICAgIC8vIFNlZSA8aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0Myh2PXZzLjg1KS5hc3B4PlxuICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICh0aGlzLl9tc0dlc3R1cmUgPSBuZXcgTVNHZXN0dXJlKCkpLnRhcmdldCA9IGRvbTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgLy8gICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdNU0dlc3R1cmVDaGFuZ2UnLCBvbk1TR2VzdHVyZUNoYW5nZSk7XG4gICAgLy8gfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICB9IC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgLy8gYW5kIGxlbm92byBYMjQwLCBAc2VlICMyMzUwKSwgd2UgbWFrZSBtb3VzZSBldmVudCBiZSBhbHdheXMgbGlzdGVuZWQsIG90aGVyd2lzZVxuICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAvLyBtb3VzZWV2ZW50IGFmdGVyIHRvdWNoIGV2ZW50IHRyaWdnZXJlZCwgc2VlIGBzZXRUb3VjaFRpbWVyYC5cblxuXG4gICAgbW91bnRIYW5kbGVycyhtb3VzZUhhbmRsZXJOYW1lcywgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEhhbmRsZXJzKGhhbmRsZXJOYW1lcywgaW5zdGFuY2UpIHtcbiAgICB6clV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0pO1xuICAgIH0sIGluc3RhbmNlKTtcbiAgfVxufVxuXG52YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gaGFuZGxlck5hbWVzW2ldO1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICB9XG59O1xuXG5oYW5kbGVyRG9tUHJveHlQcm90by5zZXRDdXJzb3IgPSBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgdGhpcy5kb20uc3R5bGUuY3Vyc29yID0gY3Vyc29yU3R5bGUgfHwgJ2RlZmF1bHQnO1xufTtcblxuenJVdGlsLm1peGluKEhhbmRsZXJEb21Qcm94eSwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlckRvbVByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///368\n");

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\n// CompoundPath to improve performance\nvar _default = Path.extend({\n  type: 'compound',\n  shape: {\n    paths: null\n  },\n  _updatePathDirty: function () {\n    var dirtyPath = this.__dirtyPath;\n    var paths = this.shape.paths;\n\n    for (var i = 0; i < paths.length; i++) {\n      // Mark as dirty if any subpath is dirty\n      dirtyPath = dirtyPath || paths[i].__dirtyPath;\n    }\n\n    this.__dirtyPath = dirtyPath;\n    this.__dirty = this.__dirty || dirtyPath;\n  },\n  beforeBrush: function () {\n    this._updatePathDirty();\n\n    var paths = this.shape.paths || [];\n    var scale = this.getGlobalScale(); // Update path scale\n\n    for (var i = 0; i < paths.length; i++) {\n      if (!paths[i].path) {\n        paths[i].createPathProxy();\n      }\n\n      paths[i].path.setScale(scale[0], scale[1]);\n    }\n  },\n  buildPath: function (ctx, shape) {\n    var paths = shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].buildPath(ctx, paths[i].shape, true);\n    }\n  },\n  afterBrush: function () {\n    var paths = this.shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].__dirtyPath = false;\n    }\n  },\n  getBoundingRect: function () {\n    this._updatePathDirty();\n\n    return Path.prototype.getBoundingRect.call(this);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qcz84NjM2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcblxuLy8gQ29tcG91bmRQYXRoIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NvbXBvdW5kJyxcbiAgc2hhcGU6IHtcbiAgICBwYXRoczogbnVsbFxuICB9LFxuICBfdXBkYXRlUGF0aERpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpcnR5UGF0aCA9IHRoaXMuX19kaXJ0eVBhdGg7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE1hcmsgYXMgZGlydHkgaWYgYW55IHN1YnBhdGggaXMgZGlydHlcbiAgICAgIGRpcnR5UGF0aCA9IGRpcnR5UGF0aCB8fCBwYXRoc1tpXS5fX2RpcnR5UGF0aDtcbiAgICB9XG5cbiAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgIHRoaXMuX19kaXJ0eSA9IHRoaXMuX19kaXJ0eSB8fCBkaXJ0eVBhdGg7XG4gIH0sXG4gIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlUGF0aERpcnR5KCk7XG5cbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTsgLy8gVXBkYXRlIHBhdGggc2NhbGVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcGF0aHNbaV0ucGF0aCkge1xuICAgICAgICBwYXRoc1tpXS5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgcGF0aHNbaV0ucGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgIH1cbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciBwYXRocyA9IHNoYXBlLnBhdGhzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aHNbaV0uYnVpbGRQYXRoKGN0eCwgcGF0aHNbaV0uc2hhcGUsIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHMgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXRoc1tpXS5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlUGF0aERpcnR5KCk7XG5cbiAgICByZXR1cm4gUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0LmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0NvbXBvdW5kUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///369\n");

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Gradient = __webpack_require__(269);\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzPzQyNTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdsaW5lYXInLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcbiAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG4gIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ2xpbmVhcic7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IExpbmVhckdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///370\n");

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar Gradient = __webpack_require__(269);\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzPzg5NWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG4gIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncmFkaWFsJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5SYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gUmFkaWFsR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///371\n");

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(268);\n\nvar zrUtil = __webpack_require__(230);\n\nvar textContain = __webpack_require__(250);\n\nvar textHelper = __webpack_require__(295);\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanM/MzI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIEFsd2F5cyBiaW5kIHN0eWxlXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS5yaWNoKTtcbiAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICBpZiAodGV4dEhlbHBlci5nZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKSkge1xuICAgICAgICB2YXIgdyA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMzcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///372\n");

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _vector = __webpack_require__(236);\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * 贝塞尔平滑曲线\n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points 线段顶点数组\n * @param {number} smooth 平滑等级, 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n *                           整个折线的包围盒做一个并集用来约束控制点。\n * @param {Array} 计算出来的控制点数组\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanM/MjcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyTWluID0gX3ZlY3Rvci5taW47XG52YXIgdjJNYXggPSBfdmVjdG9yLm1heDtcbnZhciB2MlNjYWxlID0gX3ZlY3Rvci5zY2FsZTtcbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcbnZhciB2MkFkZCA9IF92ZWN0b3IuYWRkO1xudmFyIHYyQ2xvbmUgPSBfdmVjdG9yLmNsb25lO1xudmFyIHYyU3ViID0gX3ZlY3Rvci5zdWI7XG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgdmFyIGNwcyA9IFtdO1xuICB2YXIgdiA9IFtdO1xuICB2YXIgdjEgPSBbXTtcbiAgdmFyIHYyID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBtaW4sIG1heDtcblxuICBpZiAoY29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgIH0gLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG5cblxuICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKHYyQ2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2MlN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7IC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcblxuICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///373\n");

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _vector = __webpack_require__(236);\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points 线段顶点数组\n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanM/YTE3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyRGlzdGFuY2UgPSBfdmVjdG9yLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIGlzTG9vcCkge1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJldCA9IFtdO1xuICB2YXIgZGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaXN0YW5jZSArPSB2MkRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gIH1cblxuICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG4gICAgdmFyIHcgPSBwb3MgLSBpZHg7XG4gICAgdmFyIHAwO1xuICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG5cbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgIH1cblxuICAgIHZhciB3MiA9IHcgKiB3O1xuICAgIHZhciB3MyA9IHcgKiB3MjtcbiAgICByZXQucHVzaChbaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///374\n");

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

eval("var textHelper = __webpack_require__(295);\n\nvar BoundingRect = __webpack_require__(244);\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzPzk0ZWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgY3R4LnNhdmUoKTsgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFzdHlsZS50cmFuc2Zvcm1UZXh0KSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB9IC8vIHRyYW5zZm9ybVRleHQgYW5kIHRleHRSb3RhdGlvbiBjYW4gbm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuXG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBSZWN0VGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDM3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///375\n");

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\n/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcz8yOTk0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYXJjJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///376\n");

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar vec2 = __webpack_require__(236);\n\nvar _curve = __webpack_require__(251);\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzP2Y1YzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///377\n");

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qcz8wNzZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NpcmNsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgfSAvLyBlbHNlIHtcbiAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuXG5cbiAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///378\n");

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\n/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanM/NzcyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIC8vIEVuZCBwb2ludFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICB9XG5cbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICByZXR1cm4gW3NoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCwgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///379\n");

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar polyHelper = __webpack_require__(293);\n\n/**\n * 多边形\n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanM/ZDM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///380\n");

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar polyHelper = __webpack_require__(293);\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzPzNjZGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWxpbmUnLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///381\n");

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar roundRectHelper = __webpack_require__(294);\n\n/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanM/M2IzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9yb3VuZFJlY3RcIik7XG5cbi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzaGFwZToge1xuICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgcjogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///382\n");

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\n/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanM/YjcxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyaW5nJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHIwOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDM4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///383\n");

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar fixClipWithShadow = __webpack_require__(303);\n\n/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcz85NzY3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///384\n");

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Animator = __webpack_require__(282);\n\nvar log = __webpack_require__(289);\n\nvar _util = __webpack_require__(230);\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzPzM1Y2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4uL2FuaW1hdGlvbi9BbmltYXRvclwiKTtcblxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IF91dGlsLmlzRnVuY3Rpb247XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xudmFyIGluZGV4T2YgPSBfdXRpbC5pbmRleE9mO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xufTtcblxuQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gIC8qKlxuICAgKiDliqjnlLtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZmV0Y2ggdmFsdWUgZnJvbSBvYmplY3QsIGxpa2UgJ2EuYi5jJy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKiBAZXhhbXBsZTpcbiAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICogICAgICAgICAuc3RhcnQoKVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgIHZhciBlbCA9IHRoaXM7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcHJvcCA9IGVsOyAvLyBJZiBhbmltYXRpbmcgc2hhcGVcblxuICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGVsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICBsb2coJ1Byb3BlcnR5IFwiJyArIHBhdGggKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnICsgZWwuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG4gICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgYW5pbWF0b3JzLnNwbGljZShpbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICB9KTtcbiAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7IC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcblxuICAgIGlmICh6cikge1xuICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgIH1cblxuICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICAgKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICAgKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9yY2VBbmltYXRlXSBQcmV2ZW50IHN0b3AgYW5pbWF0aW9uIGFuZCBjYWxsYmFja1xuICAgKiAgICAgICAgaW1tZWRpZW50bHkgd2hlbiB0YXJnZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqL1xuICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSkge1xuICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH0gLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuXG5cbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcblxuICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXkpOyAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcblxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBjb3VudC0tO1xuXG4gICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG5cblxuICAgIGlmICghY291bnQpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uZG9uZShkb25lKS5zdGFydChlYXNpbmcsIGZvcmNlQW5pbWF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMClcbiAgICovXG4gIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3cocGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSwgc291cmNlW25hbWVdLCB0YXJnZXRbbmFtZV0sIHRpbWUsIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdykuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///385\n");

/***/ }),
/* 386 */
/***/ (function(module, exports) {

eval("// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanM/ZmJjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcbmZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcbiAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///386\n");

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(238);\n\nvar PathProxy = __webpack_require__(260);\n\nvar transformPath = __webpack_require__(388);\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL3BhdGguanM/ZGM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///387\n");

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

eval("var PathProxy = __webpack_require__(260);\n\nvar _vector = __webpack_require__(236);\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanM/ZGRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhdGgsIG0pIHtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBjbWQ7XG4gIHZhciBuUG9pbnQ7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGs7XG4gIHZhciBwO1xuICB2YXIgTSA9IENNRC5NO1xuICB2YXIgQyA9IENNRC5DO1xuICB2YXIgTCA9IENNRC5MO1xuICB2YXIgUiA9IENNRC5SO1xuICB2YXIgQSA9IENNRC5BO1xuICB2YXIgUSA9IENNRC5RO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgY21kID0gZGF0YVtpKytdO1xuICAgIGogPSBpO1xuICAgIG5Qb2ludCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBNOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDOlxuICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBROlxuICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBOlxuICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTsgLy8gY3hcblxuICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKz0geDsgLy8gY3lcblxuICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICBkYXRhW2krK10gKz0geTsgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG5cbiAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKj0gc3k7IC8vIFN0YXJ0IGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBlbmQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIEZJWE1FIHBzaVxuXG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFI6XG4gICAgICAgIC8vIHgwLCB5MFxuICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdOyAvLyB4MSwgeTFcblxuICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8gV3JpdGUgYmFja1xuXG4gICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///388\n");

/***/ }),
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_echarts_lib_echarts__ = __webpack_require__(232);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_chart_pie__ = __webpack_require__(444);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_chart_pie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_chart_pie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_title__ = __webpack_require__(334);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_title___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_title__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend__ = __webpack_require__(329);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend__);\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    mounted: function mounted() {\n        this.myChart = __WEBPACK_IMPORTED_MODULE_0_echarts_lib_echarts___default.a.init(document.getElementById('visitorpie'));\n        this.initData();\n    },\n\n    props: ['pieData'],\n    methods: {\n        initData: function initData() {\n            var option = {\n                title: {\n                    text: '用户分布',\n                    subtext: '',\n                    x: 'center'\n                },\n                tooltip: {\n                    trigger: 'item',\n                    formatter: \"{a} <br/>{b} : {c} ({d}%)\"\n                },\n                legend: {\n                    orient: 'vertical',\n                    left: 'left',\n                    data: ['北京', '上海', '深圳', '杭州', '其他']\n                },\n                series: [{\n                    name: '访问来源',\n                    type: 'pie',\n                    radius: '55%',\n                    center: ['50%', '60%'],\n                    data: [{ value: this.pieData.beijing, name: '北京' }, { value: this.pieData.shanghai, name: '上海' }, { value: this.pieData.shenzhen, name: '深圳' }, { value: this.pieData.hangzhou, name: '杭州' }, { value: this.pieData.qita, name: '其他' }],\n                    itemStyle: {\n                        emphasis: {\n                            shadowBlur: 10,\n                            shadowOffsetX: 0,\n                            shadowColor: 'rgba(0, 0, 0, 0.5)'\n                        }\n                    }\n                }]\n            };\n\n            this.myChart.setOption(option);\n        }\n    },\n    watch: {\n        pieData: function pieData() {\n            this.initData();\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3Zpc2l0b3JQaWUudnVlPzM4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJ2aXNpdG9ycGllXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJ2aXNpdG9ycGllXCIgY2xhc3M9XCJcIiBzdHlsZT1cIndpZHRoOiA5MCU7aGVpZ2h0OjQ1MHB4O1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgICBpbXBvcnQgZWNoYXJ0cyBmcm9tICdlY2hhcnRzL2xpYi9lY2hhcnRzJztcbiAgICAvLyDlvJXlhaXmn7Hnirblm75cbiAgICBpbXBvcnQgJ2VjaGFydHMvbGliL2NoYXJ0L3BpZSc7XG4gICAgaW1wb3J0ICdlY2hhcnRzL2xpYi9jb21wb25lbnQvdGl0bGUnO1xuICAgIGltcG9ydCAnZWNoYXJ0cy9saWIvY29tcG9uZW50L2xlZ2VuZCc7XG4gICAgXG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBtb3VudGVkKCl7XG4gICAgICAgICAgICB0aGlzLm15Q2hhcnQgPSBlY2hhcnRzLmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Zpc2l0b3JwaWUnKSk7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiBbJ3BpZURhdGEnXSxcbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgaW5pdERhdGEoKXtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ+eUqOaIt+WIhuW4gycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6J2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogXCJ7YX0gPGJyLz57Yn0gOiB7Y30gKHtkfSUpXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnQ6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbJ+WMl+S6rCcsJ+S4iua1tycsJ+a3seWcsycsJ+adreW3nicsJ+WFtuS7liddXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNlcmllcyA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAn6K6/6Zeu5p2l5rqQJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGllJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgOiAnNTUlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFsnNTAlJywgJzYwJSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWU6dGhpcy5waWVEYXRhLmJlaWppbmcsIG5hbWU6J+WMl+S6rCd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWU6dGhpcy5waWVEYXRhLnNoYW5naGFpLCBuYW1lOifkuIrmtbcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlOnRoaXMucGllRGF0YS5zaGVuemhlbiwgbmFtZTon5rex5ZyzJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWx1ZTp0aGlzLnBpZURhdGEuaGFuZ3pob3UsIG5hbWU6J+adreW3nid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWU6dGhpcy5waWVEYXRhLnFpdGEsIG5hbWU6J+WFtuS7lid9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMubXlDaGFydC5zZXRPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2F0Y2g6IHtcbiAgICAgICAgICAgIHBpZURhdGE6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdERhdGEoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi9zdHlsZS9taXhpbic7XG4gICAgLnZpc2l0b3JwaWV7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdmlzaXRvclBpZS52dWU/NTM3MzJmODEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFaQTtBQWhCQTtBQUNBO0FBc0NBO0FBQ0E7QUExQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQWxEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///406\n");

/***/ }),
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_headTop__ = __webpack_require__(241);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_headTop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__components_headTop__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_visitorPie__ = __webpack_require__(505);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_visitorPie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__components_visitorPie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__api_getData__ = __webpack_require__(87);\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n   data: function data() {\n      return {\n         pieData: {}\n      };\n   },\n\n   components: {\n      headTop: __WEBPACK_IMPORTED_MODULE_2__components_headTop___default.a,\n      visitorPie: __WEBPACK_IMPORTED_MODULE_3__components_visitorPie___default.a\n   },\n   mounted: function mounted() {\n      this.initData();\n   },\n\n   methods: {\n      initData: function initData() {\n         var _this = this;\n\n         return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {\n            var res;\n            return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {\n               while (1) {\n                  switch (_context.prev = _context.next) {\n                     case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__api_getData__[\"c\" /* getUserCity */])();\n\n                     case 3:\n                        res = _context.sent;\n\n                        if (!(res.status == 1)) {\n                           _context.next = 8;\n                           break;\n                        }\n\n                        _this.pieData = res.user_city;\n                        _context.next = 9;\n                        break;\n\n                     case 8:\n                        throw new Error(res);\n\n                     case 9:\n                        _context.next = 14;\n                        break;\n\n                     case 11:\n                        _context.prev = 11;\n                        _context.t0 = _context['catch'](0);\n\n                        console.log('获取用户分布信息失败', _context.t0);\n\n                     case 14:\n                     case 'end':\n                        return _context.stop();\n                  }\n               }\n            }, _callee, _this, [[0, 11]]);\n         }))();\n      }\n   }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3Zpc2l0b3IudnVlP2ZiNDkiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXY+XG4gICAgICAgIDxoZWFkLXRvcD48L2hlYWQtdG9wPlxuICAgICAgICA8dmlzaXRvci1waWUgOnBpZURhdGE9XCJwaWVEYXRhXCI+PC92aXNpdG9yLXBpZT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCBoZWFkVG9wIGZyb20gJy4uL2NvbXBvbmVudHMvaGVhZFRvcCdcbiAgICBpbXBvcnQgdmlzaXRvclBpZSBmcm9tICdAL2NvbXBvbmVudHMvdmlzaXRvclBpZSdcblx0aW1wb3J0IHtnZXRVc2VyQ2l0eX0gZnJvbSAnQC9hcGkvZ2V0RGF0YSdcbiAgICBleHBvcnQgZGVmYXVsdCB7XG4gICAgXHRkYXRhKCl7XG4gICAgXHRcdHJldHVybiB7XG4gICAgXHRcdFx0cGllRGF0YToge30sXG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRjb21wb25lbnRzOiB7XG4gICAgXHRcdGhlYWRUb3AsXG4gICAgICAgICAgICB2aXNpdG9yUGllLFxuICAgIFx0fSxcbiAgICBcdG1vdW50ZWQoKXtcbiAgICBcdFx0dGhpcy5pbml0RGF0YSgpO1xuICAgIFx0fSxcbiAgICBcdG1ldGhvZHM6IHtcbiAgICBcdFx0YXN5bmMgaW5pdERhdGEoKXtcbiAgICBcdFx0XHR0cnl7XG4gICAgXHRcdFx0XHRjb25zdCByZXMgPSBhd2FpdCBnZXRVc2VyQ2l0eSgpO1xuICAgIFx0XHRcdFx0aWYgKHJlcy5zdGF0dXMgPT0gMSkge1xuICAgIFx0XHRcdFx0XHR0aGlzLnBpZURhdGEgPSByZXMudXNlcl9jaXR5O1xuICAgIFx0XHRcdFx0fWVsc2V7XG4gICAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihyZXMpXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fWNhdGNoKGVycil7XG4gICAgXHRcdFx0XHRjb25zb2xlLmxvZygn6I635Y+W55So5oi35YiG5biD5L+h5oGv5aSx6LSlJyxlcnIpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fSxcbiAgICBcdH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uL3N0eWxlL21peGluJztcblx0XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHZpc2l0b3IudnVlPzcyZmZlMzdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFKQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV0E7QUFaQTtBQWJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///422\n");

/***/ }),
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar zrUtil = __webpack_require__(230);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9hY3Rpb24vY3JlYXRlRGF0YVNlbGVjdEFjdGlvbi5qcz8yYzJiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlY2hhcnRzID0gcmVxdWlyZShcIi4uL2VjaGFydHNcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBhY3Rpb25JbmZvcykge1xuICB6clV0aWwuZWFjaChhY3Rpb25JbmZvcywgZnVuY3Rpb24gKGFjdGlvbkluZm8pIHtcbiAgICBhY3Rpb25JbmZvLnVwZGF0ZSA9ICd1cGRhdGVWaWV3JztcbiAgICAvKipcbiAgICAgKiBAcGF5bG9hZFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZXJpZXNOYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cblxuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oYWN0aW9uSW5mbywgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHt9O1xuICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICAgICAgbWFpblR5cGU6ICdzZXJpZXMnLFxuICAgICAgICBzdWJUeXBlOiBzZXJpZXNUeXBlLFxuICAgICAgICBxdWVyeTogcGF5bG9hZFxuICAgICAgfSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIGlmIChzZXJpZXNNb2RlbFthY3Rpb25JbmZvLm1ldGhvZF0pIHtcbiAgICAgICAgICBzZXJpZXNNb2RlbFthY3Rpb25JbmZvLm1ldGhvZF0ocGF5bG9hZC5uYW1lLCBwYXlsb2FkLmRhdGFJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTsgLy8gQ3JlYXRlIHNlbGVjdGVkIG1hcFxuXG4gICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICAgICAgICBzZWxlY3RlZFtuYW1lXSA9IHNlcmllc01vZGVsLmlzU2VsZWN0ZWQobmFtZSkgfHwgZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBwYXlsb2FkLm5hbWUsXG4gICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2FjdGlvbi9jcmVhdGVEYXRhU2VsZWN0QWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///431\n");

/***/ }),
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar zrUtil = __webpack_require__(230);\n\n__webpack_require__(445);\n\n__webpack_require__(446);\n\nvar createDataSelectAction = __webpack_require__(431);\n\nvar dataColor = __webpack_require__(499);\n\nvar pieLayout = __webpack_require__(448);\n\nvar dataFilter = __webpack_require__(497);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(zrUtil.curry(dataColor, 'pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(zrUtil.curry(dataFilter, 'pie'));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUuanM/ZWMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9lY2hhcnRzXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxucmVxdWlyZShcIi4vcGllL1BpZVNlcmllc1wiKTtcblxucmVxdWlyZShcIi4vcGllL1BpZVZpZXdcIik7XG5cbnZhciBjcmVhdGVEYXRhU2VsZWN0QWN0aW9uID0gcmVxdWlyZShcIi4uL2FjdGlvbi9jcmVhdGVEYXRhU2VsZWN0QWN0aW9uXCIpO1xuXG52YXIgZGF0YUNvbG9yID0gcmVxdWlyZShcIi4uL3Zpc3VhbC9kYXRhQ29sb3JcIik7XG5cbnZhciBwaWVMYXlvdXQgPSByZXF1aXJlKFwiLi9waWUvcGllTGF5b3V0XCIpO1xuXG52YXIgZGF0YUZpbHRlciA9IHJlcXVpcmUoXCIuLi9wcm9jZXNzb3IvZGF0YUZpbHRlclwiKTtcblxuY3JlYXRlRGF0YVNlbGVjdEFjdGlvbigncGllJywgW3tcbiAgdHlwZTogJ3BpZVRvZ2dsZVNlbGVjdCcsXG4gIGV2ZW50OiAncGllc2VsZWN0Y2hhbmdlZCcsXG4gIG1ldGhvZDogJ3RvZ2dsZVNlbGVjdGVkJ1xufSwge1xuICB0eXBlOiAncGllU2VsZWN0JyxcbiAgZXZlbnQ6ICdwaWVzZWxlY3RlZCcsXG4gIG1ldGhvZDogJ3NlbGVjdCdcbn0sIHtcbiAgdHlwZTogJ3BpZVVuU2VsZWN0JyxcbiAgZXZlbnQ6ICdwaWV1bnNlbGVjdGVkJyxcbiAgbWV0aG9kOiAndW5TZWxlY3QnXG59XSk7XG5lY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeShkYXRhQ29sb3IsICdwaWUnKSk7XG5lY2hhcnRzLnJlZ2lzdGVyTGF5b3V0KHpyVXRpbC5jdXJyeShwaWVMYXlvdXQsICdwaWUnKSk7XG5lY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKHpyVXRpbC5jdXJyeShkYXRhRmlsdGVyLCAncGllJykpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///444\n");

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

eval("var echarts = __webpack_require__(232);\n\nvar List = __webpack_require__(263);\n\nvar zrUtil = __webpack_require__(230);\n\nvar modelUtil = __webpack_require__(234);\n\nvar _number = __webpack_require__(235);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar completeDimensions = __webpack_require__(272);\n\nvar dataSelectableMixin = __webpack_require__(469);\n\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(option.data);\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this.option.data);\n  },\n  getInitialData: function (option, ecModel) {\n    var dimensions = completeDimensions(['value'], option.data);\n    var list = new List(dimensions, this);\n    list.initData(option.data);\n    return list;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each('value', function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option.labelLine, ['show']);\n    var labelLineNormalOpt = option.labelLine.normal;\n    var labelLineEmphasisOpt = option.labelLine.emphasis; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // 默认全局居中\n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // 默认顺时针\n    clockwise: true,\n    startAngle: 90,\n    // 最小角度改为0\n    minAngle: 0,\n    // 选中时扇区偏移量\n    selectedOffset: 10,\n    // 高亮扇区偏移量\n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // 选择模式，默认关闭，可选single，multiple\n    // selectedMode: false,\n    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      normal: {\n        // If rotate around circle\n        rotate: false,\n        show: true,\n        // 'outer', 'inside', 'center'\n        position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n        // 默认使用全局文本样式，详见TEXTSTYLE\n        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\n      },\n      emphasis: {}\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      normal: {\n        show: true,\n        // 引导线两段中的第一段长度\n        length: 15,\n        // 引导线两段中的第二段长度\n        length2: 15,\n        smooth: false,\n        lineStyle: {\n          // color: 各异,\n          width: 1,\n          type: 'solid'\n        }\n      }\n    },\n    itemStyle: {\n      normal: {\n        borderWidth: 1\n      },\n      emphasis: {}\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut',\n    data: []\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllU2VyaWVzLmpzPzJhNTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVjaGFydHMgPSByZXF1aXJlKFwiLi4vLi4vZWNoYXJ0c1wiKTtcblxudmFyIExpc3QgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS9MaXN0XCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2NvcmUvdXRpbFwiKTtcblxudmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL21vZGVsXCIpO1xuXG52YXIgX251bWJlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL251bWJlclwiKTtcblxudmFyIGdldFBlcmNlbnRXaXRoUHJlY2lzaW9uID0gX251bWJlci5nZXRQZXJjZW50V2l0aFByZWNpc2lvbjtcblxudmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnNcIik7XG5cbnZhciBkYXRhU2VsZWN0YWJsZU1peGluID0gcmVxdWlyZShcIi4uLy4uL2NvbXBvbmVudC9oZWxwZXIvc2VsZWN0YWJsZU1peGluXCIpO1xuXG52YXIgUGllU2VyaWVzID0gZWNoYXJ0cy5leHRlbmRTZXJpZXNNb2RlbCh7XG4gIHR5cGU6ICdzZXJpZXMucGllJyxcbiAgLy8gT3ZlcndyaXRlXG4gIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBQaWVTZXJpZXMuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7IC8vIEVuYWJsZSBsZWdlbmQgc2VsZWN0aW9uIGZvciBlYWNoIGRhdGEgaXRlbVxuICAgIC8vIFVzZSBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgZGlyZWN0IGFjY2VzcyBiZWNhdXNlIGRhdGEgcmVmZXJlbmNlIG1heSBjaGFuZ2VkXG5cbiAgICB0aGlzLmxlZ2VuZERhdGFQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhd0RhdGEoKTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZE1hcChvcHRpb24uZGF0YSk7XG5cbiAgICB0aGlzLl9kZWZhdWx0TGFiZWxMaW5lKG9wdGlvbik7XG4gIH0sXG4gIC8vIE92ZXJ3cml0ZVxuICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgIFBpZVNlcmllcy5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgbmV3T3B0aW9uKTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkTWFwKHRoaXMub3B0aW9uLmRhdGEpO1xuICB9LFxuICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgIHZhciBkaW1lbnNpb25zID0gY29tcGxldGVEaW1lbnNpb25zKFsndmFsdWUnXSwgb3B0aW9uLmRhdGEpO1xuICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgbGlzdC5pbml0RGF0YShvcHRpb24uZGF0YSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG4gIC8vIE92ZXJ3cml0ZVxuICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICB2YXIgcGFyYW1zID0gUGllU2VyaWVzLnN1cGVyQ2FsbCh0aGlzLCAnZ2V0RGF0YVBhcmFtcycsIGRhdGFJbmRleCk7IC8vIEZJWE1FIHRvRml4ZWQ/XG5cbiAgICB2YXIgdmFsdWVMaXN0ID0gW107XG4gICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWVMaXN0LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHBhcmFtcy5wZXJjZW50ID0gZ2V0UGVyY2VudFdpdGhQcmVjaXNpb24odmFsdWVMaXN0LCBkYXRhSW5kZXgsIGRhdGEuaG9zdE1vZGVsLmdldCgncGVyY2VudFByZWNpc2lvbicpKTtcbiAgICBwYXJhbXMuJHZhcnMucHVzaCgncGVyY2VudCcpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIF9kZWZhdWx0TGFiZWxMaW5lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gRXh0ZW5kIGxhYmVsTGluZSBlbXBoYXNpc1xuICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLmxhYmVsTGluZSwgWydzaG93J10pO1xuICAgIHZhciBsYWJlbExpbmVOb3JtYWxPcHQgPSBvcHRpb24ubGFiZWxMaW5lLm5vcm1hbDtcbiAgICB2YXIgbGFiZWxMaW5lRW1waGFzaXNPcHQgPSBvcHRpb24ubGFiZWxMaW5lLmVtcGhhc2lzOyAvLyBOb3Qgc2hvdyBsYWJlbCBsaW5lIGlmIGBsYWJlbC5ub3JtYWwuc2hvdyA9IGZhbHNlYFxuXG4gICAgbGFiZWxMaW5lTm9ybWFsT3B0LnNob3cgPSBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyAmJiBvcHRpb24ubGFiZWwubm9ybWFsLnNob3c7XG4gICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3cgJiYgb3B0aW9uLmxhYmVsLmVtcGhhc2lzLnNob3c7XG4gIH0sXG4gIGRlZmF1bHRPcHRpb246IHtcbiAgICB6bGV2ZWw6IDAsXG4gICAgejogMixcbiAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgaG92ZXJBbmltYXRpb246IHRydWUsXG4gICAgLy8g6buY6K6k5YWo5bGA5bGF5LitXG4gICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICByYWRpdXM6IFswLCAnNzUlJ10sXG4gICAgLy8g6buY6K6k6aG65pe26ZKIXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIHN0YXJ0QW5nbGU6IDkwLFxuICAgIC8vIOacgOWwj+inkuW6puaUueS4ujBcbiAgICBtaW5BbmdsZTogMCxcbiAgICAvLyDpgInkuK3ml7bmiYfljLrlgY/np7vph49cbiAgICBzZWxlY3RlZE9mZnNldDogMTAsXG4gICAgLy8g6auY5Lqu5omH5Yy65YGP56e76YePXG4gICAgaG92ZXJPZmZzZXQ6IDEwLFxuICAgIC8vIElmIHVzZSBzdHJhdGVneSB0byBhdm9pZCBsYWJlbCBvdmVybGFwcGluZ1xuICAgIGF2b2lkTGFiZWxPdmVybGFwOiB0cnVlLFxuICAgIC8vIOmAieaLqeaooeW8j++8jOm7mOiupOWFs+mXre+8jOWPr+mAiXNpbmdsZe+8jG11bHRpcGxlXG4gICAgLy8gc2VsZWN0ZWRNb2RlOiBmYWxzZSxcbiAgICAvLyDljZfkuIHmoLzlsJTnjqvnkbDlm77mqKHlvI/vvIwncmFkaXVzJ++8iOWNiuW+hO+8iSB8ICdhcmVhJ++8iOmdouenr++8iVxuICAgIC8vIHJvc2VUeXBlOiBudWxsLFxuICAgIHBlcmNlbnRQcmVjaXNpb246IDIsXG4gICAgLy8gSWYgc3RpbGwgc2hvdyB3aGVuIGFsbCBkYXRhIHplcm8uXG4gICAgc3RpbGxTaG93WmVyb1N1bTogdHJ1ZSxcbiAgICAvLyBjdXJzb3I6IG51bGwsXG4gICAgbGFiZWw6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICAvLyBJZiByb3RhdGUgYXJvdW5kIGNpcmNsZVxuICAgICAgICByb3RhdGU6IGZhbHNlLFxuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAvLyAnb3V0ZXInLCAnaW5zaWRlJywgJ2NlbnRlcidcbiAgICAgICAgcG9zaXRpb246ICdvdXRlcicgLy8gZm9ybWF0dGVyOiDmoIfnrb7mlofmnKzmoLzlvI/lmajvvIzlkIxUb29sdGlwLmZvcm1hdHRlcu+8jOS4jeaUr+aMgeW8guatpeWbnuiwg1xuICAgICAgICAvLyDpu5jorqTkvb/nlKjlhajlsYDmlofmnKzmoLflvI/vvIzor6bop4FURVhUU1RZTEVcbiAgICAgICAgLy8gZGlzdGFuY2U6IOW9k3Bvc2l0aW9u5Li6aW5uZXLml7bmnInmlYjvvIzkuLpsYWJlbOS9jee9ruWIsOWchuW/g+eahOi3neemu+S4juWchuWNiuW+hCjnjq/nirblm77kuLrlhoXlpJbljYrlvoTlkowp55qE5q+U5L6L57O75pWwXG5cbiAgICAgIH0sXG4gICAgICBlbXBoYXNpczoge31cbiAgICB9LFxuICAgIC8vIEVuYWJsZWQgd2hlbiBsYWJlbC5ub3JtYWwucG9zaXRpb24gaXMgJ291dGVyJ1xuICAgIGxhYmVsTGluZToge1xuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS4gOautemVv+W6plxuICAgICAgICBsZW5ndGg6IDE1LFxuICAgICAgICAvLyDlvJXlr7znur/kuKTmrrXkuK3nmoTnrKzkuozmrrXplb/luqZcbiAgICAgICAgbGVuZ3RoMjogMTUsXG4gICAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgIC8vIGNvbG9yOiDlkITlvIIsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtU3R5bGU6IHtcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSxcbiAgICAgIGVtcGhhc2lzOiB7fVxuICAgIH0sXG4gICAgLy8gQW5pbWF0aW9uIHR5cGUgY2FuYmUgZXhwYW5zaW9uLCBzY2FsZVxuICAgIGFuaW1hdGlvblR5cGU6ICdleHBhbnNpb24nLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2N1YmljT3V0JyxcbiAgICBkYXRhOiBbXVxuICB9XG59KTtcbnpyVXRpbC5taXhpbihQaWVTZXJpZXMsIGRhdGFTZWxlY3RhYmxlTWl4aW4pO1xudmFyIF9kZWZhdWx0ID0gUGllU2VyaWVzO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvcGllL1BpZVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gNDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///445\n");

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\nvar graphic = __webpack_require__(233);\n\nvar ChartView = __webpack_require__(280);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var itemStyleModel = itemModel.getModel('itemStyle');\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemStyleModel.getModel('normal').getItemStyle()));\n  sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label.normal');\n  var labelHoverModel = itemModel.getModel('label.emphasis');\n  var labelLineModel = itemModel.getModel('labelLine.normal');\n  var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUvUGllVmlldy5qcz9jMDgyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2dyYXBoaWNcIik7XG5cbnZhciBDaGFydFZpZXcgPSByZXF1aXJlKFwiLi4vLi4vdmlldy9DaGFydFwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQW5pbWF0aW9uXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0YVNlbGVjdGVkKHVpZCwgc2VyaWVzTW9kZWwsIGhhc0FuaW1hdGlvbiwgYXBpKSB7XG4gIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICB2YXIgZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gIHZhciBzZWxlY3RlZE9mZnNldCA9IHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRPZmZzZXQnKTtcbiAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICB0eXBlOiAncGllVG9nZ2xlU2VsZWN0JyxcbiAgICBmcm9tOiB1aWQsXG4gICAgbmFtZTogbmFtZSxcbiAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWRcbiAgfSk7XG4gIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgdG9nZ2xlSXRlbVNlbGVjdGVkKGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpLCBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSwgc2VyaWVzTW9kZWwuaXNTZWxlY3RlZChkYXRhLmdldE5hbWUoaWR4KSksIHNlbGVjdGVkT2Zmc2V0LCBoYXNBbmltYXRpb24pO1xuICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1NlY3Rvcn0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWxlY3RlZFxuICogQHBhcmFtIHtudW1iZXJ9IHNlbGVjdGVkT2Zmc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0FuaW1hdGlvblxuICogQGlubmVyXG4gKi9cblxuXG5mdW5jdGlvbiB0b2dnbGVJdGVtU2VsZWN0ZWQoZWwsIGxheW91dCwgaXNTZWxlY3RlZCwgc2VsZWN0ZWRPZmZzZXQsIGhhc0FuaW1hdGlvbikge1xuICB2YXIgbWlkQW5nbGUgPSAobGF5b3V0LnN0YXJ0QW5nbGUgKyBsYXlvdXQuZW5kQW5nbGUpIC8gMjtcbiAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICB2YXIgZHkgPSBNYXRoLnNpbihtaWRBbmdsZSk7XG4gIHZhciBvZmZzZXQgPSBpc1NlbGVjdGVkID8gc2VsZWN0ZWRPZmZzZXQgOiAwO1xuICB2YXIgcG9zaXRpb24gPSBbZHggKiBvZmZzZXQsIGR5ICogb2Zmc2V0XTtcbiAgaGFzQW5pbWF0aW9uIC8vIGFuaW1hdGVUbyB3aWxsIHN0b3AgcmV2aW91cyBhbmltYXRpb24gbGlrZSB1cGRhdGUgdHJhbnNpdGlvblxuICA/IGVsLmFuaW1hdGUoKS53aGVuKDIwMCwge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9KS5zdGFydCgnYm91bmNlT3V0JykgOiBlbC5hdHRyKCdwb3NpdGlvbicsIHBvc2l0aW9uKTtcbn1cbi8qKlxuICogUGllY2Ugb2YgcGllIGluY2x1ZGluZyBTZWN0b3IsIExhYmVsLCBMYWJlbExpbmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gKi9cblxuXG5mdW5jdGlvbiBQaWVQaWVjZShkYXRhLCBpZHgpIHtcbiAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuICB2YXIgc2VjdG9yID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICB6MjogMlxuICB9KTtcbiAgdmFyIHBvbHlsaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoKTtcbiAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KCk7XG4gIHRoaXMuYWRkKHNlY3Rvcik7XG4gIHRoaXMuYWRkKHBvbHlsaW5lKTtcbiAgdGhpcy5hZGQodGV4dCk7XG4gIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHRydWUpOyAvLyBIb3ZlciB0byBjaGFuZ2UgbGFiZWwgYW5kIGxhYmVsTGluZVxuXG4gIGZ1bmN0aW9uIG9uRW1waGFzaXMoKSB7XG4gICAgcG9seWxpbmUuaWdub3JlID0gcG9seWxpbmUuaG92ZXJJZ25vcmU7XG4gICAgdGV4dC5pZ25vcmUgPSB0ZXh0LmhvdmVySWdub3JlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ob3JtYWwoKSB7XG4gICAgcG9seWxpbmUuaWdub3JlID0gcG9seWxpbmUubm9ybWFsSWdub3JlO1xuICAgIHRleHQuaWdub3JlID0gdGV4dC5ub3JtYWxJZ25vcmU7XG4gIH1cblxuICB0aGlzLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpLm9uKCdub3JtYWwnLCBvbk5vcm1hbCkub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKTtcbn1cblxudmFyIHBpZVBpZWNlUHJvdG8gPSBQaWVQaWVjZS5wcm90b3R5cGU7XG5cbnBpZVBpZWNlUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBpZHgsIGZpcnN0Q3JlYXRlKSB7XG4gIHZhciBzZWN0b3IgPSB0aGlzLmNoaWxkQXQoMCk7XG4gIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICB2YXIgc2VjdG9yU2hhcGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBsYXlvdXQpO1xuICBzZWN0b3JTaGFwZS5sYWJlbCA9IG51bGw7XG5cbiAgaWYgKGZpcnN0Q3JlYXRlKSB7XG4gICAgc2VjdG9yLnNldFNoYXBlKHNlY3RvclNoYXBlKTtcbiAgICB2YXIgYW5pbWF0aW9uVHlwZSA9IHNlcmllc01vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvblR5cGUnKTtcblxuICAgIGlmIChhbmltYXRpb25UeXBlID09PSAnc2NhbGUnKSB7XG4gICAgICBzZWN0b3Iuc2hhcGUuciA9IGxheW91dC5yMDtcbiAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHNlY3Rvciwge1xuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIHI6IGxheW91dC5yXG4gICAgICAgIH1cbiAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgIH0gLy8gRXhwYW5zaW9uXG4gICAgZWxzZSB7XG4gICAgICAgIHNlY3Rvci5zaGFwZS5lbmRBbmdsZSA9IGxheW91dC5zdGFydEFuZ2xlO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBlbmRBbmdsZTogbGF5b3V0LmVuZEFuZ2xlXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgIH1cbiAgfSBlbHNlIHtcbiAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgc2hhcGU6IHNlY3RvclNoYXBlXG4gICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIH0gLy8gVXBkYXRlIGNvbW1vbiBzdHlsZVxuXG5cbiAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUnKTtcbiAgdmFyIHZpc3VhbENvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gIHNlY3Rvci51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoe1xuICAgIGxpbmVKb2luOiAnYmV2ZWwnLFxuICAgIGZpbGw6IHZpc3VhbENvbG9yXG4gIH0sIGl0ZW1TdHlsZU1vZGVsLmdldE1vZGVsKCdub3JtYWwnKS5nZXRJdGVtU3R5bGUoKSkpO1xuICBzZWN0b3IuaG92ZXJTdHlsZSA9IGl0ZW1TdHlsZU1vZGVsLmdldE1vZGVsKCdlbXBoYXNpcycpLmdldEl0ZW1TdHlsZSgpO1xuICB2YXIgY3Vyc29yU3R5bGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnY3Vyc29yJyk7XG4gIGN1cnNvclN0eWxlICYmIHNlY3Rvci5hdHRyKCdjdXJzb3InLCBjdXJzb3JTdHlsZSk7IC8vIFRvZ2dsZSBzZWxlY3RlZFxuXG4gIHRvZ2dsZUl0ZW1TZWxlY3RlZCh0aGlzLCBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSwgaXRlbU1vZGVsLmdldCgnc2VsZWN0ZWQnKSwgc2VyaWVzTW9kZWwuZ2V0KCdzZWxlY3RlZE9mZnNldCcpLCBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpKTtcblxuICBmdW5jdGlvbiBvbkVtcGhhc2lzKCkge1xuICAgIC8vIFNlY3RvciBtYXkgaGFzIGFuaW1hdGlvbiBvZiB1cGRhdGluZyBkYXRhLiBGb3JjZSB0byBtb3ZlIHRvIHRoZSBsYXN0IGZyYW1lXG4gICAgLy8gT3IgaXQgbWF5IHN0b3BwZWQgb24gdGhlIHdyb25nIHNoYXBlXG4gICAgc2VjdG9yLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgc2VjdG9yLmFuaW1hdGVUbyh7XG4gICAgICBzaGFwZToge1xuICAgICAgICByOiBsYXlvdXQuciArIHNlcmllc01vZGVsLmdldCgnaG92ZXJPZmZzZXQnKVxuICAgICAgfVxuICAgIH0sIDMwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTm9ybWFsKCkge1xuICAgIHNlY3Rvci5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgIHNlY3Rvci5hbmltYXRlVG8oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcjogbGF5b3V0LnJcbiAgICAgIH1cbiAgICB9LCAzMDAsICdlbGFzdGljT3V0Jyk7XG4gIH1cblxuICBzZWN0b3Iub2ZmKCdtb3VzZW92ZXInKS5vZmYoJ21vdXNlb3V0Jykub2ZmKCdlbXBoYXNpcycpLm9mZignbm9ybWFsJyk7XG5cbiAgaWYgKGl0ZW1Nb2RlbC5nZXQoJ2hvdmVyQW5pbWF0aW9uJykgJiYgc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkpIHtcbiAgICBzZWN0b3Iub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKS5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKS5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlTGFiZWwoZGF0YSwgaWR4KTtcblxuICBncmFwaGljLnNldEhvdmVyU3R5bGUodGhpcyk7XG59O1xuXG5waWVQaWVjZVByb3RvLl91cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIChkYXRhLCBpZHgpIHtcbiAgdmFyIGxhYmVsTGluZSA9IHRoaXMuY2hpbGRBdCgxKTtcbiAgdmFyIGxhYmVsVGV4dCA9IHRoaXMuY2hpbGRBdCgyKTtcbiAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gIHZhciBsYWJlbExheW91dCA9IGxheW91dC5sYWJlbDtcbiAgdmFyIHZpc3VhbENvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxMaW5lLCB7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogbGFiZWxMYXlvdXQubGluZVBvaW50cyB8fCBbW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldLCBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV0sIFtsYWJlbExheW91dC54LCBsYWJlbExheW91dC55XV1cbiAgICB9XG4gIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICBncmFwaGljLnVwZGF0ZVByb3BzKGxhYmVsVGV4dCwge1xuICAgIHN0eWxlOiB7XG4gICAgICB4OiBsYWJlbExheW91dC54LFxuICAgICAgeTogbGFiZWxMYXlvdXQueVxuICAgIH1cbiAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gIGxhYmVsVGV4dC5hdHRyKHtcbiAgICByb3RhdGlvbjogbGFiZWxMYXlvdXQucm90YXRpb24sXG4gICAgb3JpZ2luOiBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV0sXG4gICAgejI6IDEwXG4gIH0pO1xuICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gIHZhciBsYWJlbEhvdmVyTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG4gIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLm5vcm1hbCcpO1xuICB2YXIgbGFiZWxMaW5lSG92ZXJNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLmVtcGhhc2lzJyk7XG4gIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICBncmFwaGljLnNldExhYmVsU3R5bGUobGFiZWxUZXh0LnN0eWxlLCBsYWJlbFRleHQuaG92ZXJTdHlsZSA9IHt9LCBsYWJlbE1vZGVsLCBsYWJlbEhvdmVyTW9kZWwsIHtcbiAgICBsYWJlbEZldGNoZXI6IGRhdGEuaG9zdE1vZGVsLFxuICAgIGxhYmVsRGF0YUluZGV4OiBpZHgsXG4gICAgZGVmYXVsdFRleHQ6IGRhdGEuZ2V0TmFtZShpZHgpLFxuICAgIGF1dG9Db2xvcjogdmlzdWFsQ29sb3IsXG4gICAgdXNlSW5zaWRlU3R5bGU6ICEhbGFiZWxMYXlvdXQuaW5zaWRlXG4gIH0sIHtcbiAgICB0ZXh0QWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudmVydGljYWxBbGlnbixcbiAgICBvcGFjaXR5OiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpXG4gIH0pO1xuICBsYWJlbFRleHQuaWdub3JlID0gbGFiZWxUZXh0Lm5vcm1hbElnbm9yZSA9ICFsYWJlbE1vZGVsLmdldCgnc2hvdycpO1xuICBsYWJlbFRleHQuaG92ZXJJZ25vcmUgPSAhbGFiZWxIb3Zlck1vZGVsLmdldCgnc2hvdycpO1xuICBsYWJlbExpbmUuaWdub3JlID0gbGFiZWxMaW5lLm5vcm1hbElnbm9yZSA9ICFsYWJlbExpbmVNb2RlbC5nZXQoJ3Nob3cnKTtcbiAgbGFiZWxMaW5lLmhvdmVySWdub3JlID0gIWxhYmVsTGluZUhvdmVyTW9kZWwuZ2V0KCdzaG93Jyk7IC8vIERlZmF1bHQgdXNlIGl0ZW0gdmlzdWFsIGNvbG9yXG5cbiAgbGFiZWxMaW5lLnNldFN0eWxlKHtcbiAgICBzdHJva2U6IHZpc3VhbENvbG9yLFxuICAgIG9wYWNpdHk6IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5JylcbiAgfSk7XG4gIGxhYmVsTGluZS5zZXRTdHlsZShsYWJlbExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCkpO1xuICBsYWJlbExpbmUuaG92ZXJTdHlsZSA9IGxhYmVsTGluZUhvdmVyTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpLmdldExpbmVTdHlsZSgpO1xuICB2YXIgc21vb3RoID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdzbW9vdGgnKTtcblxuICBpZiAoc21vb3RoICYmIHNtb290aCA9PT0gdHJ1ZSkge1xuICAgIHNtb290aCA9IDAuNDtcbiAgfVxuXG4gIGxhYmVsTGluZS5zZXRTaGFwZSh7XG4gICAgc21vb3RoOiBzbW9vdGhcbiAgfSk7XG59O1xuXG56clV0aWwuaW5oZXJpdHMoUGllUGllY2UsIGdyYXBoaWMuR3JvdXApOyAvLyBQaWUgdmlld1xuXG52YXIgUGllVmlldyA9IENoYXJ0Vmlldy5leHRlbmQoe1xuICB0eXBlOiAncGllJyxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWN0b3JHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdGhpcy5fc2VjdG9yR3JvdXAgPSBzZWN0b3JHcm91cDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICB2YXIgaGFzQW5pbWF0aW9uID0gZWNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuICAgIHZhciBpc0ZpcnN0UmVuZGVyID0gIW9sZERhdGE7XG4gICAgdmFyIGFuaW1hdGlvblR5cGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvblR5cGUnKTtcbiAgICB2YXIgb25TZWN0b3JDbGljayA9IHpyVXRpbC5jdXJyeSh1cGRhdGVEYXRhU2VsZWN0ZWQsIHRoaXMudWlkLCBzZXJpZXNNb2RlbCwgaGFzQW5pbWF0aW9uLCBhcGkpO1xuICAgIHZhciBzZWxlY3RlZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuICAgIGRhdGEuZGlmZihvbGREYXRhKS5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBpZVBpZWNlID0gbmV3IFBpZVBpZWNlKGRhdGEsIGlkeCk7IC8vIERlZmF1bHQgZXhwYW5zaW9uIGFuaW1hdGlvblxuXG4gICAgICBpZiAoaXNGaXJzdFJlbmRlciAmJiBhbmltYXRpb25UeXBlICE9PSAnc2NhbGUnKSB7XG4gICAgICAgIHBpZVBpZWNlLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWRNb2RlICYmIHBpZVBpZWNlLm9uKCdjbGljaycsIG9uU2VjdG9yQ2xpY2spO1xuICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgcGllUGllY2UpO1xuICAgICAgZ3JvdXAuYWRkKHBpZVBpZWNlKTtcbiAgICB9KS51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICB2YXIgcGllUGllY2UgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgIHBpZVBpZWNlLnVwZGF0ZURhdGEoZGF0YSwgbmV3SWR4KTtcbiAgICAgIHBpZVBpZWNlLm9mZignY2xpY2snKTtcbiAgICAgIHNlbGVjdGVkTW9kZSAmJiBwaWVQaWVjZS5vbignY2xpY2snLCBvblNlY3RvckNsaWNrKTtcbiAgICAgIGdyb3VwLmFkZChwaWVQaWVjZSk7XG4gICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBwaWVQaWVjZSk7XG4gICAgfSkucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBwaWVQaWVjZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgZ3JvdXAucmVtb3ZlKHBpZVBpZWNlKTtcbiAgICB9KS5leGVjdXRlKCk7XG5cbiAgICBpZiAoaGFzQW5pbWF0aW9uICYmIGlzRmlyc3RSZW5kZXIgJiYgZGF0YS5jb3VudCgpID4gMCAvLyBEZWZhdWx0IGV4cGFuc2lvbiBhbmltYXRpb25cbiAgICAmJiBhbmltYXRpb25UeXBlICE9PSAnc2NhbGUnKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLmdldEl0ZW1MYXlvdXQoMCk7XG4gICAgICB2YXIgciA9IE1hdGgubWF4KGFwaS5nZXRXaWR0aCgpLCBhcGkuZ2V0SGVpZ2h0KCkpIC8gMjtcbiAgICAgIHZhciByZW1vdmVDbGlwUGF0aCA9IHpyVXRpbC5iaW5kKGdyb3VwLnJlbW92ZUNsaXBQYXRoLCBncm91cCk7XG4gICAgICBncm91cC5zZXRDbGlwUGF0aCh0aGlzLl9jcmVhdGVDbGlwUGF0aChzaGFwZS5jeCwgc2hhcGUuY3ksIHIsIHNoYXBlLnN0YXJ0QW5nbGUsIHNoYXBlLmNsb2Nrd2lzZSwgcmVtb3ZlQ2xpcFBhdGgsIHNlcmllc01vZGVsKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH0sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9LFxuICBfY3JlYXRlQ2xpcFBhdGg6IGZ1bmN0aW9uIChjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSwgY2IsIHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICByMDogMCxcbiAgICAgICAgcjogcixcbiAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBNYXRoLlBJICogMlxuICAgICAgfVxuICAgIH0sIHNlcmllc01vZGVsLCBjYik7XG4gICAgcmV0dXJuIGNsaXBQYXRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAaW1wbGVtZW50XG4gICAqL1xuICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICB2YXIgaXRlbUxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dCgwKTtcblxuICAgIGlmIChpdGVtTGF5b3V0KSB7XG4gICAgICB2YXIgZHggPSBwb2ludFswXSAtIGl0ZW1MYXlvdXQuY3g7XG4gICAgICB2YXIgZHkgPSBwb2ludFsxXSAtIGl0ZW1MYXlvdXQuY3k7XG4gICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHJldHVybiByYWRpdXMgPD0gaXRlbUxheW91dC5yICYmIHJhZGl1cyA+PSBpdGVtTGF5b3V0LnIwO1xuICAgIH1cbiAgfVxufSk7XG52YXIgX2RlZmF1bHQgPSBQaWVWaWV3O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWNoYXJ0cy9saWIvY2hhcnQvcGllL1BpZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///446\n");

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

eval("var textContain = __webpack_require__(250);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // 压\n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // 弹\n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // 右侧\n    ? Number.MAX_VALUE // 下\n    : 0 // 上\n    : isDownList // 左侧\n    ? Number.MAX_VALUE // 下\n    : 0; // 上\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // 右下，左下\n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // 右上，左上\n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label.normal'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n    var labelLineModel = itemModel.getModel('labelLine.normal');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUvbGFiZWxMYXlvdXQuanM/YTdjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwienJlbmRlci9saWIvY29udGFpbi90ZXh0XCIpO1xuXG4vLyBGSVhNRSBlbXBoYXNpcyBsYWJlbCBwb3NpdGlvbiBpcyBub3Qgc2FtZSB3aXRoIG5vcm1hbCBsYWJlbCBwb3NpdGlvblxuZnVuY3Rpb24gYWRqdXN0U2luZ2xlU2lkZShsaXN0LCBjeCwgY3ksIHIsIGRpciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnkgLSBiLnk7XG4gIH0pOyAvLyDljotcblxuICBmdW5jdGlvbiBzaGlmdERvd24oc3RhcnQsIGVuZCwgZGVsdGEsIGRpcikge1xuICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgaisrKSB7XG4gICAgICBsaXN0W2pdLnkgKz0gZGVsdGE7XG5cbiAgICAgIGlmIChqID4gc3RhcnQgJiYgaiArIDEgPCBlbmQgJiYgbGlzdFtqICsgMV0ueSA+IGxpc3Rbal0ueSArIGxpc3Rbal0uaGVpZ2h0KSB7XG4gICAgICAgIHNoaWZ0VXAoaiwgZGVsdGEgLyAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNoaWZ0VXAoZW5kIC0gMSwgZGVsdGEgLyAyKTtcbiAgfSAvLyDlvLlcblxuXG4gIGZ1bmN0aW9uIHNoaWZ0VXAoZW5kLCBkZWx0YSkge1xuICAgIGZvciAodmFyIGogPSBlbmQ7IGogPj0gMDsgai0tKSB7XG4gICAgICBsaXN0W2pdLnkgLT0gZGVsdGE7XG5cbiAgICAgIGlmIChqID4gMCAmJiBsaXN0W2pdLnkgPiBsaXN0W2ogLSAxXS55ICsgbGlzdFtqIC0gMV0uaGVpZ2h0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVgobGlzdCwgaXNEb3duTGlzdCwgY3gsIGN5LCByLCBkaXIpIHtcbiAgICB2YXIgbGFzdERlbHRhWCA9IGRpciA+IDAgPyBpc0Rvd25MaXN0IC8vIOWPs+S+p1xuICAgID8gTnVtYmVyLk1BWF9WQUxVRSAvLyDkuItcbiAgICA6IDAgLy8g5LiKXG4gICAgOiBpc0Rvd25MaXN0IC8vIOW3puS+p1xuICAgID8gTnVtYmVyLk1BWF9WQUxVRSAvLyDkuItcbiAgICA6IDA7IC8vIOS4ilxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gTm90IGNoYW5nZSB4IGZvciBjZW50ZXIgbGFiZWxcbiAgICAgIGlmIChsaXN0W2ldLnBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhWSA9IE1hdGguYWJzKGxpc3RbaV0ueSAtIGN5KTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0W2ldLmxlbjtcbiAgICAgIHZhciBsZW5ndGgyID0gbGlzdFtpXS5sZW4yO1xuICAgICAgdmFyIGRlbHRhWCA9IGRlbHRhWSA8IHIgKyBsZW5ndGggPyBNYXRoLnNxcnQoKHIgKyBsZW5ndGggKyBsZW5ndGgyKSAqIChyICsgbGVuZ3RoICsgbGVuZ3RoMikgLSBkZWx0YVkgKiBkZWx0YVkpIDogTWF0aC5hYnMobGlzdFtpXS54IC0gY3gpO1xuXG4gICAgICBpZiAoaXNEb3duTGlzdCAmJiBkZWx0YVggPj0gbGFzdERlbHRhWCkge1xuICAgICAgICAvLyDlj7PkuIvvvIzlt6bkuItcbiAgICAgICAgZGVsdGFYID0gbGFzdERlbHRhWCAtIDEwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRG93bkxpc3QgJiYgZGVsdGFYIDw9IGxhc3REZWx0YVgpIHtcbiAgICAgICAgLy8g5Y+z5LiK77yM5bem5LiKXG4gICAgICAgIGRlbHRhWCA9IGxhc3REZWx0YVggKyAxMDtcbiAgICAgIH1cblxuICAgICAgbGlzdFtpXS54ID0gY3ggKyBkZWx0YVggKiBkaXI7XG4gICAgICBsYXN0RGVsdGFYID0gZGVsdGFYO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0WSA9IDA7XG4gIHZhciBkZWx0YTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgdXBMaXN0ID0gW107XG4gIHZhciBkb3duTGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkZWx0YSA9IGxpc3RbaV0ueSAtIGxhc3RZO1xuXG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgc2hpZnREb3duKGksIGxlbiwgLWRlbHRhLCBkaXIpO1xuICAgIH1cblxuICAgIGxhc3RZID0gbGlzdFtpXS55ICsgbGlzdFtpXS5oZWlnaHQ7XG4gIH1cblxuICBpZiAodmlld0hlaWdodCAtIGxhc3RZIDwgMCkge1xuICAgIHNoaWZ0VXAobGVuIC0gMSwgbGFzdFkgLSB2aWV3SGVpZ2h0KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobGlzdFtpXS55ID49IGN5KSB7XG4gICAgICBkb3duTGlzdC5wdXNoKGxpc3RbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cExpc3QucHVzaChsaXN0W2ldKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VYKHVwTGlzdCwgZmFsc2UsIGN4LCBjeSwgciwgZGlyKTtcbiAgY2hhbmdlWChkb3duTGlzdCwgdHJ1ZSwgY3gsIGN5LCByLCBkaXIpO1xufVxuXG5mdW5jdGlvbiBhdm9pZE92ZXJsYXAobGFiZWxMYXlvdXRMaXN0LCBjeCwgY3ksIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICB2YXIgbGVmdExpc3QgPSBbXTtcbiAgdmFyIHJpZ2h0TGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxMYXlvdXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxhYmVsTGF5b3V0TGlzdFtpXS54IDwgY3gpIHtcbiAgICAgIGxlZnRMaXN0LnB1c2gobGFiZWxMYXlvdXRMaXN0W2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHRMaXN0LnB1c2gobGFiZWxMYXlvdXRMaXN0W2ldKTtcbiAgICB9XG4gIH1cblxuICBhZGp1c3RTaW5nbGVTaWRlKHJpZ2h0TGlzdCwgY3gsIGN5LCByLCAxLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICBhZGp1c3RTaW5nbGVTaWRlKGxlZnRMaXN0LCBjeCwgY3ksIHIsIC0xLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxMYXlvdXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmVQb2ludHMgPSBsYWJlbExheW91dExpc3RbaV0ubGluZVBvaW50cztcblxuICAgIGlmIChsaW5lUG9pbnRzKSB7XG4gICAgICB2YXIgZGlzdCA9IGxpbmVQb2ludHNbMV1bMF0gLSBsaW5lUG9pbnRzWzJdWzBdO1xuXG4gICAgICBpZiAobGFiZWxMYXlvdXRMaXN0W2ldLnggPCBjeCkge1xuICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gbGFiZWxMYXlvdXRMaXN0W2ldLnggKyAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVBvaW50c1syXVswXSA9IGxhYmVsTGF5b3V0TGlzdFtpXS54IC0gMztcbiAgICAgIH1cblxuICAgICAgbGluZVBvaW50c1sxXVsxXSA9IGxpbmVQb2ludHNbMl1bMV0gPSBsYWJlbExheW91dExpc3RbaV0ueTtcbiAgICAgIGxpbmVQb2ludHNbMV1bMF0gPSBsaW5lUG9pbnRzWzJdWzBdICsgZGlzdDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmF1bHQoc2VyaWVzTW9kZWwsIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgdmFyIGxhYmVsTGF5b3V0TGlzdCA9IFtdO1xuICB2YXIgY3g7XG4gIHZhciBjeTtcbiAgdmFyIGhhc0xhYmVsUm90YXRlID0gZmFsc2U7XG4gIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTsgLy8gVXNlIHBvc2l0aW9uIGluIG5vcm1hbCBvciBlbXBoYXNpc1xuXG4gICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSB8fCBpdGVtTW9kZWwuZ2V0KCdsYWJlbC5lbXBoYXNpcy5wb3NpdGlvbicpO1xuICAgIHZhciBsYWJlbExpbmVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWxMaW5lLm5vcm1hbCcpO1xuICAgIHZhciBsYWJlbExpbmVMZW4gPSBsYWJlbExpbmVNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuICAgIHZhciBsYWJlbExpbmVMZW4yID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgyJyk7XG4gICAgdmFyIG1pZEFuZ2xlID0gKGxheW91dC5zdGFydEFuZ2xlICsgbGF5b3V0LmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgIHZhciBkeSA9IE1hdGguc2luKG1pZEFuZ2xlKTtcbiAgICB2YXIgdGV4dFg7XG4gICAgdmFyIHRleHRZO1xuICAgIHZhciBsaW5lUG9pbnRzO1xuICAgIHZhciB0ZXh0QWxpZ247XG4gICAgY3ggPSBsYXlvdXQuY3g7XG4gICAgY3kgPSBsYXlvdXQuY3k7XG4gICAgdmFyIGlzTGFiZWxJbnNpZGUgPSBsYWJlbFBvc2l0aW9uID09PSAnaW5zaWRlJyB8fCBsYWJlbFBvc2l0aW9uID09PSAnaW5uZXInO1xuXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0ZXh0WCA9IGxheW91dC5jeDtcbiAgICAgIHRleHRZID0gbGF5b3V0LmN5O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4MSA9IChpc0xhYmVsSW5zaWRlID8gKGxheW91dC5yICsgbGF5b3V0LnIwKSAvIDIgKiBkeCA6IGxheW91dC5yICogZHgpICsgY3g7XG4gICAgICB2YXIgeTEgPSAoaXNMYWJlbEluc2lkZSA/IChsYXlvdXQuciArIGxheW91dC5yMCkgLyAyICogZHkgOiBsYXlvdXQuciAqIGR5KSArIGN5O1xuICAgICAgdGV4dFggPSB4MSArIGR4ICogMztcbiAgICAgIHRleHRZID0geTEgKyBkeSAqIDM7XG5cbiAgICAgIGlmICghaXNMYWJlbEluc2lkZSkge1xuICAgICAgICAvLyBGb3Igcm9zZVR5cGVcbiAgICAgICAgdmFyIHgyID0geDEgKyBkeCAqIChsYWJlbExpbmVMZW4gKyByIC0gbGF5b3V0LnIpO1xuICAgICAgICB2YXIgeTIgPSB5MSArIGR5ICogKGxhYmVsTGluZUxlbiArIHIgLSBsYXlvdXQucik7XG4gICAgICAgIHZhciB4MyA9IHgyICsgKGR4IDwgMCA/IC0xIDogMSkgKiBsYWJlbExpbmVMZW4yO1xuICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgdGV4dFggPSB4MyArIChkeCA8IDAgPyAtNSA6IDUpO1xuICAgICAgICB0ZXh0WSA9IHkzO1xuICAgICAgICBsaW5lUG9pbnRzID0gW1t4MSwgeTFdLCBbeDIsIHkyXSwgW3gzLCB5M11dO1xuICAgICAgfVxuXG4gICAgICB0ZXh0QWxpZ24gPSBpc0xhYmVsSW5zaWRlID8gJ2NlbnRlcicgOiBkeCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cblxuICAgIHZhciBmb250ID0gbGFiZWxNb2RlbC5nZXRGb250KCk7XG4gICAgdmFyIGxhYmVsUm90YXRlID0gbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpID8gZHggPCAwID8gLW1pZEFuZ2xlICsgTWF0aC5QSSA6IC1taWRBbmdsZSA6IDA7XG4gICAgdmFyIHRleHQgPSBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnKSB8fCBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCAndG9wJyk7XG4gICAgaGFzTGFiZWxSb3RhdGUgPSAhIWxhYmVsUm90YXRlO1xuICAgIGxheW91dC5sYWJlbCA9IHtcbiAgICAgIHg6IHRleHRYLFxuICAgICAgeTogdGV4dFksXG4gICAgICBwb3NpdGlvbjogbGFiZWxQb3NpdGlvbixcbiAgICAgIGhlaWdodDogdGV4dFJlY3QuaGVpZ2h0LFxuICAgICAgbGVuOiBsYWJlbExpbmVMZW4sXG4gICAgICBsZW4yOiBsYWJlbExpbmVMZW4yLFxuICAgICAgbGluZVBvaW50czogbGluZVBvaW50cyxcbiAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICByb3RhdGlvbjogbGFiZWxSb3RhdGUsXG4gICAgICBpbnNpZGU6IGlzTGFiZWxJbnNpZGVcbiAgICB9OyAvLyBOb3QgbGF5b3V0IHRoZSBpbnNpZGUgbGFiZWxcblxuICAgIGlmICghaXNMYWJlbEluc2lkZSkge1xuICAgICAgbGFiZWxMYXlvdXRMaXN0LnB1c2gobGF5b3V0LmxhYmVsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghaGFzTGFiZWxSb3RhdGUgJiYgc2VyaWVzTW9kZWwuZ2V0KCdhdm9pZExhYmVsT3ZlcmxhcCcpKSB7XG4gICAgYXZvaWRPdmVybGFwKGxhYmVsTGF5b3V0TGlzdCwgY3gsIGN5LCByLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9sYWJlbExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gNDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///447\n");

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

eval("var _number = __webpack_require__(235);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(447);\n\nvar zrUtil = __webpack_require__(230);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var data = seriesModel.getData();\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each('value', function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum('value'); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent('value');\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each('value', function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }, true); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each('value', function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jaGFydC9waWUvcGllTGF5b3V0LmpzP2IzMjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9udW1iZXIgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9udW1iZXJcIik7XG5cbnZhciBwYXJzZVBlcmNlbnQgPSBfbnVtYmVyLnBhcnNlUGVyY2VudDtcbnZhciBsaW5lYXJNYXAgPSBfbnVtYmVyLmxpbmVhck1hcDtcblxudmFyIGxhYmVsTGF5b3V0ID0gcmVxdWlyZShcIi4vbGFiZWxMYXlvdXRcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gX2RlZmF1bHQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICB2YXIgY2VudGVyID0gc2VyaWVzTW9kZWwuZ2V0KCdjZW50ZXInKTtcbiAgICB2YXIgcmFkaXVzID0gc2VyaWVzTW9kZWwuZ2V0KCdyYWRpdXMnKTtcblxuICAgIGlmICghenJVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgICAgcmFkaXVzID0gWzAsIHJhZGl1c107XG4gICAgfVxuXG4gICAgaWYgKCF6clV0aWwuaXNBcnJheShjZW50ZXIpKSB7XG4gICAgICBjZW50ZXIgPSBbY2VudGVyLCBjZW50ZXJdO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gICAgdmFyIGN5ID0gcGFyc2VQZXJjZW50KGNlbnRlclsxXSwgaGVpZ2h0KTtcbiAgICB2YXIgcjAgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzBdLCBzaXplIC8gMik7XG4gICAgdmFyIHIgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzFdLCBzaXplIC8gMik7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAtc2VyaWVzTW9kZWwuZ2V0KCdzdGFydEFuZ2xlJykgKiBSQURJQU47XG4gICAgdmFyIG1pbkFuZ2xlID0gc2VyaWVzTW9kZWwuZ2V0KCdtaW5BbmdsZScpICogUkFESUFOO1xuICAgIHZhciB2YWxpZERhdGFDb3VudCA9IDA7XG4gICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgIWlzTmFOKHZhbHVlKSAmJiB2YWxpZERhdGFDb3VudCsrO1xuICAgIH0pO1xuICAgIHZhciBzdW0gPSBkYXRhLmdldFN1bSgndmFsdWUnKTsgLy8gU3VtIG1heSBiZSAwXG5cbiAgICB2YXIgdW5pdFJhZGlhbiA9IE1hdGguUEkgLyAoc3VtIHx8IHZhbGlkRGF0YUNvdW50KSAqIDI7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNlcmllc01vZGVsLmdldCgnY2xvY2t3aXNlJyk7XG4gICAgdmFyIHJvc2VUeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdyb3NlVHlwZScpO1xuICAgIHZhciBzdGlsbFNob3daZXJvU3VtID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGlsbFNob3daZXJvU3VtJyk7IC8vIFswLi4ubWF4XVxuXG4gICAgdmFyIGV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICBleHRlbnRbMF0gPSAwOyAvLyBJbiB0aGUgY2FzZSBzb21lIHNlY3RvciBhbmdsZSBpcyBzbWFsbGVyIHRoYW4gbWluQW5nbGVcblxuICAgIHZhciByZXN0QW5nbGUgPSBQSTI7XG4gICAgdmFyIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlID0gMDtcbiAgICB2YXIgY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICB2YXIgZGlyID0gY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgIGRhdGEuZWFjaCgndmFsdWUnLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgdmFyIGFuZ2xlO1xuXG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICBhbmdsZTogTmFOLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IE5hTixcbiAgICAgICAgICBlbmRBbmdsZTogTmFOLFxuICAgICAgICAgIGNsb2Nrd2lzZTogY2xvY2t3aXNlLFxuICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgIHI6IHJvc2VUeXBlID8gTmFOIDogclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGSVhNRSDlhbzlrrkgMi4wIOS9huaYryByb3NlVHlwZSDmmK8gYXJlYSDnmoTml7blgJnmiY3mmK/ov5nmoLfvvJ9cblxuXG4gICAgICBpZiAocm9zZVR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICBhbmdsZSA9IHN1bSA9PT0gMCAmJiBzdGlsbFNob3daZXJvU3VtID8gdW5pdFJhZGlhbiA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gUEkyIC8gdmFsaWREYXRhQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSA8IG1pbkFuZ2xlKSB7XG4gICAgICAgIGFuZ2xlID0gbWluQW5nbGU7XG4gICAgICAgIHJlc3RBbmdsZSAtPSBtaW5BbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlICs9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICBzdGFydEFuZ2xlOiBjdXJyZW50QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICByMDogcjAsXG4gICAgICAgIHI6IHJvc2VUeXBlID8gbGluZWFyTWFwKHZhbHVlLCBleHRlbnQsIFtyMCwgcl0pIDogclxuICAgICAgfSk7XG4gICAgICBjdXJyZW50QW5nbGUgPSBlbmRBbmdsZTtcbiAgICB9LCB0cnVlKTsgLy8gU29tZSBzZWN0b3IgaXMgY29uc3RyYWluZWQgYnkgbWluQW5nbGVcbiAgICAvLyBSZXN0IHNlY3RvcnMgbmVlZHMgcmVjYWxjdWxhdGUgYW5nbGVcblxuICAgIGlmIChyZXN0QW5nbGUgPCBQSTIgJiYgdmFsaWREYXRhQ291bnQpIHtcbiAgICAgIC8vIEF2ZXJhZ2UgdGhlIGFuZ2xlIGlmIHJlc3QgYW5nbGUgaXMgbm90IGVub3VnaCBhZnRlciBhbGwgYW5nbGVzIGlzXG4gICAgICAvLyBDb25zdHJhaW5lZCBieSBtaW5BbmdsZVxuICAgICAgaWYgKHJlc3RBbmdsZSA8PSAxZS0zKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IFBJMiAvIHZhbGlkRGF0YUNvdW50O1xuICAgICAgICBkYXRhLmVhY2goJ3ZhbHVlJywgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgbGF5b3V0LmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICBsYXlvdXQuc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiBpZHggKiBhbmdsZTtcbiAgICAgICAgICAgIGxheW91dC5lbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXIgKiAoaWR4ICsgMSkgKiBhbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pdFJhZGlhbiA9IHJlc3RBbmdsZSAvIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlO1xuICAgICAgICBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICBkYXRhLmVhY2goJ3ZhbHVlJywgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gbGF5b3V0LmFuZ2xlID09PSBtaW5BbmdsZSA/IG1pbkFuZ2xlIDogdmFsdWUgKiB1bml0UmFkaWFuO1xuICAgICAgICAgICAgbGF5b3V0LnN0YXJ0QW5nbGUgPSBjdXJyZW50QW5nbGU7XG4gICAgICAgICAgICBsYXlvdXQuZW5kQW5nbGUgPSBjdXJyZW50QW5nbGUgKyBkaXIgKiBhbmdsZTtcbiAgICAgICAgICAgIGN1cnJlbnRBbmdsZSArPSBkaXIgKiBhbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhYmVsTGF5b3V0KHNlcmllc01vZGVsLCByLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NoYXJ0L3BpZS9waWVMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///448\n");

/***/ }),
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(230);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  updateSelectedMap: function (targetList) {\n    this._targetList = targetList.slice();\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9jb21wb25lbnQvaGVscGVyL3NlbGVjdGFibGVNaXhpbi5qcz9hZDcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwienJlbmRlci9saWIvY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIERhdGEgc2VsZWN0YWJsZSBtaXhpbiBmb3IgY2hhcnQgc2VyaWVzLlxuICogVG8gZWFuYmxlIGRhdGEgc2VsZWN0LCBvcHRpb24gb2Ygc2VyaWVzIG11c3QgaGF2ZSBgc2VsZWN0ZWRNb2RlYC5cbiAqIEFuZCBlYWNoIGRhdGEgaXRlbSB3aWxsIHVzZSBgc2VsZWN0ZWRgIHRvIHRvZ2dsZSBpdHNlbGYgc2VsZWN0ZWQgc3RhdHVzXG4gKi9cbnZhciBfZGVmYXVsdCA9IHtcbiAgdXBkYXRlU2VsZWN0ZWRNYXA6IGZ1bmN0aW9uICh0YXJnZXRMaXN0KSB7XG4gICAgdGhpcy5fdGFyZ2V0TGlzdCA9IHRhcmdldExpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9zZWxlY3RUYXJnZXRNYXAgPSB6clV0aWwucmVkdWNlKHRhcmdldExpc3QgfHwgW10sIGZ1bmN0aW9uICh0YXJnZXRNYXAsIHRhcmdldCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQubmFtZSwgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0YXJnZXRNYXA7XG4gICAgfSwgenJVdGlsLmNyZWF0ZUhhc2hNYXAoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVpdGhlciBuYW1lIG9yIGlkIHNob3VsZCBiZSBwYXNzZWQgYXMgaW5wdXQgaGVyZS5cbiAgICogSWYgYm90aCBvZiB0aGVtIGFyZSBkZWZpbmVkLCBpZCBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IG5hbWUgbmFtZSBvZiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gaWQgZGF0YUluZGV4IG9mIGRhdGFcbiAgICovXG4gIC8vIFBFTkdJTkcgSWYgc2VsZWN0ZWRNb2RlIGlzIG51bGwgP1xuICBzZWxlY3Q6IGZ1bmN0aW9uIChuYW1lLCBpZCkge1xuICAgIHZhciB0YXJnZXQgPSBpZCAhPSBudWxsID8gdGhpcy5fdGFyZ2V0TGlzdFtpZF0gOiB0aGlzLl9zZWxlY3RUYXJnZXRNYXAuZ2V0KG5hbWUpO1xuICAgIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG5cbiAgICBpZiAoc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgdGhpcy5fc2VsZWN0VGFyZ2V0TWFwLmVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRhcmdldCAmJiAodGFyZ2V0LnNlbGVjdGVkID0gdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVpdGhlciBuYW1lIG9yIGlkIHNob3VsZCBiZSBwYXNzZWQgYXMgaW5wdXQgaGVyZS5cbiAgICogSWYgYm90aCBvZiB0aGVtIGFyZSBkZWZpbmVkLCBpZCBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IG5hbWUgbmFtZSBvZiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gaWQgZGF0YUluZGV4IG9mIGRhdGFcbiAgICovXG4gIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSwgaWQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gaWQgIT0gbnVsbCA/IHRoaXMuX3RhcmdldExpc3RbaWRdIDogdGhpcy5fc2VsZWN0VGFyZ2V0TWFwLmdldChuYW1lKTsgLy8gdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAvLyBzZWxlY3RlZE1vZGUgIT09ICdzaW5nbGUnICYmIHRhcmdldCAmJiAodGFyZ2V0LnNlbGVjdGVkID0gZmFsc2UpO1xuXG4gICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVpdGhlciBuYW1lIG9yIGlkIHNob3VsZCBiZSBwYXNzZWQgYXMgaW5wdXQgaGVyZS5cbiAgICogSWYgYm90aCBvZiB0aGVtIGFyZSBkZWZpbmVkLCBpZCBpcyB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IG5hbWUgbmFtZSBvZiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gaWQgZGF0YUluZGV4IG9mIGRhdGFcbiAgICovXG4gIHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSwgaWQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gaWQgIT0gbnVsbCA/IHRoaXMuX3RhcmdldExpc3RbaWRdIDogdGhpcy5fc2VsZWN0VGFyZ2V0TWFwLmdldChuYW1lKTtcblxuICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgdGhpc1t0YXJnZXQuc2VsZWN0ZWQgPyAndW5TZWxlY3QnIDogJ3NlbGVjdCddKG5hbWUsIGlkKTtcbiAgICAgIHJldHVybiB0YXJnZXQuc2VsZWN0ZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFaXRoZXIgbmFtZSBvciBpZCBzaG91bGQgYmUgcGFzc2VkIGFzIGlucHV0IGhlcmUuXG4gICAqIElmIGJvdGggb2YgdGhlbSBhcmUgZGVmaW5lZCwgaWQgaXMgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBuYW1lIG5hbWUgb2YgZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGlkIGRhdGFJbmRleCBvZiBkYXRhXG4gICAqL1xuICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAobmFtZSwgaWQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gaWQgIT0gbnVsbCA/IHRoaXMuX3RhcmdldExpc3RbaWRdIDogdGhpcy5fc2VsZWN0VGFyZ2V0TWFwLmdldChuYW1lKTtcbiAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5zZWxlY3RlZDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL2NvbXBvbmVudC9oZWxwZXIvc2VsZWN0YWJsZU1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///469\n");

/***/ }),
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */
/***/ (function(module, exports) {

eval("function _default(seriesType, ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (!legendModels || !legendModels.length) {\n    return;\n  }\n\n  ecModel.eachSeriesByType(seriesType, function (series) {\n    var data = series.getData();\n    data.filterSelf(function (idx) {\n      var name = data.getName(idx); // If in any legend component the status is not selected.\n\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(name)) {\n          return false;\n        }\n      }\n\n      return true;\n    }, this);\n  }, this);\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi9wcm9jZXNzb3IvZGF0YUZpbHRlci5qcz9kNmU0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZhdWx0KHNlcmllc1R5cGUsIGVjTW9kZWwpIHtcbiAgdmFyIGxlZ2VuZE1vZGVscyA9IGVjTW9kZWwuZmluZENvbXBvbmVudHMoe1xuICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICB9KTtcblxuICBpZiAoIWxlZ2VuZE1vZGVscyB8fCAhbGVnZW5kTW9kZWxzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgIGRhdGEuZmlsdGVyU2VsZihmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShpZHgpOyAvLyBJZiBpbiBhbnkgbGVnZW5kIGNvbXBvbmVudCB0aGUgc3RhdHVzIGlzIG5vdCBzZWxlY3RlZC5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRNb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHNbaV0uaXNTZWxlY3RlZChuYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3Byb2Nlc3Nvci9kYXRhRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///497\n");

/***/ }),
/* 498 */,
/* 499 */
/***/ (function(module, exports) {

eval("// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType, ecModel) {\n  // Pie and funnel may use diferrent scope\n  var paletteScope = {};\n  ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n    var dataAll = seriesModel.getRawData();\n    var idxMap = {};\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9lY2hhcnRzL2xpYi92aXN1YWwvZGF0YUNvbG9yLmpzP2ZhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGljayBjb2xvciBmcm9tIHBhbGV0dGUgZm9yIGVhY2ggZGF0YSBpdGVtLlxuLy8gQXBwbGljYWJsZSBmb3IgY2hhcnRzIHRoYXQgcmVxdWlyZSBhcHBseWluZyBjb2xvciBwYWxldHRlXG4vLyBpbiBkYXRhIGxldmVsIChsaWtlIHBpZSwgZnVubmVsLCBjaG9yZCkuXG5mdW5jdGlvbiBfZGVmYXVsdChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gIC8vIFBpZSBhbmQgZnVubmVsIG1heSB1c2UgZGlmZXJyZW50IHNjb3BlXG4gIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgIHZhciBkYXRhQWxsID0gc2VyaWVzTW9kZWwuZ2V0UmF3RGF0YSgpO1xuICAgIHZhciBpZHhNYXAgPSB7fTtcblxuICAgIGlmICghZWNNb2RlbC5pc1Nlcmllc0ZpbHRlcmVkKHNlcmllc01vZGVsKSkge1xuICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgcmF3SWR4ID0gZGF0YS5nZXRSYXdJbmRleChpZHgpO1xuICAgICAgICBpZHhNYXBbcmF3SWR4XSA9IGlkeDtcbiAgICAgIH0pO1xuICAgICAgZGF0YUFsbC5lYWNoKGZ1bmN0aW9uIChyYXdJZHgpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkSWR4ID0gaWR4TWFwW3Jhd0lkeF07IC8vIElmIHNlcmllcy5pdGVtU3R5bGUubm9ybWFsLmNvbG9yIGlzIGEgZnVuY3Rpb24uIGl0ZW1WaXN1YWwgbWF5IGJlIGVuY29kZWRcblxuICAgICAgICB2YXIgc2luZ2xlRGF0YUNvbG9yID0gZmlsdGVyZWRJZHggIT0gbnVsbCAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIHRydWUpO1xuXG4gICAgICAgIGlmICghc2luZ2xlRGF0YUNvbG9yKSB7XG4gICAgICAgICAgLy8gRklYTUUgUGVyZm9ybWFuY2VcbiAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YUFsbC5nZXRJdGVtTW9kZWwocmF3SWR4KTtcbiAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykgfHwgc2VyaWVzTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShkYXRhQWxsLmdldE5hbWUocmF3SWR4KSwgcGFsZXR0ZVNjb3BlKTsgLy8gTGVnZW5kIG1heSB1c2UgdGhlIHZpc3VhbCBpbmZvIGluIGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuXG4gICAgICAgICAgZGF0YUFsbC5zZXRJdGVtVmlzdWFsKHJhd0lkeCwgJ2NvbG9yJywgY29sb3IpOyAvLyBEYXRhIGlzIG5vdCBmaWx0ZXJlZFxuXG4gICAgICAgICAgaWYgKGZpbHRlcmVkSWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChmaWx0ZXJlZElkeCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXQgZGF0YSBhbGwgY29sb3IgZm9yIGxlZ2VuZFxuICAgICAgICAgIGRhdGFBbGwuc2V0SXRlbVZpc3VhbChyYXdJZHgsICdjb2xvcicsIHNpbmdsZURhdGFDb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VjaGFydHMvbGliL3Zpc3VhbC9kYXRhQ29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///499\n");

/***/ }),
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/* styles */\n__webpack_require__(550)\n\nvar Component = __webpack_require__(86)(\n  /* script */\n  __webpack_require__(406),\n  /* template */\n  __webpack_require__(526),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = \"D:\\\\Study\\\\project\\\\vueManageSys\\\\VuemanageSys\\\\vue2-manage-master\\\\src\\\\components\\\\visitorPie.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key !== \"__esModule\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] visitorPie.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (true) {(function () {\n  var hotAPI = __webpack_require__(51)\n  hotAPI.install(__webpack_require__(1), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-d906cdd8\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-d906cdd8\", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlzaXRvclBpZS52dWU/NzhjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIHN0eWxlcyAqL1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3tcXFwibWluaW1pemVcXFwiOmZhbHNlLFxcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1kOTA2Y2RkOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IWxlc3MtbG9hZGVyP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yUGllLnZ1ZVwiKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi92aXNpdG9yUGllLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZDkwNmNkZDhcXFwifSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vdmlzaXRvclBpZS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkQ6XFxcXFN0dWR5XFxcXHByb2plY3RcXFxcdnVlTWFuYWdlU3lzXFxcXFZ1ZW1hbmFnZVN5c1xcXFx2dWUyLW1hbmFnZS1tYXN0ZXJcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcdmlzaXRvclBpZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSB2aXNpdG9yUGllLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1kOTA2Y2RkOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWQ5MDZjZGQ4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3Zpc2l0b3JQaWUudnVlXG4vLyBtb2R1bGUgaWQgPSA1MDVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///505\n");

/***/ }),
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('head-top'), _vm._v(\" \"), _c('visitor-pie', {\n    attrs: {\n      \"pieData\": _vm.pieData\n    }\n  })], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (true) {\n  module.hot.accept()\n  if (module.hot.data) {\n     __webpack_require__(51).rerender(\"data-v-4cd6d3c1\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvdmlzaXRvci52dWU/YWIyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnaGVhZC10b3AnKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3Zpc2l0b3ItcGllJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInBpZURhdGFcIjogX3ZtLnBpZURhdGFcbiAgICB9XG4gIH0pXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNGNkNmQzYzFcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00Y2Q2ZDNjMVwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3JjL3BhZ2UvdmlzaXRvci52dWVcbi8vIG1vZHVsZSBpZCA9IDUxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///517\n");

/***/ }),
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"visitorpie\"\n  }, [_c('div', {\n    staticStyle: {\n      \"width\": \"90%\",\n      \"height\": \"450px\"\n    },\n    attrs: {\n      \"id\": \"visitorpie\"\n    }\n  })])\n}]}\nmodule.exports.render._withStripped = true\nif (true) {\n  module.hot.accept()\n  if (module.hot.data) {\n     __webpack_require__(51).rerender(\"data-v-d906cdd8\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlzaXRvclBpZS52dWU/MjBiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX3ZtLl9tKDApXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ2aXNpdG9ycGllXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljU3R5bGU6IHtcbiAgICAgIFwid2lkdGhcIjogXCI5MCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IFwiNDUwcHhcIlxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJ2aXNpdG9ycGllXCJcbiAgICB9XG4gIH0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi1kOTA2Y2RkOFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWQ5MDZjZGQ4XCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvY29tcG9uZW50cy92aXNpdG9yUGllLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///526\n");

/***/ }),
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(317);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(53)(\"09c6c490\", content, false);\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(317, function() {\n     var newContent = __webpack_require__(317);\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvdmlzaXRvci52dWU/MjRiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTRjZDZkM2MxXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMDljNmM0OTBcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LTRjZDZkM2MxXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XFxcIm1pbmltaXplXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGNkNmQzYzFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1xcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3Zpc2l0b3IudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj97XCJtaW5pbWl6ZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTRjZDZkM2MxXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1wic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL3BhZ2UvdmlzaXRvci52dWVcbi8vIG1vZHVsZSBpZCA9IDU0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///541\n");

/***/ }),
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(326);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(53)(\"4347c9f4\", content, false);\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(326, function() {\n     var newContent = __webpack_require__(326);\n     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvdmlzaXRvclBpZS52dWU/NjQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWQ5MDZjZGQ4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yUGllLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNDM0N2M5ZjRcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/e1xcXCJtaW5pbWl6ZVxcXCI6ZmFsc2UsXFxcInNvdXJjZU1hcFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcImlkXFxcIjpcXFwiZGF0YS12LWQ5MDZjZGQ4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi92aXNpdG9yUGllLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz97XFxcIm1pbmltaXplXFxcIjpmYWxzZSxcXFwic291cmNlTWFwXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZDkwNmNkZDhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1xcXCJzb3VyY2VNYXBcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3Zpc2l0b3JQaWUudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj97XCJtaW5pbWl6ZVwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWQ5MDZjZGQ4XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vbGVzcy1sb2FkZXIvZGlzdC9janMuanM/e1wic291cmNlTWFwXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3JjL2NvbXBvbmVudHMvdmlzaXRvclBpZS52dWVcbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///550\n");

/***/ })
]));